// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod golem {
    pub mod agent {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod common {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type WitType = super::super::super::golem::rpc::types::WitType;
            #[derive(Clone)]
            pub struct TextType {
                pub language_code: _rt::String,
            }
            impl ::core::fmt::Debug for TextType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TextType")
                        .field("language-code", &self.language_code)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum ParameterType {
                Wit(WitType),
                Text(TextType),
            }
            impl ::core::fmt::Debug for ParameterType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ParameterType::Wit(e) => {
                            f.debug_tuple("ParameterType::Wit").field(e).finish()
                        }
                        ParameterType::Text(e) => {
                            f.debug_tuple("ParameterType::Text").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct Structured {
                pub parameters: _rt::Vec<ParameterType>,
            }
            impl ::core::fmt::Debug for Structured {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Structured")
                        .field("parameters", &self.parameters)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Multimodal {
                pub text: Option<_rt::Vec<TextType>>,
            }
            impl ::core::fmt::Debug for Multimodal {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Multimodal").field("text", &self.text).finish()
                }
            }
            #[derive(Clone)]
            pub enum DataSchema {
                Structured(Structured),
                Multimodal(Multimodal),
            }
            impl ::core::fmt::Debug for DataSchema {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        DataSchema::Structured(e) => {
                            f.debug_tuple("DataSchema::Structured").field(e).finish()
                        }
                        DataSchema::Multimodal(e) => {
                            f.debug_tuple("DataSchema::Multimodal").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct AgentConstructor {
                pub name: Option<_rt::String>,
                pub description: _rt::String,
                pub prompt_hint: Option<_rt::String>,
                pub input_schema: DataSchema,
            }
            impl ::core::fmt::Debug for AgentConstructor {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AgentConstructor")
                        .field("name", &self.name)
                        .field("description", &self.description)
                        .field("prompt-hint", &self.prompt_hint)
                        .field("input-schema", &self.input_schema)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct AgentMethod {
                pub name: _rt::String,
                pub description: _rt::String,
                pub prompt_hint: Option<_rt::String>,
                pub input_schema: DataSchema,
                pub output_schema: DataSchema,
            }
            impl ::core::fmt::Debug for AgentMethod {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AgentMethod")
                        .field("name", &self.name)
                        .field("description", &self.description)
                        .field("prompt-hint", &self.prompt_hint)
                        .field("input-schema", &self.input_schema)
                        .field("output-schema", &self.output_schema)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct AgentDependency {
                pub agent_name: _rt::String,
                pub methods: _rt::Vec<AgentMethod>,
            }
            impl ::core::fmt::Debug for AgentDependency {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AgentDependency")
                        .field("agent-name", &self.agent_name)
                        .field("methods", &self.methods)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct AgentType {
                pub type_name: _rt::String,
                pub description: _rt::String,
                pub agent_constructor: AgentConstructor,
                pub methods: _rt::Vec<AgentMethod>,
                pub requires: _rt::Vec<AgentDependency>,
            }
            impl ::core::fmt::Debug for AgentType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AgentType")
                        .field("type-name", &self.type_name)
                        .field("description", &self.description)
                        .field("agent-constructor", &self.agent_constructor)
                        .field("methods", &self.methods)
                        .field("requires", &self.requires)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct ProgressCounter {
                pub steps: u32,
                pub total: u32,
            }
            impl ::core::fmt::Debug for ProgressCounter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ProgressCounter")
                        .field("steps", &self.steps)
                        .field("total", &self.total)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct ProgressReport {
                pub description: _rt::String,
                pub counter: Option<ProgressCounter>,
            }
            impl ::core::fmt::Debug for ProgressReport {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ProgressReport")
                        .field("description", &self.description)
                        .field("counter", &self.counter)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum Error {
                NetworkError,
            }
            impl ::core::fmt::Debug for Error {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Error::NetworkError => {
                            f.debug_tuple("Error::NetworkError").finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum StatusUpdate {
                Error(Error),
                Progress(Option<ProgressReport>),
                Emit(_rt::String),
            }
            impl ::core::fmt::Debug for StatusUpdate {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        StatusUpdate::Error(e) => {
                            f.debug_tuple("StatusUpdate::Error").field(e).finish()
                        }
                        StatusUpdate::Progress(e) => {
                            f.debug_tuple("StatusUpdate::Progress").field(e).finish()
                        }
                        StatusUpdate::Emit(e) => {
                            f.debug_tuple("StatusUpdate::Emit").field(e).finish()
                        }
                    }
                }
            }
        }
    }
    pub mod api {
        /// The Golem host API provides low level access to Golem specific features such as promises and control over
        /// the durability and transactional guarantees the executor provides.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod host {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
            pub type ComponentId = super::super::super::golem::rpc::types::ComponentId;
            pub type Uuid = super::super::super::golem::rpc::types::Uuid;
            pub type WorkerId = super::super::super::golem::rpc::types::WorkerId;
            pub type AgentType = super::super::super::golem::agent::common::AgentType;
            /// An index into the persistent log storing all performed operations of a worker
            pub type OplogIndex = u64;
            /// A promise ID is a value that can be passed to an external Golem API to complete that promise
            /// from an arbitrary external source, while Golem workers can await for this completion.
            #[derive(Clone)]
            pub struct PromiseId {
                pub worker_id: WorkerId,
                pub oplog_idx: OplogIndex,
            }
            impl ::core::fmt::Debug for PromiseId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PromiseId")
                        .field("worker-id", &self.worker_id)
                        .field("oplog-idx", &self.oplog_idx)
                        .finish()
                }
            }
            /// Represents a Golem component's version
            pub type ComponentVersion = u64;
            /// Configures how the executor retries failures
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct RetryPolicy {
                /// The maximum number of retries before the worker becomes permanently failed
                pub max_attempts: u32,
                /// The minimum delay between retries (applied to the first retry)
                pub min_delay: Duration,
                /// The maximum delay between retries
                pub max_delay: Duration,
                /// Multiplier applied to the delay on each retry to implement exponential backoff
                pub multiplier: f64,
                /// The maximum amount of jitter to add to the delay
                pub max_jitter_factor: Option<f64>,
            }
            impl ::core::fmt::Debug for RetryPolicy {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RetryPolicy")
                        .field("max-attempts", &self.max_attempts)
                        .field("min-delay", &self.min_delay)
                        .field("max-delay", &self.max_delay)
                        .field("multiplier", &self.multiplier)
                        .field("max-jitter-factor", &self.max_jitter_factor)
                        .finish()
                }
            }
            /// Configurable persistence level for workers
            #[derive(Clone, Copy)]
            pub enum PersistenceLevel {
                PersistNothing,
                PersistRemoteSideEffects,
                Smart,
            }
            impl ::core::fmt::Debug for PersistenceLevel {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        PersistenceLevel::PersistNothing => {
                            f.debug_tuple("PersistenceLevel::PersistNothing").finish()
                        }
                        PersistenceLevel::PersistRemoteSideEffects => {
                            f.debug_tuple("PersistenceLevel::PersistRemoteSideEffects")
                                .finish()
                        }
                        PersistenceLevel::Smart => {
                            f.debug_tuple("PersistenceLevel::Smart").finish()
                        }
                    }
                }
            }
            /// Describes how to update a worker to a different component version
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum UpdateMode {
                /// Automatic update tries to recover the worker using the new component version
                /// and may fail if there is a divergence.
                Automatic,
                /// Manual, snapshot-based update uses a user-defined implementation of the `save-snapshot` interface
                /// to store the worker's state, and a user-defined implementation of the `load-snapshot` interface to
                /// load it into the new version.
                SnapshotBased,
            }
            impl ::core::fmt::Debug for UpdateMode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        UpdateMode::Automatic => {
                            f.debug_tuple("UpdateMode::Automatic").finish()
                        }
                        UpdateMode::SnapshotBased => {
                            f.debug_tuple("UpdateMode::SnapshotBased").finish()
                        }
                    }
                }
            }
            impl UpdateMode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> UpdateMode {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => UpdateMode::Automatic,
                        1 => UpdateMode::SnapshotBased,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum FilterComparator {
                Equal,
                NotEqual,
                GreaterEqual,
                Greater,
                LessEqual,
                Less,
            }
            impl ::core::fmt::Debug for FilterComparator {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        FilterComparator::Equal => {
                            f.debug_tuple("FilterComparator::Equal").finish()
                        }
                        FilterComparator::NotEqual => {
                            f.debug_tuple("FilterComparator::NotEqual").finish()
                        }
                        FilterComparator::GreaterEqual => {
                            f.debug_tuple("FilterComparator::GreaterEqual").finish()
                        }
                        FilterComparator::Greater => {
                            f.debug_tuple("FilterComparator::Greater").finish()
                        }
                        FilterComparator::LessEqual => {
                            f.debug_tuple("FilterComparator::LessEqual").finish()
                        }
                        FilterComparator::Less => {
                            f.debug_tuple("FilterComparator::Less").finish()
                        }
                    }
                }
            }
            impl FilterComparator {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> FilterComparator {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => FilterComparator::Equal,
                        1 => FilterComparator::NotEqual,
                        2 => FilterComparator::GreaterEqual,
                        3 => FilterComparator::Greater,
                        4 => FilterComparator::LessEqual,
                        5 => FilterComparator::Less,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum StringFilterComparator {
                Equal,
                NotEqual,
                Like,
                NotLike,
            }
            impl ::core::fmt::Debug for StringFilterComparator {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        StringFilterComparator::Equal => {
                            f.debug_tuple("StringFilterComparator::Equal").finish()
                        }
                        StringFilterComparator::NotEqual => {
                            f.debug_tuple("StringFilterComparator::NotEqual").finish()
                        }
                        StringFilterComparator::Like => {
                            f.debug_tuple("StringFilterComparator::Like").finish()
                        }
                        StringFilterComparator::NotLike => {
                            f.debug_tuple("StringFilterComparator::NotLike").finish()
                        }
                    }
                }
            }
            impl StringFilterComparator {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> StringFilterComparator {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => StringFilterComparator::Equal,
                        1 => StringFilterComparator::NotEqual,
                        2 => StringFilterComparator::Like,
                        3 => StringFilterComparator::NotLike,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum WorkerStatus {
                /// The worker is running an invoked function
                Running,
                /// The worker is ready to run an invoked function
                Idle,
                /// An invocation is active but waiting for something (sleeping, waiting for a promise)
                Suspended,
                /// The last invocation was interrupted but will be resumed
                Interrupted,
                /// The last invocation failed and a retry was scheduled
                Retrying,
                /// The last invocation failed and the worker can no longer be used
                Failed,
                /// The worker exited after a successful invocation and can no longer be invoked
                Exited,
            }
            impl ::core::fmt::Debug for WorkerStatus {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        WorkerStatus::Running => {
                            f.debug_tuple("WorkerStatus::Running").finish()
                        }
                        WorkerStatus::Idle => {
                            f.debug_tuple("WorkerStatus::Idle").finish()
                        }
                        WorkerStatus::Suspended => {
                            f.debug_tuple("WorkerStatus::Suspended").finish()
                        }
                        WorkerStatus::Interrupted => {
                            f.debug_tuple("WorkerStatus::Interrupted").finish()
                        }
                        WorkerStatus::Retrying => {
                            f.debug_tuple("WorkerStatus::Retrying").finish()
                        }
                        WorkerStatus::Failed => {
                            f.debug_tuple("WorkerStatus::Failed").finish()
                        }
                        WorkerStatus::Exited => {
                            f.debug_tuple("WorkerStatus::Exited").finish()
                        }
                    }
                }
            }
            impl WorkerStatus {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> WorkerStatus {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => WorkerStatus::Running,
                        1 => WorkerStatus::Idle,
                        2 => WorkerStatus::Suspended,
                        3 => WorkerStatus::Interrupted,
                        4 => WorkerStatus::Retrying,
                        5 => WorkerStatus::Failed,
                        6 => WorkerStatus::Exited,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[derive(Clone)]
            pub struct WorkerNameFilter {
                pub comparator: StringFilterComparator,
                pub value: _rt::String,
            }
            impl ::core::fmt::Debug for WorkerNameFilter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerNameFilter")
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct WorkerStatusFilter {
                pub comparator: FilterComparator,
                pub value: WorkerStatus,
            }
            impl ::core::fmt::Debug for WorkerStatusFilter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerStatusFilter")
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct WorkerVersionFilter {
                pub comparator: FilterComparator,
                pub value: u64,
            }
            impl ::core::fmt::Debug for WorkerVersionFilter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerVersionFilter")
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct WorkerCreatedAtFilter {
                pub comparator: FilterComparator,
                pub value: u64,
            }
            impl ::core::fmt::Debug for WorkerCreatedAtFilter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerCreatedAtFilter")
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct WorkerEnvFilter {
                pub name: _rt::String,
                pub comparator: StringFilterComparator,
                pub value: _rt::String,
            }
            impl ::core::fmt::Debug for WorkerEnvFilter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerEnvFilter")
                        .field("name", &self.name)
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum WorkerPropertyFilter {
                Name(WorkerNameFilter),
                Status(WorkerStatusFilter),
                Version(WorkerVersionFilter),
                CreatedAt(WorkerCreatedAtFilter),
                Env(WorkerEnvFilter),
            }
            impl ::core::fmt::Debug for WorkerPropertyFilter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        WorkerPropertyFilter::Name(e) => {
                            f.debug_tuple("WorkerPropertyFilter::Name").field(e).finish()
                        }
                        WorkerPropertyFilter::Status(e) => {
                            f.debug_tuple("WorkerPropertyFilter::Status")
                                .field(e)
                                .finish()
                        }
                        WorkerPropertyFilter::Version(e) => {
                            f.debug_tuple("WorkerPropertyFilter::Version")
                                .field(e)
                                .finish()
                        }
                        WorkerPropertyFilter::CreatedAt(e) => {
                            f.debug_tuple("WorkerPropertyFilter::CreatedAt")
                                .field(e)
                                .finish()
                        }
                        WorkerPropertyFilter::Env(e) => {
                            f.debug_tuple("WorkerPropertyFilter::Env").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct WorkerAllFilter {
                pub filters: _rt::Vec<WorkerPropertyFilter>,
            }
            impl ::core::fmt::Debug for WorkerAllFilter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerAllFilter")
                        .field("filters", &self.filters)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct WorkerAnyFilter {
                pub filters: _rt::Vec<WorkerAllFilter>,
            }
            impl ::core::fmt::Debug for WorkerAnyFilter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerAnyFilter")
                        .field("filters", &self.filters)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct WorkerMetadata {
                pub worker_id: WorkerId,
                pub args: _rt::Vec<_rt::String>,
                pub env: _rt::Vec<(_rt::String, _rt::String)>,
                pub status: WorkerStatus,
                pub component_version: u64,
                pub retry_count: u64,
            }
            impl ::core::fmt::Debug for WorkerMetadata {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerMetadata")
                        .field("worker-id", &self.worker_id)
                        .field("args", &self.args)
                        .field("env", &self.env)
                        .field("status", &self.status)
                        .field("component-version", &self.component_version)
                        .field("retry-count", &self.retry_count)
                        .finish()
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct GetWorkers {
                handle: _rt::Resource<GetWorkers>,
            }
            impl GetWorkers {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for GetWorkers {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "golem:api/host@1.1.7")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]get-workers"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            /// Target parameter for the `revert-worker` operation
            #[derive(Clone, Copy)]
            pub enum RevertWorkerTarget {
                /// Revert to a specific oplog index. The given index will be the last one to be kept.
                RevertToOplogIndex(OplogIndex),
                /// Revert the last N invocations.
                RevertLastInvocations(u64),
            }
            impl ::core::fmt::Debug for RevertWorkerTarget {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        RevertWorkerTarget::RevertToOplogIndex(e) => {
                            f.debug_tuple("RevertWorkerTarget::RevertToOplogIndex")
                                .field(e)
                                .finish()
                        }
                        RevertWorkerTarget::RevertLastInvocations(e) => {
                            f.debug_tuple("RevertWorkerTarget::RevertLastInvocations")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            /// Indicates which worker the code is running on after `fork`
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ForkResult {
                /// The original worker that called `fork`
                Original,
                /// The new worker
                Forked,
            }
            impl ::core::fmt::Debug for ForkResult {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ForkResult::Original => {
                            f.debug_tuple("ForkResult::Original").finish()
                        }
                        ForkResult::Forked => {
                            f.debug_tuple("ForkResult::Forked").finish()
                        }
                    }
                }
            }
            impl ForkResult {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ForkResult {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => ForkResult::Original,
                        1 => ForkResult::Forked,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            impl GetWorkers {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new(
                    component_id: ComponentId,
                    filter: Option<&WorkerAnyFilter>,
                    precise: bool,
                ) -> Self {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        let super::super::super::golem::rpc::types::ComponentId {
                            uuid: uuid0,
                        } = component_id;
                        let super::super::super::golem::rpc::types::Uuid {
                            high_bits: high_bits1,
                            low_bits: low_bits1,
                        } = uuid0;
                        let (result14_0, result14_1, result14_2) = match filter {
                            Some(e) => {
                                let WorkerAnyFilter { filters: filters2 } = e;
                                let vec13 = filters2;
                                let len13 = vec13.len();
                                let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                                    vec13.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let result13 = if layout13.size() != 0 {
                                    let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                                    if ptr.is_null() {
                                        _rt::alloc::handle_alloc_error(layout13);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec13.into_iter().enumerate() {
                                    let base = result13
                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let WorkerAllFilter { filters: filters3 } = e;
                                        let vec12 = filters3;
                                        let len12 = vec12.len();
                                        let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                                            vec12.len()
                                                * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                            8,
                                        );
                                        let result12 = if layout12.size() != 0 {
                                            let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                            if ptr.is_null() {
                                                _rt::alloc::handle_alloc_error(layout12);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec12.into_iter().enumerate() {
                                            let base = result12
                                                .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                            {
                                                match e {
                                                    WorkerPropertyFilter::Name(e) => {
                                                        *base.add(0).cast::<u8>() = (0i32) as u8;
                                                        let WorkerNameFilter {
                                                            comparator: comparator4,
                                                            value: value4,
                                                        } = e;
                                                        *base.add(8).cast::<u8>() = (comparator4.clone() as i32)
                                                            as u8;
                                                        let vec5 = value4;
                                                        let ptr5 = vec5.as_ptr().cast::<u8>();
                                                        let len5 = vec5.len();
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len5;
                                                        *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr5.cast_mut();
                                                    }
                                                    WorkerPropertyFilter::Status(e) => {
                                                        *base.add(0).cast::<u8>() = (1i32) as u8;
                                                        let WorkerStatusFilter {
                                                            comparator: comparator6,
                                                            value: value6,
                                                        } = e;
                                                        *base.add(8).cast::<u8>() = (comparator6.clone() as i32)
                                                            as u8;
                                                        *base.add(9).cast::<u8>() = (value6.clone() as i32) as u8;
                                                    }
                                                    WorkerPropertyFilter::Version(e) => {
                                                        *base.add(0).cast::<u8>() = (2i32) as u8;
                                                        let WorkerVersionFilter {
                                                            comparator: comparator7,
                                                            value: value7,
                                                        } = e;
                                                        *base.add(8).cast::<u8>() = (comparator7.clone() as i32)
                                                            as u8;
                                                        *base.add(16).cast::<i64>() = _rt::as_i64(value7);
                                                    }
                                                    WorkerPropertyFilter::CreatedAt(e) => {
                                                        *base.add(0).cast::<u8>() = (3i32) as u8;
                                                        let WorkerCreatedAtFilter {
                                                            comparator: comparator8,
                                                            value: value8,
                                                        } = e;
                                                        *base.add(8).cast::<u8>() = (comparator8.clone() as i32)
                                                            as u8;
                                                        *base.add(16).cast::<i64>() = _rt::as_i64(value8);
                                                    }
                                                    WorkerPropertyFilter::Env(e) => {
                                                        *base.add(0).cast::<u8>() = (4i32) as u8;
                                                        let WorkerEnvFilter {
                                                            name: name9,
                                                            comparator: comparator9,
                                                            value: value9,
                                                        } = e;
                                                        let vec10 = name9;
                                                        let ptr10 = vec10.as_ptr().cast::<u8>();
                                                        let len10 = vec10.len();
                                                        *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len10;
                                                        *base.add(8).cast::<*mut u8>() = ptr10.cast_mut();
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (comparator9.clone() as i32) as u8;
                                                        let vec11 = value9;
                                                        let ptr11 = vec11.as_ptr().cast::<u8>();
                                                        let len11 = vec11.len();
                                                        *base
                                                            .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len11;
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr11.cast_mut();
                                                    }
                                                }
                                            }
                                        }
                                        *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len12;
                                        *base.add(0).cast::<*mut u8>() = result12;
                                        cleanup_list.extend_from_slice(&[(result12, layout12)]);
                                    }
                                }
                                cleanup_list.extend_from_slice(&[(result13, layout13)]);
                                (1i32, result13, len13)
                            }
                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:api/host@1.1.7")]
                        unsafe extern "C" {
                            #[link_name = "[constructor]get-workers"]
                            fn wit_import15(
                                _: i64,
                                _: i64,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                            ) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import15(
                            _: i64,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import15(
                                _rt::as_i64(high_bits1),
                                _rt::as_i64(low_bits1),
                                result14_0,
                                result14_1,
                                result14_2,
                                match &precise {
                                    true => 1,
                                    false => 0,
                                },
                            )
                        };
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                _rt::alloc::dealloc(ptr.cast(), layout);
                            }
                        }
                        unsafe { GetWorkers::from_handle(ret as u32) }
                    }
                }
            }
            impl GetWorkers {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get_next(&self) -> Option<_rt::Vec<WorkerMetadata>> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:api/host@1.1.7")]
                        unsafe extern "C" {
                            #[link_name = "[method]get-workers.get-next"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result29 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base28 = l3;
                                    let len28 = l4;
                                    let mut result28 = _rt::Vec::with_capacity(len28);
                                    for i in 0..len28 {
                                        let base = base28
                                            .add(i * (40 + 6 * ::core::mem::size_of::<*const u8>()));
                                        let e28 = {
                                            let l5 = *base.add(0).cast::<i64>();
                                            let l6 = *base.add(8).cast::<i64>();
                                            let l7 = *base.add(16).cast::<*mut u8>();
                                            let l8 = *base
                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len9 = l8;
                                            let bytes9 = _rt::Vec::from_raw_parts(
                                                l7.cast(),
                                                len9,
                                                len9,
                                            );
                                            let l10 = *base
                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l11 = *base
                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base15 = l10;
                                            let len15 = l11;
                                            let mut result15 = _rt::Vec::with_capacity(len15);
                                            for i in 0..len15 {
                                                let base = base15
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                let e15 = {
                                                    let l12 = *base.add(0).cast::<*mut u8>();
                                                    let l13 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len14 = l13;
                                                    let bytes14 = _rt::Vec::from_raw_parts(
                                                        l12.cast(),
                                                        len14,
                                                        len14,
                                                    );
                                                    _rt::string_lift(bytes14)
                                                };
                                                result15.push(e15);
                                            }
                                            _rt::cabi_dealloc(
                                                base15,
                                                len15 * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let l16 = *base
                                                .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l17 = *base
                                                .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base24 = l16;
                                            let len24 = l17;
                                            let mut result24 = _rt::Vec::with_capacity(len24);
                                            for i in 0..len24 {
                                                let base = base24
                                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                                let e24 = {
                                                    let l18 = *base.add(0).cast::<*mut u8>();
                                                    let l19 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len20 = l19;
                                                    let bytes20 = _rt::Vec::from_raw_parts(
                                                        l18.cast(),
                                                        len20,
                                                        len20,
                                                    );
                                                    let l21 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l22 = *base
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len23 = l22;
                                                    let bytes23 = _rt::Vec::from_raw_parts(
                                                        l21.cast(),
                                                        len23,
                                                        len23,
                                                    );
                                                    (_rt::string_lift(bytes20), _rt::string_lift(bytes23))
                                                };
                                                result24.push(e24);
                                            }
                                            _rt::cabi_dealloc(
                                                base24,
                                                len24 * (4 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let l25 = i32::from(
                                                *base
                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            let l26 = *base
                                                .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i64>();
                                            let l27 = *base
                                                .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i64>();
                                            WorkerMetadata {
                                                worker_id: super::super::super::golem::rpc::types::WorkerId {
                                                    component_id: super::super::super::golem::rpc::types::ComponentId {
                                                        uuid: super::super::super::golem::rpc::types::Uuid {
                                                            high_bits: l5 as u64,
                                                            low_bits: l6 as u64,
                                                        },
                                                    },
                                                    worker_name: _rt::string_lift(bytes9),
                                                },
                                                args: result15,
                                                env: result24,
                                                status: WorkerStatus::_lift(l25 as u8),
                                                component_version: l26 as u64,
                                                retry_count: l27 as u64,
                                            }
                                        };
                                        result28.push(e28);
                                    }
                                    _rt::cabi_dealloc(
                                        base28,
                                        len28 * (40 + 6 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    );
                                    result28
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result29
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Create a new promise
            pub fn create_promise() -> PromiseId {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 24 + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 24
                            + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "create-promise"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let l4 = *ptr0.add(16).cast::<*mut u8>();
                    let l5 = *ptr0
                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr0
                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>();
                    let result8 = PromiseId {
                        worker_id: super::super::super::golem::rpc::types::WorkerId {
                            component_id: super::super::super::golem::rpc::types::ComponentId {
                                uuid: super::super::super::golem::rpc::types::Uuid {
                                    high_bits: l2 as u64,
                                    low_bits: l3 as u64,
                                },
                            },
                            worker_name: _rt::string_lift(bytes6),
                        },
                        oplog_idx: l7 as u64,
                    };
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Suspends execution until the given promise gets completed, and returns the payload passed to
            /// the promise completion.
            pub fn await_promise(promise_id: &PromiseId) -> _rt::Vec<u8> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let PromiseId { worker_id: worker_id0, oplog_idx: oplog_idx0 } = promise_id;
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id1,
                        worker_name: worker_name1,
                    } = worker_id0;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid2,
                    } = component_id1;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits3,
                        low_bits: low_bits3,
                    } = uuid2;
                    let vec4 = worker_name1;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "await-promise"]
                        fn wit_import6(
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import6(
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import6(
                            _rt::as_i64(high_bits3),
                            _rt::as_i64(low_bits3),
                            ptr4.cast_mut(),
                            len4,
                            _rt::as_i64(oplog_idx0),
                            ptr5,
                        )
                    };
                    let l7 = *ptr5.add(0).cast::<*mut u8>();
                    let l8 = *ptr5
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let result10 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Checks whether the given promise is completed. If not, it returns None. If the promise is completed,
            /// it returns the payload passed to the promise completion.
            pub fn poll_promise(promise_id: &PromiseId) -> Option<_rt::Vec<u8>> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let PromiseId { worker_id: worker_id0, oplog_idx: oplog_idx0 } = promise_id;
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id1,
                        worker_name: worker_name1,
                    } = worker_id0;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid2,
                    } = component_id1;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits3,
                        low_bits: low_bits3,
                    } = uuid2;
                    let vec4 = worker_name1;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "poll-promise"]
                        fn wit_import6(
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import6(
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import6(
                            _rt::as_i64(high_bits3),
                            _rt::as_i64(low_bits3),
                            ptr4.cast_mut(),
                            len4,
                            _rt::as_i64(oplog_idx0),
                            ptr5,
                        )
                    };
                    let l7 = i32::from(*ptr5.add(0).cast::<u8>());
                    let result11 = match l7 {
                        0 => None,
                        1 => {
                            let e = {
                                let l8 = *ptr5
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l9 = *ptr5
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len10 = l9;
                                _rt::Vec::from_raw_parts(l8.cast(), len10, len10)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Completes the given promise with the given payload. Returns true if the promise was completed, false
            /// if the promise was already completed. The payload is passed to the worker that is awaiting the promise.
            pub fn complete_promise(promise_id: &PromiseId, data: &[u8]) -> bool {
                unsafe {
                    let PromiseId { worker_id: worker_id0, oplog_idx: oplog_idx0 } = promise_id;
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id1,
                        worker_name: worker_name1,
                    } = worker_id0;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid2,
                    } = component_id1;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits3,
                        low_bits: low_bits3,
                    } = uuid2;
                    let vec4 = worker_name1;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    let vec5 = data;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "complete-promise"]
                        fn wit_import6(
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                        ) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import6(
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                    ) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe {
                        wit_import6(
                            _rt::as_i64(high_bits3),
                            _rt::as_i64(low_bits3),
                            ptr4.cast_mut(),
                            len4,
                            _rt::as_i64(oplog_idx0),
                            ptr5.cast_mut(),
                            len5,
                        )
                    };
                    _rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Deletes the given promise
            pub fn delete_promise(promise_id: &PromiseId) -> () {
                unsafe {
                    let PromiseId { worker_id: worker_id0, oplog_idx: oplog_idx0 } = promise_id;
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id1,
                        worker_name: worker_name1,
                    } = worker_id0;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid2,
                    } = component_id1;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits3,
                        low_bits: low_bits3,
                    } = uuid2;
                    let vec4 = worker_name1;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "delete-promise"]
                        fn wit_import5(_: i64, _: i64, _: *mut u8, _: usize, _: i64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import5(
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import5(
                            _rt::as_i64(high_bits3),
                            _rt::as_i64(low_bits3),
                            ptr4.cast_mut(),
                            len4,
                            _rt::as_i64(oplog_idx0),
                        )
                    };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the current position in the persistent op log
            pub fn get_oplog_index() -> OplogIndex {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "get-oplog-index"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Makes the current worker travel back in time and continue execution from the given position in the persistent
            /// op log.
            pub fn set_oplog_index(oplog_idx: OplogIndex) -> () {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "set-oplog-index"]
                        fn wit_import0(_: i64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i64) {
                        unreachable!()
                    }
                    unsafe { wit_import0(_rt::as_i64(oplog_idx)) };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Blocks the execution until the oplog has been written to at least the specified number of replicas,
            /// or the maximum number of replicas if the requested number is higher.
            pub fn oplog_commit(replicas: u8) -> () {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "oplog-commit"]
                        fn wit_import0(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i32) {
                        unreachable!()
                    }
                    unsafe { wit_import0(_rt::as_i32(&replicas)) };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Marks the beginning of an atomic operation.
            /// In case of a failure within the region selected by `mark-begin-operation` and `mark-end-operation`
            /// the whole region will be reexecuted on retry.
            /// The end of the region is when `mark-end-operation` is called with the returned oplog-index.
            pub fn mark_begin_operation() -> OplogIndex {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "mark-begin-operation"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Commits this atomic operation. After `mark-end-operation` is called for a given index, further calls
            /// with the same parameter will do nothing.
            pub fn mark_end_operation(begin: OplogIndex) -> () {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "mark-end-operation"]
                        fn wit_import0(_: i64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i64) {
                        unreachable!()
                    }
                    unsafe { wit_import0(_rt::as_i64(begin)) };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets the current retry policy associated with the worker
            pub fn get_retry_policy() -> RetryPolicy {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 48]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 48]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "get-retry-policy"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i32>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let l4 = *ptr0.add(16).cast::<i64>();
                    let l5 = *ptr0.add(24).cast::<f64>();
                    let l6 = i32::from(*ptr0.add(32).cast::<u8>());
                    let result8 = RetryPolicy {
                        max_attempts: l2 as u32,
                        min_delay: l3 as u64,
                        max_delay: l4 as u64,
                        multiplier: l5,
                        max_jitter_factor: match l6 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l7 = *ptr0.add(40).cast::<f64>();
                                    l7
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    };
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Overrides the current retry policy associated with the worker. Following this call, `get-retry-policy` will return the
            /// new retry policy.
            pub fn set_retry_policy(new_retry_policy: RetryPolicy) -> () {
                unsafe {
                    let RetryPolicy {
                        max_attempts: max_attempts0,
                        min_delay: min_delay0,
                        max_delay: max_delay0,
                        multiplier: multiplier0,
                        max_jitter_factor: max_jitter_factor0,
                    } = new_retry_policy;
                    let (result1_0, result1_1) = match max_jitter_factor0 {
                        Some(e) => (1i32, _rt::as_f64(e)),
                        None => (0i32, 0.0f64),
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "set-retry-policy"]
                        fn wit_import2(_: i32, _: i64, _: i64, _: f64, _: i32, _: f64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(
                        _: i32,
                        _: i64,
                        _: i64,
                        _: f64,
                        _: i32,
                        _: f64,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import2(
                            _rt::as_i32(max_attempts0),
                            _rt::as_i64(min_delay0),
                            _rt::as_i64(max_delay0),
                            _rt::as_f64(multiplier0),
                            result1_0,
                            result1_1,
                        )
                    };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets the worker's current persistence level.
            pub fn get_oplog_persistence_level() -> PersistenceLevel {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "get-oplog-persistence-level"]
                        fn wit_import0() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    let v1 = match ret {
                        0 => PersistenceLevel::PersistNothing,
                        1 => PersistenceLevel::PersistRemoteSideEffects,
                        n => {
                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                            PersistenceLevel::Smart
                        }
                    };
                    v1
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Sets the worker's current persistence level. This can increase the performance of execution in cases where durable
            /// execution is not required.
            pub fn set_oplog_persistence_level(
                new_persistence_level: PersistenceLevel,
            ) -> () {
                unsafe {
                    let result0 = match new_persistence_level {
                        PersistenceLevel::PersistNothing => 0i32,
                        PersistenceLevel::PersistRemoteSideEffects => 1i32,
                        PersistenceLevel::Smart => 2i32,
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "set-oplog-persistence-level"]
                        fn wit_import1(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32) {
                        unreachable!()
                    }
                    unsafe { wit_import1(result0) };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets the current idempotence mode. See `set-idempotence-mode` for details.
            pub fn get_idempotence_mode() -> bool {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "get-idempotence-mode"]
                        fn wit_import0() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    _rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Sets the current idempotence mode. The default is true.
            /// True means side-effects are treated idempotent and Golem guarantees at-least-once semantics.
            /// In case of false the executor provides at-most-once semantics, failing the worker in case it is
            /// not known if the side effect was already executed.
            pub fn set_idempotence_mode(idempotent: bool) -> () {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "set-idempotence-mode"]
                        fn wit_import0(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i32) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import0(
                            match &idempotent {
                                true => 1,
                                false => 0,
                            },
                        )
                    };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Generates an idempotency key. This operation will never be replayed 
            /// i.e. not only is this key generated, but it is persisted and committed, such that the key can be used in third-party systems (e.g. payment processing)
            /// to introduce idempotence.
            pub fn generate_idempotency_key() -> Uuid {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "generate-idempotency-key"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let result4 = super::super::super::golem::rpc::types::Uuid {
                        high_bits: l2 as u64,
                        low_bits: l3 as u64,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Initiates an update attempt for the given worker. The function returns immediately once the request has been processed,
            /// not waiting for the worker to get updated.
            pub fn update_worker(
                worker_id: &WorkerId,
                target_version: ComponentVersion,
                mode: UpdateMode,
            ) -> () {
                unsafe {
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id0,
                        worker_name: worker_name0,
                    } = worker_id;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid1,
                    } = component_id0;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits2,
                        low_bits: low_bits2,
                    } = uuid1;
                    let vec3 = worker_name0;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "update-worker"]
                        fn wit_import4(
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: i32,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import4(
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: i32,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import4(
                            _rt::as_i64(high_bits2),
                            _rt::as_i64(low_bits2),
                            ptr3.cast_mut(),
                            len3,
                            _rt::as_i64(target_version),
                            mode.clone() as i32,
                        )
                    };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get current worker metadata
            pub fn get_self_metadata() -> WorkerMetadata {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 40 + 6 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 40
                            + 6 * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "get-self-metadata"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let l4 = *ptr0.add(16).cast::<*mut u8>();
                    let l5 = *ptr0
                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr0
                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr0
                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base12 = l7;
                    let len12 = l8;
                    let mut result12 = _rt::Vec::with_capacity(len12);
                    for i in 0..len12 {
                        let base = base12
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e12 = {
                            let l9 = *base.add(0).cast::<*mut u8>();
                            let l10 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len11 = l10;
                            let bytes11 = _rt::Vec::from_raw_parts(
                                l9.cast(),
                                len11,
                                len11,
                            );
                            _rt::string_lift(bytes11)
                        };
                        result12.push(e12);
                    }
                    _rt::cabi_dealloc(
                        base12,
                        len12 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l13 = *ptr0
                        .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l14 = *ptr0
                        .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base21 = l13;
                    let len21 = l14;
                    let mut result21 = _rt::Vec::with_capacity(len21);
                    for i in 0..len21 {
                        let base = base21
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e21 = {
                            let l15 = *base.add(0).cast::<*mut u8>();
                            let l16 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len17 = l16;
                            let bytes17 = _rt::Vec::from_raw_parts(
                                l15.cast(),
                                len17,
                                len17,
                            );
                            let l18 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l19 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len20 = l19;
                            let bytes20 = _rt::Vec::from_raw_parts(
                                l18.cast(),
                                len20,
                                len20,
                            );
                            (_rt::string_lift(bytes17), _rt::string_lift(bytes20))
                        };
                        result21.push(e21);
                    }
                    _rt::cabi_dealloc(
                        base21,
                        len21 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l22 = i32::from(
                        *ptr0
                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l23 = *ptr0
                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>();
                    let l24 = *ptr0
                        .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>();
                    let result25 = WorkerMetadata {
                        worker_id: super::super::super::golem::rpc::types::WorkerId {
                            component_id: super::super::super::golem::rpc::types::ComponentId {
                                uuid: super::super::super::golem::rpc::types::Uuid {
                                    high_bits: l2 as u64,
                                    low_bits: l3 as u64,
                                },
                            },
                            worker_name: _rt::string_lift(bytes6),
                        },
                        args: result12,
                        env: result21,
                        status: WorkerStatus::_lift(l22 as u8),
                        component_version: l23 as u64,
                        retry_count: l24 as u64,
                    };
                    result25
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get worker metadata
            pub fn get_worker_metadata(worker_id: &WorkerId) -> Option<WorkerMetadata> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 48 + 6 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 48
                            + 6 * ::core::mem::size_of::<*const u8>()],
                    );
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id0,
                        worker_name: worker_name0,
                    } = worker_id;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid1,
                    } = component_id0;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits2,
                        low_bits: low_bits2,
                    } = uuid1;
                    let vec3 = worker_name0;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "get-worker-metadata"]
                        fn wit_import5(_: i64, _: i64, _: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import5(
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import5(
                            _rt::as_i64(high_bits2),
                            _rt::as_i64(low_bits2),
                            ptr3.cast_mut(),
                            len3,
                            ptr4,
                        )
                    };
                    let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                    let result30 = match l6 {
                        0 => None,
                        1 => {
                            let e = {
                                let l7 = *ptr4.add(8).cast::<i64>();
                                let l8 = *ptr4.add(16).cast::<i64>();
                                let l9 = *ptr4.add(24).cast::<*mut u8>();
                                let l10 = *ptr4
                                    .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len11 = l10;
                                let bytes11 = _rt::Vec::from_raw_parts(
                                    l9.cast(),
                                    len11,
                                    len11,
                                );
                                let l12 = *ptr4
                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l13 = *ptr4
                                    .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base17 = l12;
                                let len17 = l13;
                                let mut result17 = _rt::Vec::with_capacity(len17);
                                for i in 0..len17 {
                                    let base = base17
                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                    let e17 = {
                                        let l14 = *base.add(0).cast::<*mut u8>();
                                        let l15 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len16 = l15;
                                        let bytes16 = _rt::Vec::from_raw_parts(
                                            l14.cast(),
                                            len16,
                                            len16,
                                        );
                                        _rt::string_lift(bytes16)
                                    };
                                    result17.push(e17);
                                }
                                _rt::cabi_dealloc(
                                    base17,
                                    len17 * (2 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let l18 = *ptr4
                                    .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l19 = *ptr4
                                    .add(24 + 5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base26 = l18;
                                let len26 = l19;
                                let mut result26 = _rt::Vec::with_capacity(len26);
                                for i in 0..len26 {
                                    let base = base26
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e26 = {
                                        let l20 = *base.add(0).cast::<*mut u8>();
                                        let l21 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len22 = l21;
                                        let bytes22 = _rt::Vec::from_raw_parts(
                                            l20.cast(),
                                            len22,
                                            len22,
                                        );
                                        let l23 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l24 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len25 = l24;
                                        let bytes25 = _rt::Vec::from_raw_parts(
                                            l23.cast(),
                                            len25,
                                            len25,
                                        );
                                        (_rt::string_lift(bytes22), _rt::string_lift(bytes25))
                                    };
                                    result26.push(e26);
                                }
                                _rt::cabi_dealloc(
                                    base26,
                                    len26 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let l27 = i32::from(
                                    *ptr4
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l28 = *ptr4
                                    .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i64>();
                                let l29 = *ptr4
                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i64>();
                                WorkerMetadata {
                                    worker_id: super::super::super::golem::rpc::types::WorkerId {
                                        component_id: super::super::super::golem::rpc::types::ComponentId {
                                            uuid: super::super::super::golem::rpc::types::Uuid {
                                                high_bits: l7 as u64,
                                                low_bits: l8 as u64,
                                            },
                                        },
                                        worker_name: _rt::string_lift(bytes11),
                                    },
                                    args: result17,
                                    env: result26,
                                    status: WorkerStatus::_lift(l27 as u8),
                                    component_version: l28 as u64,
                                    retry_count: l29 as u64,
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result30
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Fork a worker to another worker at a given oplog index
            pub fn fork_worker(
                source_worker_id: &WorkerId,
                target_worker_id: &WorkerId,
                oplog_idx_cut_off: OplogIndex,
            ) -> () {
                unsafe {
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id0,
                        worker_name: worker_name0,
                    } = source_worker_id;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid1,
                    } = component_id0;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits2,
                        low_bits: low_bits2,
                    } = uuid1;
                    let vec3 = worker_name0;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id4,
                        worker_name: worker_name4,
                    } = target_worker_id;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid5,
                    } = component_id4;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits6,
                        low_bits: low_bits6,
                    } = uuid5;
                    let vec7 = worker_name4;
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "fork-worker"]
                        fn wit_import8(
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import8(
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import8(
                            _rt::as_i64(high_bits2),
                            _rt::as_i64(low_bits2),
                            ptr3.cast_mut(),
                            len3,
                            _rt::as_i64(high_bits6),
                            _rt::as_i64(low_bits6),
                            ptr7.cast_mut(),
                            len7,
                            _rt::as_i64(oplog_idx_cut_off),
                        )
                    };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Revert a worker to a previous state
            pub fn revert_worker(
                worker_id: &WorkerId,
                revert_target: RevertWorkerTarget,
            ) -> () {
                unsafe {
                    let super::super::super::golem::rpc::types::WorkerId {
                        component_id: component_id0,
                        worker_name: worker_name0,
                    } = worker_id;
                    let super::super::super::golem::rpc::types::ComponentId {
                        uuid: uuid1,
                    } = component_id0;
                    let super::super::super::golem::rpc::types::Uuid {
                        high_bits: high_bits2,
                        low_bits: low_bits2,
                    } = uuid1;
                    let vec3 = worker_name0;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let (result4_0, result4_1) = match revert_target {
                        RevertWorkerTarget::RevertToOplogIndex(e) => {
                            (0i32, _rt::as_i64(e))
                        }
                        RevertWorkerTarget::RevertLastInvocations(e) => {
                            (1i32, _rt::as_i64(e))
                        }
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "revert-worker"]
                        fn wit_import5(
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i64,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import5(
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i64,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import5(
                            _rt::as_i64(high_bits2),
                            _rt::as_i64(low_bits2),
                            ptr3.cast_mut(),
                            len3,
                            result4_0,
                            result4_1,
                        )
                    };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the component-id for a given component reference.
            /// Returns none when no component with the specified reference exists.
            /// The syntax of the component reference is implementation dependent.
            ///
            /// Golem OSS: "{component_name}"
            /// Golem Cloud:
            ///     1: "{component_name}" -> will resolve in current account and project
            ///     2: "{project_name}/{component_name}" -> will resolve in current account
            ///     3: "{account_id}/{project_name}/{component_name}"
            pub fn resolve_component_id(
                component_reference: &str,
            ) -> Option<ComponentId> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let vec0 = component_reference;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "resolve-component-id"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result6 = match l3 {
                        0 => None,
                        1 => {
                            let e = {
                                let l4 = *ptr1.add(8).cast::<i64>();
                                let l5 = *ptr1.add(16).cast::<i64>();
                                super::super::super::golem::rpc::types::ComponentId {
                                    uuid: super::super::super::golem::rpc::types::Uuid {
                                        high_bits: l4 as u64,
                                        low_bits: l5 as u64,
                                    },
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result6
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the worker-id for a given component and worker name.
            /// Returns none when no component for the specified reference exists.
            pub fn resolve_worker_id(
                component_reference: &str,
                worker_name: &str,
            ) -> Option<WorkerId> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 24 + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 24
                            + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = component_reference;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = worker_name;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "resolve-worker-id"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result10 = match l4 {
                        0 => None,
                        1 => {
                            let e = {
                                let l5 = *ptr2.add(8).cast::<i64>();
                                let l6 = *ptr2.add(16).cast::<i64>();
                                let l7 = *ptr2.add(24).cast::<*mut u8>();
                                let l8 = *ptr2
                                    .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len9 = l8;
                                let bytes9 = _rt::Vec::from_raw_parts(
                                    l7.cast(),
                                    len9,
                                    len9,
                                );
                                super::super::super::golem::rpc::types::WorkerId {
                                    component_id: super::super::super::golem::rpc::types::ComponentId {
                                        uuid: super::super::super::golem::rpc::types::Uuid {
                                            high_bits: l5 as u64,
                                            low_bits: l6 as u64,
                                        },
                                    },
                                    worker_name: _rt::string_lift(bytes9),
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the worker-id for a given component and worker name.
            /// Returns none when no component for the specified component-reference or no worker with the specified worker-name exists.
            pub fn resolve_worker_id_strict(
                component_reference: &str,
                worker_name: &str,
            ) -> Option<WorkerId> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 24 + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 24
                            + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = component_reference;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = worker_name;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "resolve-worker-id-strict"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result10 = match l4 {
                        0 => None,
                        1 => {
                            let e = {
                                let l5 = *ptr2.add(8).cast::<i64>();
                                let l6 = *ptr2.add(16).cast::<i64>();
                                let l7 = *ptr2.add(24).cast::<*mut u8>();
                                let l8 = *ptr2
                                    .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len9 = l8;
                                let bytes9 = _rt::Vec::from_raw_parts(
                                    l7.cast(),
                                    len9,
                                    len9,
                                );
                                super::super::super::golem::rpc::types::WorkerId {
                                    component_id: super::super::super::golem::rpc::types::ComponentId {
                                        uuid: super::super::super::golem::rpc::types::Uuid {
                                            high_bits: l5 as u64,
                                            low_bits: l6 as u64,
                                        },
                                    },
                                    worker_name: _rt::string_lift(bytes9),
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Forks the current worker at the current execution point. The new worker gets the `new-name` worker name,
            /// and this worker continues running as well. The return value is going to be different in this worker and
            /// the forked worker.
            pub fn fork(new_name: &str) -> ForkResult {
                unsafe {
                    let vec0 = new_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "fork"]
                        fn wit_import1(_: *mut u8, _: usize) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import1(ptr0.cast_mut(), len0) };
                    ForkResult::_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn discover_agent_types() -> _rt::Vec<AgentType> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "discover-agent-types"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base353 = l2;
                    let len353 = l3;
                    let mut result353 = _rt::Vec::with_capacity(len353);
                    for i in 0..len353 {
                        let base = base353
                            .add(i * (20 * ::core::mem::size_of::<*const u8>()));
                        let e353 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            let l7 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            let l10 = i32::from(
                                *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l14 = *base
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l15 = *base
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len16 = l15;
                            let bytes16 = _rt::Vec::from_raw_parts(
                                l14.cast(),
                                len16,
                                len16,
                            );
                            let l17 = i32::from(
                                *base
                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l21 = i32::from(
                                *base
                                    .add(12 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            use super::super::super::golem::agent::common::DataSchema as V80;
                            let v80 = match l21 {
                                0 => {
                                    let e80 = {
                                        let l22 = *base
                                            .add(13 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l23 = *base
                                            .add(14 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base72 = l22;
                                        let len72 = l23;
                                        let mut result72 = _rt::Vec::with_capacity(len72);
                                        for i in 0..len72 {
                                            let base = base72
                                                .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                            let e72 = {
                                                let l24 = i32::from(*base.add(0).cast::<u8>());
                                                use super::super::super::golem::agent::common::ParameterType as V71;
                                                let v71 = match l24 {
                                                    0 => {
                                                        let e71 = {
                                                            let l25 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l26 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base67 = l25;
                                                            let len67 = l26;
                                                            let mut result67 = _rt::Vec::with_capacity(len67);
                                                            for i in 0..len67 {
                                                                let base = base67.add(i * 24);
                                                                let e67 = {
                                                                    let l27 = i32::from(*base.add(0).cast::<u8>());
                                                                    use super::super::super::golem::rpc::types::WitTypeNode as V66;
                                                                    let v66 = match l27 {
                                                                        0 => {
                                                                            let e66 = {
                                                                                let l28 = *base.add(8).cast::<*mut u8>();
                                                                                let l29 = *base
                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>();
                                                                                let base34 = l28;
                                                                                let len34 = l29;
                                                                                let mut result34 = _rt::Vec::with_capacity(len34);
                                                                                for i in 0..len34 {
                                                                                    let base = base34
                                                                                        .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                    let e34 = {
                                                                                        let l30 = *base.add(0).cast::<*mut u8>();
                                                                                        let l31 = *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len32 = l31;
                                                                                        let bytes32 = _rt::Vec::from_raw_parts(
                                                                                            l30.cast(),
                                                                                            len32,
                                                                                            len32,
                                                                                        );
                                                                                        let l33 = *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i32>();
                                                                                        (_rt::string_lift(bytes32), l33)
                                                                                    };
                                                                                    result34.push(e34);
                                                                                }
                                                                                _rt::cabi_dealloc(
                                                                                    base34,
                                                                                    len34 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                );
                                                                                result34
                                                                            };
                                                                            V66::RecordType(e66)
                                                                        }
                                                                        1 => {
                                                                            let e66 = {
                                                                                let l35 = *base.add(8).cast::<*mut u8>();
                                                                                let l36 = *base
                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>();
                                                                                let base42 = l35;
                                                                                let len42 = l36;
                                                                                let mut result42 = _rt::Vec::with_capacity(len42);
                                                                                for i in 0..len42 {
                                                                                    let base = base42
                                                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                    let e42 = {
                                                                                        let l37 = *base.add(0).cast::<*mut u8>();
                                                                                        let l38 = *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len39 = l38;
                                                                                        let bytes39 = _rt::Vec::from_raw_parts(
                                                                                            l37.cast(),
                                                                                            len39,
                                                                                            len39,
                                                                                        );
                                                                                        let l40 = i32::from(
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>(),
                                                                                        );
                                                                                        (
                                                                                            _rt::string_lift(bytes39),
                                                                                            match l40 {
                                                                                                0 => None,
                                                                                                1 => {
                                                                                                    let e = {
                                                                                                        let l41 = *base
                                                                                                            .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<i32>();
                                                                                                        l41
                                                                                                    };
                                                                                                    Some(e)
                                                                                                }
                                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                                            },
                                                                                        )
                                                                                    };
                                                                                    result42.push(e42);
                                                                                }
                                                                                _rt::cabi_dealloc(
                                                                                    base42,
                                                                                    len42 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                );
                                                                                result42
                                                                            };
                                                                            V66::VariantType(e66)
                                                                        }
                                                                        2 => {
                                                                            let e66 = {
                                                                                let l43 = *base.add(8).cast::<*mut u8>();
                                                                                let l44 = *base
                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>();
                                                                                let base48 = l43;
                                                                                let len48 = l44;
                                                                                let mut result48 = _rt::Vec::with_capacity(len48);
                                                                                for i in 0..len48 {
                                                                                    let base = base48
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    let e48 = {
                                                                                        let l45 = *base.add(0).cast::<*mut u8>();
                                                                                        let l46 = *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len47 = l46;
                                                                                        let bytes47 = _rt::Vec::from_raw_parts(
                                                                                            l45.cast(),
                                                                                            len47,
                                                                                            len47,
                                                                                        );
                                                                                        _rt::string_lift(bytes47)
                                                                                    };
                                                                                    result48.push(e48);
                                                                                }
                                                                                _rt::cabi_dealloc(
                                                                                    base48,
                                                                                    len48 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                );
                                                                                result48
                                                                            };
                                                                            V66::EnumType(e66)
                                                                        }
                                                                        3 => {
                                                                            let e66 = {
                                                                                let l49 = *base.add(8).cast::<*mut u8>();
                                                                                let l50 = *base
                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>();
                                                                                let base54 = l49;
                                                                                let len54 = l50;
                                                                                let mut result54 = _rt::Vec::with_capacity(len54);
                                                                                for i in 0..len54 {
                                                                                    let base = base54
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    let e54 = {
                                                                                        let l51 = *base.add(0).cast::<*mut u8>();
                                                                                        let l52 = *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len53 = l52;
                                                                                        let bytes53 = _rt::Vec::from_raw_parts(
                                                                                            l51.cast(),
                                                                                            len53,
                                                                                            len53,
                                                                                        );
                                                                                        _rt::string_lift(bytes53)
                                                                                    };
                                                                                    result54.push(e54);
                                                                                }
                                                                                _rt::cabi_dealloc(
                                                                                    base54,
                                                                                    len54 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                );
                                                                                result54
                                                                            };
                                                                            V66::FlagsType(e66)
                                                                        }
                                                                        4 => {
                                                                            let e66 = {
                                                                                let l55 = *base.add(8).cast::<*mut u8>();
                                                                                let l56 = *base
                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>();
                                                                                let len57 = l56;
                                                                                _rt::Vec::from_raw_parts(l55.cast(), len57, len57)
                                                                            };
                                                                            V66::TupleType(e66)
                                                                        }
                                                                        5 => {
                                                                            let e66 = {
                                                                                let l58 = *base.add(8).cast::<i32>();
                                                                                l58
                                                                            };
                                                                            V66::ListType(e66)
                                                                        }
                                                                        6 => {
                                                                            let e66 = {
                                                                                let l59 = *base.add(8).cast::<i32>();
                                                                                l59
                                                                            };
                                                                            V66::OptionType(e66)
                                                                        }
                                                                        7 => {
                                                                            let e66 = {
                                                                                let l60 = i32::from(*base.add(8).cast::<u8>());
                                                                                let l62 = i32::from(*base.add(16).cast::<u8>());
                                                                                (
                                                                                    match l60 {
                                                                                        0 => None,
                                                                                        1 => {
                                                                                            let e = {
                                                                                                let l61 = *base.add(12).cast::<i32>();
                                                                                                l61
                                                                                            };
                                                                                            Some(e)
                                                                                        }
                                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                                    },
                                                                                    match l62 {
                                                                                        0 => None,
                                                                                        1 => {
                                                                                            let e = {
                                                                                                let l63 = *base.add(20).cast::<i32>();
                                                                                                l63
                                                                                            };
                                                                                            Some(e)
                                                                                        }
                                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                                    },
                                                                                )
                                                                            };
                                                                            V66::ResultType(e66)
                                                                        }
                                                                        8 => V66::PrimU8Type,
                                                                        9 => V66::PrimU16Type,
                                                                        10 => V66::PrimU32Type,
                                                                        11 => V66::PrimU64Type,
                                                                        12 => V66::PrimS8Type,
                                                                        13 => V66::PrimS16Type,
                                                                        14 => V66::PrimS32Type,
                                                                        15 => V66::PrimS64Type,
                                                                        16 => V66::PrimF32Type,
                                                                        17 => V66::PrimF64Type,
                                                                        18 => V66::PrimCharType,
                                                                        19 => V66::PrimBoolType,
                                                                        20 => V66::PrimStringType,
                                                                        n => {
                                                                            debug_assert_eq!(n, 21, "invalid enum discriminant");
                                                                            let e66 = {
                                                                                let l64 = *base.add(8).cast::<i64>();
                                                                                let l65 = i32::from(*base.add(16).cast::<u8>());
                                                                                (
                                                                                    l64 as u64,
                                                                                    super::super::super::golem::rpc::types::ResourceMode::_lift(
                                                                                        l65 as u8,
                                                                                    ),
                                                                                )
                                                                            };
                                                                            V66::HandleType(e66)
                                                                        }
                                                                    };
                                                                    v66
                                                                };
                                                                result67.push(e67);
                                                            }
                                                            _rt::cabi_dealloc(base67, len67 * 24, 8);
                                                            super::super::super::golem::rpc::types::WitType {
                                                                nodes: result67,
                                                            }
                                                        };
                                                        V71::Wit(e71)
                                                    }
                                                    n => {
                                                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                        let e71 = {
                                                            let l68 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l69 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len70 = l69;
                                                            let bytes70 = _rt::Vec::from_raw_parts(
                                                                l68.cast(),
                                                                len70,
                                                                len70,
                                                            );
                                                            super::super::super::golem::agent::common::TextType {
                                                                language_code: _rt::string_lift(bytes70),
                                                            }
                                                        };
                                                        V71::Text(e71)
                                                    }
                                                };
                                                v71
                                            };
                                            result72.push(e72);
                                        }
                                        _rt::cabi_dealloc(
                                            base72,
                                            len72 * (3 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        super::super::super::golem::agent::common::Structured {
                                            parameters: result72,
                                        }
                                    };
                                    V80::Structured(e80)
                                }
                                n => {
                                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                                    let e80 = {
                                        let l73 = i32::from(
                                            *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        super::super::super::golem::agent::common::Multimodal {
                                            text: match l73 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l74 = *base
                                                            .add(14 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l75 = *base
                                                            .add(15 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let base79 = l74;
                                                        let len79 = l75;
                                                        let mut result79 = _rt::Vec::with_capacity(len79);
                                                        for i in 0..len79 {
                                                            let base = base79
                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                            let e79 = {
                                                                let l76 = *base.add(0).cast::<*mut u8>();
                                                                let l77 = *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let len78 = l77;
                                                                let bytes78 = _rt::Vec::from_raw_parts(
                                                                    l76.cast(),
                                                                    len78,
                                                                    len78,
                                                                );
                                                                super::super::super::golem::agent::common::TextType {
                                                                    language_code: _rt::string_lift(bytes78),
                                                                }
                                                            };
                                                            result79.push(e79);
                                                        }
                                                        _rt::cabi_dealloc(
                                                            base79,
                                                            len79 * (2 * ::core::mem::size_of::<*const u8>()),
                                                            ::core::mem::size_of::<*const u8>(),
                                                        );
                                                        result79
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        }
                                    };
                                    V80::Multimodal(e80)
                                }
                            };
                            let l81 = *base
                                .add(16 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l82 = *base
                                .add(17 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base213 = l81;
                            let len213 = l82;
                            let mut result213 = _rt::Vec::with_capacity(len213);
                            for i in 0..len213 {
                                let base = base213
                                    .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                                let e213 = {
                                    let l83 = *base.add(0).cast::<*mut u8>();
                                    let l84 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len85 = l84;
                                    let bytes85 = _rt::Vec::from_raw_parts(
                                        l83.cast(),
                                        len85,
                                        len85,
                                    );
                                    let l86 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l87 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len88 = l87;
                                    let bytes88 = _rt::Vec::from_raw_parts(
                                        l86.cast(),
                                        len88,
                                        len88,
                                    );
                                    let l89 = i32::from(
                                        *base
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l93 = i32::from(
                                        *base
                                            .add(7 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    use super::super::super::golem::agent::common::DataSchema as V152;
                                    let v152 = match l93 {
                                        0 => {
                                            let e152 = {
                                                let l94 = *base
                                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l95 = *base
                                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base144 = l94;
                                                let len144 = l95;
                                                let mut result144 = _rt::Vec::with_capacity(len144);
                                                for i in 0..len144 {
                                                    let base = base144
                                                        .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                    let e144 = {
                                                        let l96 = i32::from(*base.add(0).cast::<u8>());
                                                        use super::super::super::golem::agent::common::ParameterType as V143;
                                                        let v143 = match l96 {
                                                            0 => {
                                                                let e143 = {
                                                                    let l97 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l98 = *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base139 = l97;
                                                                    let len139 = l98;
                                                                    let mut result139 = _rt::Vec::with_capacity(len139);
                                                                    for i in 0..len139 {
                                                                        let base = base139.add(i * 24);
                                                                        let e139 = {
                                                                            let l99 = i32::from(*base.add(0).cast::<u8>());
                                                                            use super::super::super::golem::rpc::types::WitTypeNode as V138;
                                                                            let v138 = match l99 {
                                                                                0 => {
                                                                                    let e138 = {
                                                                                        let l100 = *base.add(8).cast::<*mut u8>();
                                                                                        let l101 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let base106 = l100;
                                                                                        let len106 = l101;
                                                                                        let mut result106 = _rt::Vec::with_capacity(len106);
                                                                                        for i in 0..len106 {
                                                                                            let base = base106
                                                                                                .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                            let e106 = {
                                                                                                let l102 = *base.add(0).cast::<*mut u8>();
                                                                                                let l103 = *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len104 = l103;
                                                                                                let bytes104 = _rt::Vec::from_raw_parts(
                                                                                                    l102.cast(),
                                                                                                    len104,
                                                                                                    len104,
                                                                                                );
                                                                                                let l105 = *base
                                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<i32>();
                                                                                                (_rt::string_lift(bytes104), l105)
                                                                                            };
                                                                                            result106.push(e106);
                                                                                        }
                                                                                        _rt::cabi_dealloc(
                                                                                            base106,
                                                                                            len106 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                            ::core::mem::size_of::<*const u8>(),
                                                                                        );
                                                                                        result106
                                                                                    };
                                                                                    V138::RecordType(e138)
                                                                                }
                                                                                1 => {
                                                                                    let e138 = {
                                                                                        let l107 = *base.add(8).cast::<*mut u8>();
                                                                                        let l108 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let base114 = l107;
                                                                                        let len114 = l108;
                                                                                        let mut result114 = _rt::Vec::with_capacity(len114);
                                                                                        for i in 0..len114 {
                                                                                            let base = base114
                                                                                                .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                            let e114 = {
                                                                                                let l109 = *base.add(0).cast::<*mut u8>();
                                                                                                let l110 = *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len111 = l110;
                                                                                                let bytes111 = _rt::Vec::from_raw_parts(
                                                                                                    l109.cast(),
                                                                                                    len111,
                                                                                                    len111,
                                                                                                );
                                                                                                let l112 = i32::from(
                                                                                                    *base
                                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<u8>(),
                                                                                                );
                                                                                                (
                                                                                                    _rt::string_lift(bytes111),
                                                                                                    match l112 {
                                                                                                        0 => None,
                                                                                                        1 => {
                                                                                                            let e = {
                                                                                                                let l113 = *base
                                                                                                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                                    .cast::<i32>();
                                                                                                                l113
                                                                                                            };
                                                                                                            Some(e)
                                                                                                        }
                                                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                                                    },
                                                                                                )
                                                                                            };
                                                                                            result114.push(e114);
                                                                                        }
                                                                                        _rt::cabi_dealloc(
                                                                                            base114,
                                                                                            len114 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                            ::core::mem::size_of::<*const u8>(),
                                                                                        );
                                                                                        result114
                                                                                    };
                                                                                    V138::VariantType(e138)
                                                                                }
                                                                                2 => {
                                                                                    let e138 = {
                                                                                        let l115 = *base.add(8).cast::<*mut u8>();
                                                                                        let l116 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let base120 = l115;
                                                                                        let len120 = l116;
                                                                                        let mut result120 = _rt::Vec::with_capacity(len120);
                                                                                        for i in 0..len120 {
                                                                                            let base = base120
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            let e120 = {
                                                                                                let l117 = *base.add(0).cast::<*mut u8>();
                                                                                                let l118 = *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len119 = l118;
                                                                                                let bytes119 = _rt::Vec::from_raw_parts(
                                                                                                    l117.cast(),
                                                                                                    len119,
                                                                                                    len119,
                                                                                                );
                                                                                                _rt::string_lift(bytes119)
                                                                                            };
                                                                                            result120.push(e120);
                                                                                        }
                                                                                        _rt::cabi_dealloc(
                                                                                            base120,
                                                                                            len120 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                            ::core::mem::size_of::<*const u8>(),
                                                                                        );
                                                                                        result120
                                                                                    };
                                                                                    V138::EnumType(e138)
                                                                                }
                                                                                3 => {
                                                                                    let e138 = {
                                                                                        let l121 = *base.add(8).cast::<*mut u8>();
                                                                                        let l122 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let base126 = l121;
                                                                                        let len126 = l122;
                                                                                        let mut result126 = _rt::Vec::with_capacity(len126);
                                                                                        for i in 0..len126 {
                                                                                            let base = base126
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            let e126 = {
                                                                                                let l123 = *base.add(0).cast::<*mut u8>();
                                                                                                let l124 = *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len125 = l124;
                                                                                                let bytes125 = _rt::Vec::from_raw_parts(
                                                                                                    l123.cast(),
                                                                                                    len125,
                                                                                                    len125,
                                                                                                );
                                                                                                _rt::string_lift(bytes125)
                                                                                            };
                                                                                            result126.push(e126);
                                                                                        }
                                                                                        _rt::cabi_dealloc(
                                                                                            base126,
                                                                                            len126 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                            ::core::mem::size_of::<*const u8>(),
                                                                                        );
                                                                                        result126
                                                                                    };
                                                                                    V138::FlagsType(e138)
                                                                                }
                                                                                4 => {
                                                                                    let e138 = {
                                                                                        let l127 = *base.add(8).cast::<*mut u8>();
                                                                                        let l128 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len129 = l128;
                                                                                        _rt::Vec::from_raw_parts(l127.cast(), len129, len129)
                                                                                    };
                                                                                    V138::TupleType(e138)
                                                                                }
                                                                                5 => {
                                                                                    let e138 = {
                                                                                        let l130 = *base.add(8).cast::<i32>();
                                                                                        l130
                                                                                    };
                                                                                    V138::ListType(e138)
                                                                                }
                                                                                6 => {
                                                                                    let e138 = {
                                                                                        let l131 = *base.add(8).cast::<i32>();
                                                                                        l131
                                                                                    };
                                                                                    V138::OptionType(e138)
                                                                                }
                                                                                7 => {
                                                                                    let e138 = {
                                                                                        let l132 = i32::from(*base.add(8).cast::<u8>());
                                                                                        let l134 = i32::from(*base.add(16).cast::<u8>());
                                                                                        (
                                                                                            match l132 {
                                                                                                0 => None,
                                                                                                1 => {
                                                                                                    let e = {
                                                                                                        let l133 = *base.add(12).cast::<i32>();
                                                                                                        l133
                                                                                                    };
                                                                                                    Some(e)
                                                                                                }
                                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                                            },
                                                                                            match l134 {
                                                                                                0 => None,
                                                                                                1 => {
                                                                                                    let e = {
                                                                                                        let l135 = *base.add(20).cast::<i32>();
                                                                                                        l135
                                                                                                    };
                                                                                                    Some(e)
                                                                                                }
                                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                                            },
                                                                                        )
                                                                                    };
                                                                                    V138::ResultType(e138)
                                                                                }
                                                                                8 => V138::PrimU8Type,
                                                                                9 => V138::PrimU16Type,
                                                                                10 => V138::PrimU32Type,
                                                                                11 => V138::PrimU64Type,
                                                                                12 => V138::PrimS8Type,
                                                                                13 => V138::PrimS16Type,
                                                                                14 => V138::PrimS32Type,
                                                                                15 => V138::PrimS64Type,
                                                                                16 => V138::PrimF32Type,
                                                                                17 => V138::PrimF64Type,
                                                                                18 => V138::PrimCharType,
                                                                                19 => V138::PrimBoolType,
                                                                                20 => V138::PrimStringType,
                                                                                n => {
                                                                                    debug_assert_eq!(n, 21, "invalid enum discriminant");
                                                                                    let e138 = {
                                                                                        let l136 = *base.add(8).cast::<i64>();
                                                                                        let l137 = i32::from(*base.add(16).cast::<u8>());
                                                                                        (
                                                                                            l136 as u64,
                                                                                            super::super::super::golem::rpc::types::ResourceMode::_lift(
                                                                                                l137 as u8,
                                                                                            ),
                                                                                        )
                                                                                    };
                                                                                    V138::HandleType(e138)
                                                                                }
                                                                            };
                                                                            v138
                                                                        };
                                                                        result139.push(e139);
                                                                    }
                                                                    _rt::cabi_dealloc(base139, len139 * 24, 8);
                                                                    super::super::super::golem::rpc::types::WitType {
                                                                        nodes: result139,
                                                                    }
                                                                };
                                                                V143::Wit(e143)
                                                            }
                                                            n => {
                                                                debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                                let e143 = {
                                                                    let l140 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l141 = *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len142 = l141;
                                                                    let bytes142 = _rt::Vec::from_raw_parts(
                                                                        l140.cast(),
                                                                        len142,
                                                                        len142,
                                                                    );
                                                                    super::super::super::golem::agent::common::TextType {
                                                                        language_code: _rt::string_lift(bytes142),
                                                                    }
                                                                };
                                                                V143::Text(e143)
                                                            }
                                                        };
                                                        v143
                                                    };
                                                    result144.push(e144);
                                                }
                                                _rt::cabi_dealloc(
                                                    base144,
                                                    len144 * (3 * ::core::mem::size_of::<*const u8>()),
                                                    ::core::mem::size_of::<*const u8>(),
                                                );
                                                super::super::super::golem::agent::common::Structured {
                                                    parameters: result144,
                                                }
                                            };
                                            V152::Structured(e152)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e152 = {
                                                let l145 = i32::from(
                                                    *base
                                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                super::super::super::golem::agent::common::Multimodal {
                                                    text: match l145 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l146 = *base
                                                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>();
                                                                let l147 = *base
                                                                    .add(10 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let base151 = l146;
                                                                let len151 = l147;
                                                                let mut result151 = _rt::Vec::with_capacity(len151);
                                                                for i in 0..len151 {
                                                                    let base = base151
                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                    let e151 = {
                                                                        let l148 = *base.add(0).cast::<*mut u8>();
                                                                        let l149 = *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>();
                                                                        let len150 = l149;
                                                                        let bytes150 = _rt::Vec::from_raw_parts(
                                                                            l148.cast(),
                                                                            len150,
                                                                            len150,
                                                                        );
                                                                        super::super::super::golem::agent::common::TextType {
                                                                            language_code: _rt::string_lift(bytes150),
                                                                        }
                                                                    };
                                                                    result151.push(e151);
                                                                }
                                                                _rt::cabi_dealloc(
                                                                    base151,
                                                                    len151 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                    ::core::mem::size_of::<*const u8>(),
                                                                );
                                                                result151
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            V152::Multimodal(e152)
                                        }
                                    };
                                    let l153 = i32::from(
                                        *base
                                            .add(11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    use super::super::super::golem::agent::common::DataSchema as V212;
                                    let v212 = match l153 {
                                        0 => {
                                            let e212 = {
                                                let l154 = *base
                                                    .add(12 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l155 = *base
                                                    .add(13 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base204 = l154;
                                                let len204 = l155;
                                                let mut result204 = _rt::Vec::with_capacity(len204);
                                                for i in 0..len204 {
                                                    let base = base204
                                                        .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                    let e204 = {
                                                        let l156 = i32::from(*base.add(0).cast::<u8>());
                                                        use super::super::super::golem::agent::common::ParameterType as V203;
                                                        let v203 = match l156 {
                                                            0 => {
                                                                let e203 = {
                                                                    let l157 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l158 = *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base199 = l157;
                                                                    let len199 = l158;
                                                                    let mut result199 = _rt::Vec::with_capacity(len199);
                                                                    for i in 0..len199 {
                                                                        let base = base199.add(i * 24);
                                                                        let e199 = {
                                                                            let l159 = i32::from(*base.add(0).cast::<u8>());
                                                                            use super::super::super::golem::rpc::types::WitTypeNode as V198;
                                                                            let v198 = match l159 {
                                                                                0 => {
                                                                                    let e198 = {
                                                                                        let l160 = *base.add(8).cast::<*mut u8>();
                                                                                        let l161 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let base166 = l160;
                                                                                        let len166 = l161;
                                                                                        let mut result166 = _rt::Vec::with_capacity(len166);
                                                                                        for i in 0..len166 {
                                                                                            let base = base166
                                                                                                .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                            let e166 = {
                                                                                                let l162 = *base.add(0).cast::<*mut u8>();
                                                                                                let l163 = *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len164 = l163;
                                                                                                let bytes164 = _rt::Vec::from_raw_parts(
                                                                                                    l162.cast(),
                                                                                                    len164,
                                                                                                    len164,
                                                                                                );
                                                                                                let l165 = *base
                                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<i32>();
                                                                                                (_rt::string_lift(bytes164), l165)
                                                                                            };
                                                                                            result166.push(e166);
                                                                                        }
                                                                                        _rt::cabi_dealloc(
                                                                                            base166,
                                                                                            len166 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                            ::core::mem::size_of::<*const u8>(),
                                                                                        );
                                                                                        result166
                                                                                    };
                                                                                    V198::RecordType(e198)
                                                                                }
                                                                                1 => {
                                                                                    let e198 = {
                                                                                        let l167 = *base.add(8).cast::<*mut u8>();
                                                                                        let l168 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let base174 = l167;
                                                                                        let len174 = l168;
                                                                                        let mut result174 = _rt::Vec::with_capacity(len174);
                                                                                        for i in 0..len174 {
                                                                                            let base = base174
                                                                                                .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                            let e174 = {
                                                                                                let l169 = *base.add(0).cast::<*mut u8>();
                                                                                                let l170 = *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len171 = l170;
                                                                                                let bytes171 = _rt::Vec::from_raw_parts(
                                                                                                    l169.cast(),
                                                                                                    len171,
                                                                                                    len171,
                                                                                                );
                                                                                                let l172 = i32::from(
                                                                                                    *base
                                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<u8>(),
                                                                                                );
                                                                                                (
                                                                                                    _rt::string_lift(bytes171),
                                                                                                    match l172 {
                                                                                                        0 => None,
                                                                                                        1 => {
                                                                                                            let e = {
                                                                                                                let l173 = *base
                                                                                                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                                    .cast::<i32>();
                                                                                                                l173
                                                                                                            };
                                                                                                            Some(e)
                                                                                                        }
                                                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                                                    },
                                                                                                )
                                                                                            };
                                                                                            result174.push(e174);
                                                                                        }
                                                                                        _rt::cabi_dealloc(
                                                                                            base174,
                                                                                            len174 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                            ::core::mem::size_of::<*const u8>(),
                                                                                        );
                                                                                        result174
                                                                                    };
                                                                                    V198::VariantType(e198)
                                                                                }
                                                                                2 => {
                                                                                    let e198 = {
                                                                                        let l175 = *base.add(8).cast::<*mut u8>();
                                                                                        let l176 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let base180 = l175;
                                                                                        let len180 = l176;
                                                                                        let mut result180 = _rt::Vec::with_capacity(len180);
                                                                                        for i in 0..len180 {
                                                                                            let base = base180
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            let e180 = {
                                                                                                let l177 = *base.add(0).cast::<*mut u8>();
                                                                                                let l178 = *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len179 = l178;
                                                                                                let bytes179 = _rt::Vec::from_raw_parts(
                                                                                                    l177.cast(),
                                                                                                    len179,
                                                                                                    len179,
                                                                                                );
                                                                                                _rt::string_lift(bytes179)
                                                                                            };
                                                                                            result180.push(e180);
                                                                                        }
                                                                                        _rt::cabi_dealloc(
                                                                                            base180,
                                                                                            len180 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                            ::core::mem::size_of::<*const u8>(),
                                                                                        );
                                                                                        result180
                                                                                    };
                                                                                    V198::EnumType(e198)
                                                                                }
                                                                                3 => {
                                                                                    let e198 = {
                                                                                        let l181 = *base.add(8).cast::<*mut u8>();
                                                                                        let l182 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let base186 = l181;
                                                                                        let len186 = l182;
                                                                                        let mut result186 = _rt::Vec::with_capacity(len186);
                                                                                        for i in 0..len186 {
                                                                                            let base = base186
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            let e186 = {
                                                                                                let l183 = *base.add(0).cast::<*mut u8>();
                                                                                                let l184 = *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len185 = l184;
                                                                                                let bytes185 = _rt::Vec::from_raw_parts(
                                                                                                    l183.cast(),
                                                                                                    len185,
                                                                                                    len185,
                                                                                                );
                                                                                                _rt::string_lift(bytes185)
                                                                                            };
                                                                                            result186.push(e186);
                                                                                        }
                                                                                        _rt::cabi_dealloc(
                                                                                            base186,
                                                                                            len186 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                            ::core::mem::size_of::<*const u8>(),
                                                                                        );
                                                                                        result186
                                                                                    };
                                                                                    V198::FlagsType(e198)
                                                                                }
                                                                                4 => {
                                                                                    let e198 = {
                                                                                        let l187 = *base.add(8).cast::<*mut u8>();
                                                                                        let l188 = *base
                                                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len189 = l188;
                                                                                        _rt::Vec::from_raw_parts(l187.cast(), len189, len189)
                                                                                    };
                                                                                    V198::TupleType(e198)
                                                                                }
                                                                                5 => {
                                                                                    let e198 = {
                                                                                        let l190 = *base.add(8).cast::<i32>();
                                                                                        l190
                                                                                    };
                                                                                    V198::ListType(e198)
                                                                                }
                                                                                6 => {
                                                                                    let e198 = {
                                                                                        let l191 = *base.add(8).cast::<i32>();
                                                                                        l191
                                                                                    };
                                                                                    V198::OptionType(e198)
                                                                                }
                                                                                7 => {
                                                                                    let e198 = {
                                                                                        let l192 = i32::from(*base.add(8).cast::<u8>());
                                                                                        let l194 = i32::from(*base.add(16).cast::<u8>());
                                                                                        (
                                                                                            match l192 {
                                                                                                0 => None,
                                                                                                1 => {
                                                                                                    let e = {
                                                                                                        let l193 = *base.add(12).cast::<i32>();
                                                                                                        l193
                                                                                                    };
                                                                                                    Some(e)
                                                                                                }
                                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                                            },
                                                                                            match l194 {
                                                                                                0 => None,
                                                                                                1 => {
                                                                                                    let e = {
                                                                                                        let l195 = *base.add(20).cast::<i32>();
                                                                                                        l195
                                                                                                    };
                                                                                                    Some(e)
                                                                                                }
                                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                                            },
                                                                                        )
                                                                                    };
                                                                                    V198::ResultType(e198)
                                                                                }
                                                                                8 => V198::PrimU8Type,
                                                                                9 => V198::PrimU16Type,
                                                                                10 => V198::PrimU32Type,
                                                                                11 => V198::PrimU64Type,
                                                                                12 => V198::PrimS8Type,
                                                                                13 => V198::PrimS16Type,
                                                                                14 => V198::PrimS32Type,
                                                                                15 => V198::PrimS64Type,
                                                                                16 => V198::PrimF32Type,
                                                                                17 => V198::PrimF64Type,
                                                                                18 => V198::PrimCharType,
                                                                                19 => V198::PrimBoolType,
                                                                                20 => V198::PrimStringType,
                                                                                n => {
                                                                                    debug_assert_eq!(n, 21, "invalid enum discriminant");
                                                                                    let e198 = {
                                                                                        let l196 = *base.add(8).cast::<i64>();
                                                                                        let l197 = i32::from(*base.add(16).cast::<u8>());
                                                                                        (
                                                                                            l196 as u64,
                                                                                            super::super::super::golem::rpc::types::ResourceMode::_lift(
                                                                                                l197 as u8,
                                                                                            ),
                                                                                        )
                                                                                    };
                                                                                    V198::HandleType(e198)
                                                                                }
                                                                            };
                                                                            v198
                                                                        };
                                                                        result199.push(e199);
                                                                    }
                                                                    _rt::cabi_dealloc(base199, len199 * 24, 8);
                                                                    super::super::super::golem::rpc::types::WitType {
                                                                        nodes: result199,
                                                                    }
                                                                };
                                                                V203::Wit(e203)
                                                            }
                                                            n => {
                                                                debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                                let e203 = {
                                                                    let l200 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l201 = *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len202 = l201;
                                                                    let bytes202 = _rt::Vec::from_raw_parts(
                                                                        l200.cast(),
                                                                        len202,
                                                                        len202,
                                                                    );
                                                                    super::super::super::golem::agent::common::TextType {
                                                                        language_code: _rt::string_lift(bytes202),
                                                                    }
                                                                };
                                                                V203::Text(e203)
                                                            }
                                                        };
                                                        v203
                                                    };
                                                    result204.push(e204);
                                                }
                                                _rt::cabi_dealloc(
                                                    base204,
                                                    len204 * (3 * ::core::mem::size_of::<*const u8>()),
                                                    ::core::mem::size_of::<*const u8>(),
                                                );
                                                super::super::super::golem::agent::common::Structured {
                                                    parameters: result204,
                                                }
                                            };
                                            V212::Structured(e212)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e212 = {
                                                let l205 = i32::from(
                                                    *base
                                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                super::super::super::golem::agent::common::Multimodal {
                                                    text: match l205 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l206 = *base
                                                                    .add(13 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>();
                                                                let l207 = *base
                                                                    .add(14 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let base211 = l206;
                                                                let len211 = l207;
                                                                let mut result211 = _rt::Vec::with_capacity(len211);
                                                                for i in 0..len211 {
                                                                    let base = base211
                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                    let e211 = {
                                                                        let l208 = *base.add(0).cast::<*mut u8>();
                                                                        let l209 = *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>();
                                                                        let len210 = l209;
                                                                        let bytes210 = _rt::Vec::from_raw_parts(
                                                                            l208.cast(),
                                                                            len210,
                                                                            len210,
                                                                        );
                                                                        super::super::super::golem::agent::common::TextType {
                                                                            language_code: _rt::string_lift(bytes210),
                                                                        }
                                                                    };
                                                                    result211.push(e211);
                                                                }
                                                                _rt::cabi_dealloc(
                                                                    base211,
                                                                    len211 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                    ::core::mem::size_of::<*const u8>(),
                                                                );
                                                                result211
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            V212::Multimodal(e212)
                                        }
                                    };
                                    super::super::super::golem::agent::common::AgentMethod {
                                        name: _rt::string_lift(bytes85),
                                        description: _rt::string_lift(bytes88),
                                        prompt_hint: match l89 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l90 = *base
                                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l91 = *base
                                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len92 = l91;
                                                    let bytes92 = _rt::Vec::from_raw_parts(
                                                        l90.cast(),
                                                        len92,
                                                        len92,
                                                    );
                                                    _rt::string_lift(bytes92)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        input_schema: v152,
                                        output_schema: v212,
                                    }
                                };
                                result213.push(e213);
                            }
                            _rt::cabi_dealloc(
                                base213,
                                len213 * (15 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l214 = *base
                                .add(18 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l215 = *base
                                .add(19 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base352 = l214;
                            let len352 = l215;
                            let mut result352 = _rt::Vec::with_capacity(len352);
                            for i in 0..len352 {
                                let base = base352
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                let e352 = {
                                    let l216 = *base.add(0).cast::<*mut u8>();
                                    let l217 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len218 = l217;
                                    let bytes218 = _rt::Vec::from_raw_parts(
                                        l216.cast(),
                                        len218,
                                        len218,
                                    );
                                    let l219 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l220 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base351 = l219;
                                    let len351 = l220;
                                    let mut result351 = _rt::Vec::with_capacity(len351);
                                    for i in 0..len351 {
                                        let base = base351
                                            .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                                        let e351 = {
                                            let l221 = *base.add(0).cast::<*mut u8>();
                                            let l222 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len223 = l222;
                                            let bytes223 = _rt::Vec::from_raw_parts(
                                                l221.cast(),
                                                len223,
                                                len223,
                                            );
                                            let l224 = *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l225 = *base
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len226 = l225;
                                            let bytes226 = _rt::Vec::from_raw_parts(
                                                l224.cast(),
                                                len226,
                                                len226,
                                            );
                                            let l227 = i32::from(
                                                *base
                                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            let l231 = i32::from(
                                                *base
                                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            use super::super::super::golem::agent::common::DataSchema as V290;
                                            let v290 = match l231 {
                                                0 => {
                                                    let e290 = {
                                                        let l232 = *base
                                                            .add(8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l233 = *base
                                                            .add(9 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let base282 = l232;
                                                        let len282 = l233;
                                                        let mut result282 = _rt::Vec::with_capacity(len282);
                                                        for i in 0..len282 {
                                                            let base = base282
                                                                .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                            let e282 = {
                                                                let l234 = i32::from(*base.add(0).cast::<u8>());
                                                                use super::super::super::golem::agent::common::ParameterType as V281;
                                                                let v281 = match l234 {
                                                                    0 => {
                                                                        let e281 = {
                                                                            let l235 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<*mut u8>();
                                                                            let l236 = *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base277 = l235;
                                                                            let len277 = l236;
                                                                            let mut result277 = _rt::Vec::with_capacity(len277);
                                                                            for i in 0..len277 {
                                                                                let base = base277.add(i * 24);
                                                                                let e277 = {
                                                                                    let l237 = i32::from(*base.add(0).cast::<u8>());
                                                                                    use super::super::super::golem::rpc::types::WitTypeNode as V276;
                                                                                    let v276 = match l237 {
                                                                                        0 => {
                                                                                            let e276 = {
                                                                                                let l238 = *base.add(8).cast::<*mut u8>();
                                                                                                let l239 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let base244 = l238;
                                                                                                let len244 = l239;
                                                                                                let mut result244 = _rt::Vec::with_capacity(len244);
                                                                                                for i in 0..len244 {
                                                                                                    let base = base244
                                                                                                        .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                                    let e244 = {
                                                                                                        let l240 = *base.add(0).cast::<*mut u8>();
                                                                                                        let l241 = *base
                                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<usize>();
                                                                                                        let len242 = l241;
                                                                                                        let bytes242 = _rt::Vec::from_raw_parts(
                                                                                                            l240.cast(),
                                                                                                            len242,
                                                                                                            len242,
                                                                                                        );
                                                                                                        let l243 = *base
                                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<i32>();
                                                                                                        (_rt::string_lift(bytes242), l243)
                                                                                                    };
                                                                                                    result244.push(e244);
                                                                                                }
                                                                                                _rt::cabi_dealloc(
                                                                                                    base244,
                                                                                                    len244 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                                );
                                                                                                result244
                                                                                            };
                                                                                            V276::RecordType(e276)
                                                                                        }
                                                                                        1 => {
                                                                                            let e276 = {
                                                                                                let l245 = *base.add(8).cast::<*mut u8>();
                                                                                                let l246 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let base252 = l245;
                                                                                                let len252 = l246;
                                                                                                let mut result252 = _rt::Vec::with_capacity(len252);
                                                                                                for i in 0..len252 {
                                                                                                    let base = base252
                                                                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                                    let e252 = {
                                                                                                        let l247 = *base.add(0).cast::<*mut u8>();
                                                                                                        let l248 = *base
                                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<usize>();
                                                                                                        let len249 = l248;
                                                                                                        let bytes249 = _rt::Vec::from_raw_parts(
                                                                                                            l247.cast(),
                                                                                                            len249,
                                                                                                            len249,
                                                                                                        );
                                                                                                        let l250 = i32::from(
                                                                                                            *base
                                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                                .cast::<u8>(),
                                                                                                        );
                                                                                                        (
                                                                                                            _rt::string_lift(bytes249),
                                                                                                            match l250 {
                                                                                                                0 => None,
                                                                                                                1 => {
                                                                                                                    let e = {
                                                                                                                        let l251 = *base
                                                                                                                            .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                                            .cast::<i32>();
                                                                                                                        l251
                                                                                                                    };
                                                                                                                    Some(e)
                                                                                                                }
                                                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                                                            },
                                                                                                        )
                                                                                                    };
                                                                                                    result252.push(e252);
                                                                                                }
                                                                                                _rt::cabi_dealloc(
                                                                                                    base252,
                                                                                                    len252 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                                );
                                                                                                result252
                                                                                            };
                                                                                            V276::VariantType(e276)
                                                                                        }
                                                                                        2 => {
                                                                                            let e276 = {
                                                                                                let l253 = *base.add(8).cast::<*mut u8>();
                                                                                                let l254 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let base258 = l253;
                                                                                                let len258 = l254;
                                                                                                let mut result258 = _rt::Vec::with_capacity(len258);
                                                                                                for i in 0..len258 {
                                                                                                    let base = base258
                                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                                    let e258 = {
                                                                                                        let l255 = *base.add(0).cast::<*mut u8>();
                                                                                                        let l256 = *base
                                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<usize>();
                                                                                                        let len257 = l256;
                                                                                                        let bytes257 = _rt::Vec::from_raw_parts(
                                                                                                            l255.cast(),
                                                                                                            len257,
                                                                                                            len257,
                                                                                                        );
                                                                                                        _rt::string_lift(bytes257)
                                                                                                    };
                                                                                                    result258.push(e258);
                                                                                                }
                                                                                                _rt::cabi_dealloc(
                                                                                                    base258,
                                                                                                    len258 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                                );
                                                                                                result258
                                                                                            };
                                                                                            V276::EnumType(e276)
                                                                                        }
                                                                                        3 => {
                                                                                            let e276 = {
                                                                                                let l259 = *base.add(8).cast::<*mut u8>();
                                                                                                let l260 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let base264 = l259;
                                                                                                let len264 = l260;
                                                                                                let mut result264 = _rt::Vec::with_capacity(len264);
                                                                                                for i in 0..len264 {
                                                                                                    let base = base264
                                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                                    let e264 = {
                                                                                                        let l261 = *base.add(0).cast::<*mut u8>();
                                                                                                        let l262 = *base
                                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<usize>();
                                                                                                        let len263 = l262;
                                                                                                        let bytes263 = _rt::Vec::from_raw_parts(
                                                                                                            l261.cast(),
                                                                                                            len263,
                                                                                                            len263,
                                                                                                        );
                                                                                                        _rt::string_lift(bytes263)
                                                                                                    };
                                                                                                    result264.push(e264);
                                                                                                }
                                                                                                _rt::cabi_dealloc(
                                                                                                    base264,
                                                                                                    len264 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                                );
                                                                                                result264
                                                                                            };
                                                                                            V276::FlagsType(e276)
                                                                                        }
                                                                                        4 => {
                                                                                            let e276 = {
                                                                                                let l265 = *base.add(8).cast::<*mut u8>();
                                                                                                let l266 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len267 = l266;
                                                                                                _rt::Vec::from_raw_parts(l265.cast(), len267, len267)
                                                                                            };
                                                                                            V276::TupleType(e276)
                                                                                        }
                                                                                        5 => {
                                                                                            let e276 = {
                                                                                                let l268 = *base.add(8).cast::<i32>();
                                                                                                l268
                                                                                            };
                                                                                            V276::ListType(e276)
                                                                                        }
                                                                                        6 => {
                                                                                            let e276 = {
                                                                                                let l269 = *base.add(8).cast::<i32>();
                                                                                                l269
                                                                                            };
                                                                                            V276::OptionType(e276)
                                                                                        }
                                                                                        7 => {
                                                                                            let e276 = {
                                                                                                let l270 = i32::from(*base.add(8).cast::<u8>());
                                                                                                let l272 = i32::from(*base.add(16).cast::<u8>());
                                                                                                (
                                                                                                    match l270 {
                                                                                                        0 => None,
                                                                                                        1 => {
                                                                                                            let e = {
                                                                                                                let l271 = *base.add(12).cast::<i32>();
                                                                                                                l271
                                                                                                            };
                                                                                                            Some(e)
                                                                                                        }
                                                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                                                    },
                                                                                                    match l272 {
                                                                                                        0 => None,
                                                                                                        1 => {
                                                                                                            let e = {
                                                                                                                let l273 = *base.add(20).cast::<i32>();
                                                                                                                l273
                                                                                                            };
                                                                                                            Some(e)
                                                                                                        }
                                                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                                                    },
                                                                                                )
                                                                                            };
                                                                                            V276::ResultType(e276)
                                                                                        }
                                                                                        8 => V276::PrimU8Type,
                                                                                        9 => V276::PrimU16Type,
                                                                                        10 => V276::PrimU32Type,
                                                                                        11 => V276::PrimU64Type,
                                                                                        12 => V276::PrimS8Type,
                                                                                        13 => V276::PrimS16Type,
                                                                                        14 => V276::PrimS32Type,
                                                                                        15 => V276::PrimS64Type,
                                                                                        16 => V276::PrimF32Type,
                                                                                        17 => V276::PrimF64Type,
                                                                                        18 => V276::PrimCharType,
                                                                                        19 => V276::PrimBoolType,
                                                                                        20 => V276::PrimStringType,
                                                                                        n => {
                                                                                            debug_assert_eq!(n, 21, "invalid enum discriminant");
                                                                                            let e276 = {
                                                                                                let l274 = *base.add(8).cast::<i64>();
                                                                                                let l275 = i32::from(*base.add(16).cast::<u8>());
                                                                                                (
                                                                                                    l274 as u64,
                                                                                                    super::super::super::golem::rpc::types::ResourceMode::_lift(
                                                                                                        l275 as u8,
                                                                                                    ),
                                                                                                )
                                                                                            };
                                                                                            V276::HandleType(e276)
                                                                                        }
                                                                                    };
                                                                                    v276
                                                                                };
                                                                                result277.push(e277);
                                                                            }
                                                                            _rt::cabi_dealloc(base277, len277 * 24, 8);
                                                                            super::super::super::golem::rpc::types::WitType {
                                                                                nodes: result277,
                                                                            }
                                                                        };
                                                                        V281::Wit(e281)
                                                                    }
                                                                    n => {
                                                                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                                        let e281 = {
                                                                            let l278 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<*mut u8>();
                                                                            let l279 = *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let len280 = l279;
                                                                            let bytes280 = _rt::Vec::from_raw_parts(
                                                                                l278.cast(),
                                                                                len280,
                                                                                len280,
                                                                            );
                                                                            super::super::super::golem::agent::common::TextType {
                                                                                language_code: _rt::string_lift(bytes280),
                                                                            }
                                                                        };
                                                                        V281::Text(e281)
                                                                    }
                                                                };
                                                                v281
                                                            };
                                                            result282.push(e282);
                                                        }
                                                        _rt::cabi_dealloc(
                                                            base282,
                                                            len282 * (3 * ::core::mem::size_of::<*const u8>()),
                                                            ::core::mem::size_of::<*const u8>(),
                                                        );
                                                        super::super::super::golem::agent::common::Structured {
                                                            parameters: result282,
                                                        }
                                                    };
                                                    V290::Structured(e290)
                                                }
                                                n => {
                                                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                    let e290 = {
                                                        let l283 = i32::from(
                                                            *base
                                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        super::super::super::golem::agent::common::Multimodal {
                                                            text: match l283 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l284 = *base
                                                                            .add(9 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>();
                                                                        let l285 = *base
                                                                            .add(10 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>();
                                                                        let base289 = l284;
                                                                        let len289 = l285;
                                                                        let mut result289 = _rt::Vec::with_capacity(len289);
                                                                        for i in 0..len289 {
                                                                            let base = base289
                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                            let e289 = {
                                                                                let l286 = *base.add(0).cast::<*mut u8>();
                                                                                let l287 = *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>();
                                                                                let len288 = l287;
                                                                                let bytes288 = _rt::Vec::from_raw_parts(
                                                                                    l286.cast(),
                                                                                    len288,
                                                                                    len288,
                                                                                );
                                                                                super::super::super::golem::agent::common::TextType {
                                                                                    language_code: _rt::string_lift(bytes288),
                                                                                }
                                                                            };
                                                                            result289.push(e289);
                                                                        }
                                                                        _rt::cabi_dealloc(
                                                                            base289,
                                                                            len289 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                            ::core::mem::size_of::<*const u8>(),
                                                                        );
                                                                        result289
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                        }
                                                    };
                                                    V290::Multimodal(e290)
                                                }
                                            };
                                            let l291 = i32::from(
                                                *base
                                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            use super::super::super::golem::agent::common::DataSchema as V350;
                                            let v350 = match l291 {
                                                0 => {
                                                    let e350 = {
                                                        let l292 = *base
                                                            .add(12 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l293 = *base
                                                            .add(13 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let base342 = l292;
                                                        let len342 = l293;
                                                        let mut result342 = _rt::Vec::with_capacity(len342);
                                                        for i in 0..len342 {
                                                            let base = base342
                                                                .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                            let e342 = {
                                                                let l294 = i32::from(*base.add(0).cast::<u8>());
                                                                use super::super::super::golem::agent::common::ParameterType as V341;
                                                                let v341 = match l294 {
                                                                    0 => {
                                                                        let e341 = {
                                                                            let l295 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<*mut u8>();
                                                                            let l296 = *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base337 = l295;
                                                                            let len337 = l296;
                                                                            let mut result337 = _rt::Vec::with_capacity(len337);
                                                                            for i in 0..len337 {
                                                                                let base = base337.add(i * 24);
                                                                                let e337 = {
                                                                                    let l297 = i32::from(*base.add(0).cast::<u8>());
                                                                                    use super::super::super::golem::rpc::types::WitTypeNode as V336;
                                                                                    let v336 = match l297 {
                                                                                        0 => {
                                                                                            let e336 = {
                                                                                                let l298 = *base.add(8).cast::<*mut u8>();
                                                                                                let l299 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let base304 = l298;
                                                                                                let len304 = l299;
                                                                                                let mut result304 = _rt::Vec::with_capacity(len304);
                                                                                                for i in 0..len304 {
                                                                                                    let base = base304
                                                                                                        .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                                    let e304 = {
                                                                                                        let l300 = *base.add(0).cast::<*mut u8>();
                                                                                                        let l301 = *base
                                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<usize>();
                                                                                                        let len302 = l301;
                                                                                                        let bytes302 = _rt::Vec::from_raw_parts(
                                                                                                            l300.cast(),
                                                                                                            len302,
                                                                                                            len302,
                                                                                                        );
                                                                                                        let l303 = *base
                                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<i32>();
                                                                                                        (_rt::string_lift(bytes302), l303)
                                                                                                    };
                                                                                                    result304.push(e304);
                                                                                                }
                                                                                                _rt::cabi_dealloc(
                                                                                                    base304,
                                                                                                    len304 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                                );
                                                                                                result304
                                                                                            };
                                                                                            V336::RecordType(e336)
                                                                                        }
                                                                                        1 => {
                                                                                            let e336 = {
                                                                                                let l305 = *base.add(8).cast::<*mut u8>();
                                                                                                let l306 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let base312 = l305;
                                                                                                let len312 = l306;
                                                                                                let mut result312 = _rt::Vec::with_capacity(len312);
                                                                                                for i in 0..len312 {
                                                                                                    let base = base312
                                                                                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                                    let e312 = {
                                                                                                        let l307 = *base.add(0).cast::<*mut u8>();
                                                                                                        let l308 = *base
                                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<usize>();
                                                                                                        let len309 = l308;
                                                                                                        let bytes309 = _rt::Vec::from_raw_parts(
                                                                                                            l307.cast(),
                                                                                                            len309,
                                                                                                            len309,
                                                                                                        );
                                                                                                        let l310 = i32::from(
                                                                                                            *base
                                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                                .cast::<u8>(),
                                                                                                        );
                                                                                                        (
                                                                                                            _rt::string_lift(bytes309),
                                                                                                            match l310 {
                                                                                                                0 => None,
                                                                                                                1 => {
                                                                                                                    let e = {
                                                                                                                        let l311 = *base
                                                                                                                            .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                                            .cast::<i32>();
                                                                                                                        l311
                                                                                                                    };
                                                                                                                    Some(e)
                                                                                                                }
                                                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                                                            },
                                                                                                        )
                                                                                                    };
                                                                                                    result312.push(e312);
                                                                                                }
                                                                                                _rt::cabi_dealloc(
                                                                                                    base312,
                                                                                                    len312 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                                );
                                                                                                result312
                                                                                            };
                                                                                            V336::VariantType(e336)
                                                                                        }
                                                                                        2 => {
                                                                                            let e336 = {
                                                                                                let l313 = *base.add(8).cast::<*mut u8>();
                                                                                                let l314 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let base318 = l313;
                                                                                                let len318 = l314;
                                                                                                let mut result318 = _rt::Vec::with_capacity(len318);
                                                                                                for i in 0..len318 {
                                                                                                    let base = base318
                                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                                    let e318 = {
                                                                                                        let l315 = *base.add(0).cast::<*mut u8>();
                                                                                                        let l316 = *base
                                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<usize>();
                                                                                                        let len317 = l316;
                                                                                                        let bytes317 = _rt::Vec::from_raw_parts(
                                                                                                            l315.cast(),
                                                                                                            len317,
                                                                                                            len317,
                                                                                                        );
                                                                                                        _rt::string_lift(bytes317)
                                                                                                    };
                                                                                                    result318.push(e318);
                                                                                                }
                                                                                                _rt::cabi_dealloc(
                                                                                                    base318,
                                                                                                    len318 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                                );
                                                                                                result318
                                                                                            };
                                                                                            V336::EnumType(e336)
                                                                                        }
                                                                                        3 => {
                                                                                            let e336 = {
                                                                                                let l319 = *base.add(8).cast::<*mut u8>();
                                                                                                let l320 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let base324 = l319;
                                                                                                let len324 = l320;
                                                                                                let mut result324 = _rt::Vec::with_capacity(len324);
                                                                                                for i in 0..len324 {
                                                                                                    let base = base324
                                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                                    let e324 = {
                                                                                                        let l321 = *base.add(0).cast::<*mut u8>();
                                                                                                        let l322 = *base
                                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                                            .cast::<usize>();
                                                                                                        let len323 = l322;
                                                                                                        let bytes323 = _rt::Vec::from_raw_parts(
                                                                                                            l321.cast(),
                                                                                                            len323,
                                                                                                            len323,
                                                                                                        );
                                                                                                        _rt::string_lift(bytes323)
                                                                                                    };
                                                                                                    result324.push(e324);
                                                                                                }
                                                                                                _rt::cabi_dealloc(
                                                                                                    base324,
                                                                                                    len324 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                    ::core::mem::size_of::<*const u8>(),
                                                                                                );
                                                                                                result324
                                                                                            };
                                                                                            V336::FlagsType(e336)
                                                                                        }
                                                                                        4 => {
                                                                                            let e336 = {
                                                                                                let l325 = *base.add(8).cast::<*mut u8>();
                                                                                                let l326 = *base
                                                                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>();
                                                                                                let len327 = l326;
                                                                                                _rt::Vec::from_raw_parts(l325.cast(), len327, len327)
                                                                                            };
                                                                                            V336::TupleType(e336)
                                                                                        }
                                                                                        5 => {
                                                                                            let e336 = {
                                                                                                let l328 = *base.add(8).cast::<i32>();
                                                                                                l328
                                                                                            };
                                                                                            V336::ListType(e336)
                                                                                        }
                                                                                        6 => {
                                                                                            let e336 = {
                                                                                                let l329 = *base.add(8).cast::<i32>();
                                                                                                l329
                                                                                            };
                                                                                            V336::OptionType(e336)
                                                                                        }
                                                                                        7 => {
                                                                                            let e336 = {
                                                                                                let l330 = i32::from(*base.add(8).cast::<u8>());
                                                                                                let l332 = i32::from(*base.add(16).cast::<u8>());
                                                                                                (
                                                                                                    match l330 {
                                                                                                        0 => None,
                                                                                                        1 => {
                                                                                                            let e = {
                                                                                                                let l331 = *base.add(12).cast::<i32>();
                                                                                                                l331
                                                                                                            };
                                                                                                            Some(e)
                                                                                                        }
                                                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                                                    },
                                                                                                    match l332 {
                                                                                                        0 => None,
                                                                                                        1 => {
                                                                                                            let e = {
                                                                                                                let l333 = *base.add(20).cast::<i32>();
                                                                                                                l333
                                                                                                            };
                                                                                                            Some(e)
                                                                                                        }
                                                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                                                    },
                                                                                                )
                                                                                            };
                                                                                            V336::ResultType(e336)
                                                                                        }
                                                                                        8 => V336::PrimU8Type,
                                                                                        9 => V336::PrimU16Type,
                                                                                        10 => V336::PrimU32Type,
                                                                                        11 => V336::PrimU64Type,
                                                                                        12 => V336::PrimS8Type,
                                                                                        13 => V336::PrimS16Type,
                                                                                        14 => V336::PrimS32Type,
                                                                                        15 => V336::PrimS64Type,
                                                                                        16 => V336::PrimF32Type,
                                                                                        17 => V336::PrimF64Type,
                                                                                        18 => V336::PrimCharType,
                                                                                        19 => V336::PrimBoolType,
                                                                                        20 => V336::PrimStringType,
                                                                                        n => {
                                                                                            debug_assert_eq!(n, 21, "invalid enum discriminant");
                                                                                            let e336 = {
                                                                                                let l334 = *base.add(8).cast::<i64>();
                                                                                                let l335 = i32::from(*base.add(16).cast::<u8>());
                                                                                                (
                                                                                                    l334 as u64,
                                                                                                    super::super::super::golem::rpc::types::ResourceMode::_lift(
                                                                                                        l335 as u8,
                                                                                                    ),
                                                                                                )
                                                                                            };
                                                                                            V336::HandleType(e336)
                                                                                        }
                                                                                    };
                                                                                    v336
                                                                                };
                                                                                result337.push(e337);
                                                                            }
                                                                            _rt::cabi_dealloc(base337, len337 * 24, 8);
                                                                            super::super::super::golem::rpc::types::WitType {
                                                                                nodes: result337,
                                                                            }
                                                                        };
                                                                        V341::Wit(e341)
                                                                    }
                                                                    n => {
                                                                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                                        let e341 = {
                                                                            let l338 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<*mut u8>();
                                                                            let l339 = *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let len340 = l339;
                                                                            let bytes340 = _rt::Vec::from_raw_parts(
                                                                                l338.cast(),
                                                                                len340,
                                                                                len340,
                                                                            );
                                                                            super::super::super::golem::agent::common::TextType {
                                                                                language_code: _rt::string_lift(bytes340),
                                                                            }
                                                                        };
                                                                        V341::Text(e341)
                                                                    }
                                                                };
                                                                v341
                                                            };
                                                            result342.push(e342);
                                                        }
                                                        _rt::cabi_dealloc(
                                                            base342,
                                                            len342 * (3 * ::core::mem::size_of::<*const u8>()),
                                                            ::core::mem::size_of::<*const u8>(),
                                                        );
                                                        super::super::super::golem::agent::common::Structured {
                                                            parameters: result342,
                                                        }
                                                    };
                                                    V350::Structured(e350)
                                                }
                                                n => {
                                                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                    let e350 = {
                                                        let l343 = i32::from(
                                                            *base
                                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        super::super::super::golem::agent::common::Multimodal {
                                                            text: match l343 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l344 = *base
                                                                            .add(13 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>();
                                                                        let l345 = *base
                                                                            .add(14 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>();
                                                                        let base349 = l344;
                                                                        let len349 = l345;
                                                                        let mut result349 = _rt::Vec::with_capacity(len349);
                                                                        for i in 0..len349 {
                                                                            let base = base349
                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                            let e349 = {
                                                                                let l346 = *base.add(0).cast::<*mut u8>();
                                                                                let l347 = *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>();
                                                                                let len348 = l347;
                                                                                let bytes348 = _rt::Vec::from_raw_parts(
                                                                                    l346.cast(),
                                                                                    len348,
                                                                                    len348,
                                                                                );
                                                                                super::super::super::golem::agent::common::TextType {
                                                                                    language_code: _rt::string_lift(bytes348),
                                                                                }
                                                                            };
                                                                            result349.push(e349);
                                                                        }
                                                                        _rt::cabi_dealloc(
                                                                            base349,
                                                                            len349 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                            ::core::mem::size_of::<*const u8>(),
                                                                        );
                                                                        result349
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                        }
                                                    };
                                                    V350::Multimodal(e350)
                                                }
                                            };
                                            super::super::super::golem::agent::common::AgentMethod {
                                                name: _rt::string_lift(bytes223),
                                                description: _rt::string_lift(bytes226),
                                                prompt_hint: match l227 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l228 = *base
                                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l229 = *base
                                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len230 = l229;
                                                            let bytes230 = _rt::Vec::from_raw_parts(
                                                                l228.cast(),
                                                                len230,
                                                                len230,
                                                            );
                                                            _rt::string_lift(bytes230)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                input_schema: v290,
                                                output_schema: v350,
                                            }
                                        };
                                        result351.push(e351);
                                    }
                                    _rt::cabi_dealloc(
                                        base351,
                                        len351 * (15 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    super::super::super::golem::agent::common::AgentDependency {
                                        agent_name: _rt::string_lift(bytes218),
                                        methods: result351,
                                    }
                                };
                                result352.push(e352);
                            }
                            _rt::cabi_dealloc(
                                base352,
                                len352 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            super::super::super::golem::agent::common::AgentType {
                                type_name: _rt::string_lift(bytes6),
                                description: _rt::string_lift(bytes9),
                                agent_constructor: super::super::super::golem::agent::common::AgentConstructor {
                                    name: match l10 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l11 = *base
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l12 = *base
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len13 = l12;
                                                let bytes13 = _rt::Vec::from_raw_parts(
                                                    l11.cast(),
                                                    len13,
                                                    len13,
                                                );
                                                _rt::string_lift(bytes13)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    description: _rt::string_lift(bytes16),
                                    prompt_hint: match l17 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l18 = *base
                                                    .add(10 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l19 = *base
                                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len20 = l19;
                                                let bytes20 = _rt::Vec::from_raw_parts(
                                                    l18.cast(),
                                                    len20,
                                                    len20,
                                                );
                                                _rt::string_lift(bytes20)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    input_schema: v80,
                                },
                                methods: result213,
                                requires: result352,
                            }
                        };
                        result353.push(e353);
                    }
                    _rt::cabi_dealloc(
                        base353,
                        len353 * (20 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result354 = result353;
                    result354
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// In the host spec, we had remote-agent resource that handled everything
            /// but this was replaced with things handled at the guest side itself - i.e, for invokes
            /// direclty using wasm-rpc than going via host
            /// resource remote-agent {
            ///     create: static func(agent-type: string, input: data-value) -> result<agent, agent-error>;
            ///     ...
            ///   }
            /// As a replacement (for prototype) we need to find the component id of the agent type
            /// this functionality has to exist in some form in host
            pub fn get_agent_component(agent_type: &str) -> Option<ComponentId> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let vec0 = agent_type;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@1.1.7")]
                    unsafe extern "C" {
                        #[link_name = "get-agent-component"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result6 = match l3 {
                        0 => None,
                        1 => {
                            let e = {
                                let l4 = *ptr1.add(8).cast::<i64>();
                                let l5 = *ptr1.add(16).cast::<i64>();
                                super::super::super::golem::rpc::types::ComponentId {
                                    uuid: super::super::super::golem::rpc::types::Uuid {
                                        high_bits: l4 as u64,
                                        low_bits: l5 as u64,
                                    },
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result6
                }
            }
        }
    }
    pub mod rpc {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            /// UUID
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Uuid {
                pub high_bits: u64,
                pub low_bits: u64,
            }
            impl ::core::fmt::Debug for Uuid {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Uuid")
                        .field("high-bits", &self.high_bits)
                        .field("low-bits", &self.low_bits)
                        .finish()
                }
            }
            /// Represents a Golem component
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct ComponentId {
                pub uuid: Uuid,
            }
            impl ::core::fmt::Debug for ComponentId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ComponentId").field("uuid", &self.uuid).finish()
                }
            }
            /// Represents a Golem worker
            #[derive(Clone)]
            pub struct WorkerId {
                pub component_id: ComponentId,
                pub worker_name: _rt::String,
            }
            impl ::core::fmt::Debug for WorkerId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WorkerId")
                        .field("component-id", &self.component_id)
                        .field("worker-name", &self.worker_name)
                        .finish()
                }
            }
            pub type NodeIndex = i32;
            pub type ResourceId = u64;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ResourceMode {
                Owned,
                Borrowed,
            }
            impl ::core::fmt::Debug for ResourceMode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ResourceMode::Owned => {
                            f.debug_tuple("ResourceMode::Owned").finish()
                        }
                        ResourceMode::Borrowed => {
                            f.debug_tuple("ResourceMode::Borrowed").finish()
                        }
                    }
                }
            }
            impl ResourceMode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ResourceMode {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => ResourceMode::Owned,
                        1 => ResourceMode::Borrowed,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[derive(Clone)]
            pub enum WitTypeNode {
                RecordType(_rt::Vec<(_rt::String, NodeIndex)>),
                VariantType(_rt::Vec<(_rt::String, Option<NodeIndex>)>),
                EnumType(_rt::Vec<_rt::String>),
                FlagsType(_rt::Vec<_rt::String>),
                TupleType(_rt::Vec<NodeIndex>),
                ListType(NodeIndex),
                OptionType(NodeIndex),
                ResultType((Option<NodeIndex>, Option<NodeIndex>)),
                PrimU8Type,
                PrimU16Type,
                PrimU32Type,
                PrimU64Type,
                PrimS8Type,
                PrimS16Type,
                PrimS32Type,
                PrimS64Type,
                PrimF32Type,
                PrimF64Type,
                PrimCharType,
                PrimBoolType,
                PrimStringType,
                HandleType((ResourceId, ResourceMode)),
            }
            impl ::core::fmt::Debug for WitTypeNode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        WitTypeNode::RecordType(e) => {
                            f.debug_tuple("WitTypeNode::RecordType").field(e).finish()
                        }
                        WitTypeNode::VariantType(e) => {
                            f.debug_tuple("WitTypeNode::VariantType").field(e).finish()
                        }
                        WitTypeNode::EnumType(e) => {
                            f.debug_tuple("WitTypeNode::EnumType").field(e).finish()
                        }
                        WitTypeNode::FlagsType(e) => {
                            f.debug_tuple("WitTypeNode::FlagsType").field(e).finish()
                        }
                        WitTypeNode::TupleType(e) => {
                            f.debug_tuple("WitTypeNode::TupleType").field(e).finish()
                        }
                        WitTypeNode::ListType(e) => {
                            f.debug_tuple("WitTypeNode::ListType").field(e).finish()
                        }
                        WitTypeNode::OptionType(e) => {
                            f.debug_tuple("WitTypeNode::OptionType").field(e).finish()
                        }
                        WitTypeNode::ResultType(e) => {
                            f.debug_tuple("WitTypeNode::ResultType").field(e).finish()
                        }
                        WitTypeNode::PrimU8Type => {
                            f.debug_tuple("WitTypeNode::PrimU8Type").finish()
                        }
                        WitTypeNode::PrimU16Type => {
                            f.debug_tuple("WitTypeNode::PrimU16Type").finish()
                        }
                        WitTypeNode::PrimU32Type => {
                            f.debug_tuple("WitTypeNode::PrimU32Type").finish()
                        }
                        WitTypeNode::PrimU64Type => {
                            f.debug_tuple("WitTypeNode::PrimU64Type").finish()
                        }
                        WitTypeNode::PrimS8Type => {
                            f.debug_tuple("WitTypeNode::PrimS8Type").finish()
                        }
                        WitTypeNode::PrimS16Type => {
                            f.debug_tuple("WitTypeNode::PrimS16Type").finish()
                        }
                        WitTypeNode::PrimS32Type => {
                            f.debug_tuple("WitTypeNode::PrimS32Type").finish()
                        }
                        WitTypeNode::PrimS64Type => {
                            f.debug_tuple("WitTypeNode::PrimS64Type").finish()
                        }
                        WitTypeNode::PrimF32Type => {
                            f.debug_tuple("WitTypeNode::PrimF32Type").finish()
                        }
                        WitTypeNode::PrimF64Type => {
                            f.debug_tuple("WitTypeNode::PrimF64Type").finish()
                        }
                        WitTypeNode::PrimCharType => {
                            f.debug_tuple("WitTypeNode::PrimCharType").finish()
                        }
                        WitTypeNode::PrimBoolType => {
                            f.debug_tuple("WitTypeNode::PrimBoolType").finish()
                        }
                        WitTypeNode::PrimStringType => {
                            f.debug_tuple("WitTypeNode::PrimStringType").finish()
                        }
                        WitTypeNode::HandleType(e) => {
                            f.debug_tuple("WitTypeNode::HandleType").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct WitType {
                pub nodes: _rt::Vec<WitTypeNode>,
            }
            impl ::core::fmt::Debug for WitType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WitType").field("nodes", &self.nodes).finish()
                }
            }
            #[derive(Clone)]
            pub struct Uri {
                pub value: _rt::String,
            }
            impl ::core::fmt::Debug for Uri {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Uri").field("value", &self.value).finish()
                }
            }
            #[derive(Clone)]
            pub enum WitNode {
                RecordValue(_rt::Vec<NodeIndex>),
                VariantValue((u32, Option<NodeIndex>)),
                EnumValue(u32),
                FlagsValue(_rt::Vec<bool>),
                TupleValue(_rt::Vec<NodeIndex>),
                ListValue(_rt::Vec<NodeIndex>),
                OptionValue(Option<NodeIndex>),
                ResultValue(Result<Option<NodeIndex>, Option<NodeIndex>>),
                PrimU8(u8),
                PrimU16(u16),
                PrimU32(u32),
                PrimU64(u64),
                PrimS8(i8),
                PrimS16(i16),
                PrimS32(i32),
                PrimS64(i64),
                PrimFloat32(f32),
                PrimFloat64(f64),
                PrimChar(char),
                PrimBool(bool),
                PrimString(_rt::String),
                Handle((Uri, u64)),
            }
            impl ::core::fmt::Debug for WitNode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        WitNode::RecordValue(e) => {
                            f.debug_tuple("WitNode::RecordValue").field(e).finish()
                        }
                        WitNode::VariantValue(e) => {
                            f.debug_tuple("WitNode::VariantValue").field(e).finish()
                        }
                        WitNode::EnumValue(e) => {
                            f.debug_tuple("WitNode::EnumValue").field(e).finish()
                        }
                        WitNode::FlagsValue(e) => {
                            f.debug_tuple("WitNode::FlagsValue").field(e).finish()
                        }
                        WitNode::TupleValue(e) => {
                            f.debug_tuple("WitNode::TupleValue").field(e).finish()
                        }
                        WitNode::ListValue(e) => {
                            f.debug_tuple("WitNode::ListValue").field(e).finish()
                        }
                        WitNode::OptionValue(e) => {
                            f.debug_tuple("WitNode::OptionValue").field(e).finish()
                        }
                        WitNode::ResultValue(e) => {
                            f.debug_tuple("WitNode::ResultValue").field(e).finish()
                        }
                        WitNode::PrimU8(e) => {
                            f.debug_tuple("WitNode::PrimU8").field(e).finish()
                        }
                        WitNode::PrimU16(e) => {
                            f.debug_tuple("WitNode::PrimU16").field(e).finish()
                        }
                        WitNode::PrimU32(e) => {
                            f.debug_tuple("WitNode::PrimU32").field(e).finish()
                        }
                        WitNode::PrimU64(e) => {
                            f.debug_tuple("WitNode::PrimU64").field(e).finish()
                        }
                        WitNode::PrimS8(e) => {
                            f.debug_tuple("WitNode::PrimS8").field(e).finish()
                        }
                        WitNode::PrimS16(e) => {
                            f.debug_tuple("WitNode::PrimS16").field(e).finish()
                        }
                        WitNode::PrimS32(e) => {
                            f.debug_tuple("WitNode::PrimS32").field(e).finish()
                        }
                        WitNode::PrimS64(e) => {
                            f.debug_tuple("WitNode::PrimS64").field(e).finish()
                        }
                        WitNode::PrimFloat32(e) => {
                            f.debug_tuple("WitNode::PrimFloat32").field(e).finish()
                        }
                        WitNode::PrimFloat64(e) => {
                            f.debug_tuple("WitNode::PrimFloat64").field(e).finish()
                        }
                        WitNode::PrimChar(e) => {
                            f.debug_tuple("WitNode::PrimChar").field(e).finish()
                        }
                        WitNode::PrimBool(e) => {
                            f.debug_tuple("WitNode::PrimBool").field(e).finish()
                        }
                        WitNode::PrimString(e) => {
                            f.debug_tuple("WitNode::PrimString").field(e).finish()
                        }
                        WitNode::Handle(e) => {
                            f.debug_tuple("WitNode::Handle").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct WitValue {
                pub nodes: _rt::Vec<WitNode>,
            }
            impl ::core::fmt::Debug for WitValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WitValue").field("nodes", &self.nodes).finish()
                }
            }
            #[derive(Clone)]
            pub struct ValueAndType {
                pub value: WitValue,
                pub typ: WitType,
            }
            impl ::core::fmt::Debug for ValueAndType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ValueAndType")
                        .field("value", &self.value)
                        .field("typ", &self.typ)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum RpcError {
                ProtocolError(_rt::String),
                Denied(_rt::String),
                NotFound(_rt::String),
                RemoteInternalError(_rt::String),
            }
            impl ::core::fmt::Debug for RpcError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        RpcError::ProtocolError(e) => {
                            f.debug_tuple("RpcError::ProtocolError").field(e).finish()
                        }
                        RpcError::Denied(e) => {
                            f.debug_tuple("RpcError::Denied").field(e).finish()
                        }
                        RpcError::NotFound(e) => {
                            f.debug_tuple("RpcError::NotFound").field(e).finish()
                        }
                        RpcError::RemoteInternalError(e) => {
                            f.debug_tuple("RpcError::RemoteInternalError")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for RpcError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for RpcError {}
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct WasmRpc {
                handle: _rt::Resource<WasmRpc>,
            }
            impl WasmRpc {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for WasmRpc {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]wasm-rpc"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct FutureInvokeResult {
                handle: _rt::Resource<FutureInvokeResult>,
            }
            impl FutureInvokeResult {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for FutureInvokeResult {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]future-invoke-result"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct CancellationToken {
                handle: _rt::Resource<CancellationToken>,
            }
            impl CancellationToken {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for CancellationToken {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]cancellation-token"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Parses a UUID from a string
            pub fn parse_uuid(uuid: &str) -> Result<Uuid, _rt::String> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let vec0 = uuid;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                    unsafe extern "C" {
                        #[link_name = "parse-uuid"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result9 = match l3 {
                        0 => {
                            let e = {
                                let l4 = *ptr1.add(8).cast::<i64>();
                                let l5 = *ptr1.add(16).cast::<i64>();
                                Uuid {
                                    high_bits: l4 as u64,
                                    low_bits: l5 as u64,
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l6 = *ptr1.add(8).cast::<*mut u8>();
                                let l7 = *ptr1
                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len8 = l7;
                                let bytes8 = _rt::Vec::from_raw_parts(
                                    l6.cast(),
                                    len8,
                                    len8,
                                );
                                _rt::string_lift(bytes8)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Converts a UUID to a string
            pub fn uuid_to_string(uuid: Uuid) -> _rt::String {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let Uuid { high_bits: high_bits0, low_bits: low_bits0 } = uuid;
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                    unsafe extern "C" {
                        #[link_name = "uuid-to-string"]
                        fn wit_import2(_: i64, _: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: i64, _: i64, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import2(
                            _rt::as_i64(high_bits0),
                            _rt::as_i64(low_bits0),
                            ptr1,
                        )
                    };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let result6 = _rt::string_lift(bytes5);
                    result6
                }
            }
            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new(worker_id: &WorkerId) -> Self {
                    unsafe {
                        let WorkerId {
                            component_id: component_id0,
                            worker_name: worker_name0,
                        } = worker_id;
                        let ComponentId { uuid: uuid1 } = component_id0;
                        let Uuid { high_bits: high_bits2, low_bits: low_bits2 } = uuid1;
                        let vec3 = worker_name0;
                        let ptr3 = vec3.as_ptr().cast::<u8>();
                        let len3 = vec3.len();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[constructor]wasm-rpc"]
                            fn wit_import4(_: i64, _: i64, _: *mut u8, _: usize) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import4(
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import4(
                                _rt::as_i64(high_bits2),
                                _rt::as_i64(low_bits2),
                                ptr3.cast_mut(),
                                len3,
                            )
                        };
                        unsafe { WasmRpc::from_handle(ret as u32) }
                    }
                }
            }
            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                pub fn ephemeral(component_id: ComponentId) -> WasmRpc {
                    unsafe {
                        let ComponentId { uuid: uuid0 } = component_id;
                        let Uuid { high_bits: high_bits1, low_bits: low_bits1 } = uuid0;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[static]wasm-rpc.ephemeral"]
                            fn wit_import2(_: i64, _: i64) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(_: i64, _: i64) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import2(_rt::as_i64(high_bits1), _rt::as_i64(low_bits1))
                        };
                        unsafe { WasmRpc::from_handle(ret as u32) }
                    }
                }
            }
            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                pub fn invoke_and_await(
                    &self,
                    function_name: &str,
                    function_params: &[WitValue],
                ) -> Result<WitValue, RpcError> {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = function_name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec12 = function_params;
                        let len12 = vec12.len();
                        let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec12.len() * (2 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result12 = if layout12.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout12);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec12.into_iter().enumerate() {
                            let base = result12
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            {
                                let WitValue { nodes: nodes1 } = e;
                                let vec11 = nodes1;
                                let len11 = vec11.len();
                                let layout11 = _rt::alloc::Layout::from_size_align_unchecked(
                                    vec11.len()
                                        * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                );
                                let result11 = if layout11.size() != 0 {
                                    let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
                                    if ptr.is_null() {
                                        _rt::alloc::handle_alloc_error(layout11);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec11.into_iter().enumerate() {
                                    let base = result11
                                        .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        match e {
                                            WitNode::RecordValue(e) => {
                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                let vec2 = e;
                                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                                let len2 = vec2.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len2;
                                                *base.add(8).cast::<*mut u8>() = ptr2.cast_mut();
                                            }
                                            WitNode::VariantValue(e) => {
                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                let (t3_0, t3_1) = e;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(t3_0);
                                                match t3_1 {
                                                    Some(e) => {
                                                        *base.add(12).cast::<u8>() = (1i32) as u8;
                                                        *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(12).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::EnumValue(e) => {
                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::FlagsValue(e) => {
                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                let vec4 = e;
                                                let len4 = vec4.len();
                                                let layout4 = _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec4.len() * 1,
                                                    1,
                                                );
                                                let result4 = if layout4.size() != 0 {
                                                    let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                                                    if ptr.is_null() {
                                                        _rt::alloc::handle_alloc_error(layout4);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec4.into_iter().enumerate() {
                                                    let base = result4.add(i * 1);
                                                    {
                                                        *base.add(0).cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                }
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len4;
                                                *base.add(8).cast::<*mut u8>() = result4;
                                                cleanup_list.extend_from_slice(&[(result4, layout4)]);
                                            }
                                            WitNode::TupleValue(e) => {
                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                let vec5 = e;
                                                let ptr5 = vec5.as_ptr().cast::<u8>();
                                                let len5 = vec5.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len5;
                                                *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                                            }
                                            WitNode::ListValue(e) => {
                                                *base.add(0).cast::<u8>() = (5i32) as u8;
                                                let vec6 = e;
                                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                                let len6 = vec6.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len6;
                                                *base.add(8).cast::<*mut u8>() = ptr6.cast_mut();
                                            }
                                            WitNode::OptionValue(e) => {
                                                *base.add(0).cast::<u8>() = (6i32) as u8;
                                                match e {
                                                    Some(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::ResultValue(e) => {
                                                *base.add(0).cast::<u8>() = (7i32) as u8;
                                                match e {
                                                    Ok(e) => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                    Err(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                };
                                            }
                                            WitNode::PrimU8(e) => {
                                                *base.add(0).cast::<u8>() = (8i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimU16(e) => {
                                                *base.add(0).cast::<u8>() = (9i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimU32(e) => {
                                                *base.add(0).cast::<u8>() = (10i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimU64(e) => {
                                                *base.add(0).cast::<u8>() = (11i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimS8(e) => {
                                                *base.add(0).cast::<u8>() = (12i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimS16(e) => {
                                                *base.add(0).cast::<u8>() = (13i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimS32(e) => {
                                                *base.add(0).cast::<u8>() = (14i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimS64(e) => {
                                                *base.add(0).cast::<u8>() = (15i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimFloat32(e) => {
                                                *base.add(0).cast::<u8>() = (16i32) as u8;
                                                *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                            }
                                            WitNode::PrimFloat64(e) => {
                                                *base.add(0).cast::<u8>() = (17i32) as u8;
                                                *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                            }
                                            WitNode::PrimChar(e) => {
                                                *base.add(0).cast::<u8>() = (18i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimBool(e) => {
                                                *base.add(0).cast::<u8>() = (19i32) as u8;
                                                *base.add(8).cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            WitNode::PrimString(e) => {
                                                *base.add(0).cast::<u8>() = (20i32) as u8;
                                                let vec7 = e;
                                                let ptr7 = vec7.as_ptr().cast::<u8>();
                                                let len7 = vec7.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len7;
                                                *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                            }
                                            WitNode::Handle(e) => {
                                                *base.add(0).cast::<u8>() = (21i32) as u8;
                                                let (t8_0, t8_1) = e;
                                                let Uri { value: value9 } = t8_0;
                                                let vec10 = value9;
                                                let ptr10 = vec10.as_ptr().cast::<u8>();
                                                let len10 = vec10.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len10;
                                                *base.add(8).cast::<*mut u8>() = ptr10.cast_mut();
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>() = _rt::as_i64(t8_1);
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len11;
                                *base.add(0).cast::<*mut u8>() = result11;
                                cleanup_list.extend_from_slice(&[(result11, layout11)]);
                            }
                        }
                        let ptr13 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[method]wasm-rpc.invoke-and-await"]
                            fn wit_import14(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import14(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import14(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                result12,
                                len12,
                                ptr13,
                            )
                        };
                        let l15 = i32::from(*ptr13.add(0).cast::<u8>());
                        let result78 = match l15 {
                            0 => {
                                let e = {
                                    let l16 = *ptr13
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l17 = *ptr13
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base63 = l16;
                                    let len63 = l17;
                                    let mut result63 = _rt::Vec::with_capacity(len63);
                                    for i in 0..len63 {
                                        let base = base63
                                            .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                        let e63 = {
                                            let l18 = i32::from(*base.add(0).cast::<u8>());
                                            let v62 = match l18 {
                                                0 => {
                                                    let e62 = {
                                                        let l19 = *base.add(8).cast::<*mut u8>();
                                                        let l20 = *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len21 = l20;
                                                        _rt::Vec::from_raw_parts(l19.cast(), len21, len21)
                                                    };
                                                    WitNode::RecordValue(e62)
                                                }
                                                1 => {
                                                    let e62 = {
                                                        let l22 = *base.add(8).cast::<i32>();
                                                        let l23 = i32::from(*base.add(12).cast::<u8>());
                                                        (
                                                            l22 as u32,
                                                            match l23 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l24 = *base.add(16).cast::<i32>();
                                                                        l24
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                        )
                                                    };
                                                    WitNode::VariantValue(e62)
                                                }
                                                2 => {
                                                    let e62 = {
                                                        let l25 = *base.add(8).cast::<i32>();
                                                        l25 as u32
                                                    };
                                                    WitNode::EnumValue(e62)
                                                }
                                                3 => {
                                                    let e62 = {
                                                        let l26 = *base.add(8).cast::<*mut u8>();
                                                        let l27 = *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let base29 = l26;
                                                        let len29 = l27;
                                                        let mut result29 = _rt::Vec::with_capacity(len29);
                                                        for i in 0..len29 {
                                                            let base = base29.add(i * 1);
                                                            let e29 = {
                                                                let l28 = i32::from(*base.add(0).cast::<u8>());
                                                                _rt::bool_lift(l28 as u8)
                                                            };
                                                            result29.push(e29);
                                                        }
                                                        _rt::cabi_dealloc(base29, len29 * 1, 1);
                                                        result29
                                                    };
                                                    WitNode::FlagsValue(e62)
                                                }
                                                4 => {
                                                    let e62 = {
                                                        let l30 = *base.add(8).cast::<*mut u8>();
                                                        let l31 = *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len32 = l31;
                                                        _rt::Vec::from_raw_parts(l30.cast(), len32, len32)
                                                    };
                                                    WitNode::TupleValue(e62)
                                                }
                                                5 => {
                                                    let e62 = {
                                                        let l33 = *base.add(8).cast::<*mut u8>();
                                                        let l34 = *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len35 = l34;
                                                        _rt::Vec::from_raw_parts(l33.cast(), len35, len35)
                                                    };
                                                    WitNode::ListValue(e62)
                                                }
                                                6 => {
                                                    let e62 = {
                                                        let l36 = i32::from(*base.add(8).cast::<u8>());
                                                        match l36 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l37 = *base.add(12).cast::<i32>();
                                                                    l37
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        }
                                                    };
                                                    WitNode::OptionValue(e62)
                                                }
                                                7 => {
                                                    let e62 = {
                                                        let l38 = i32::from(*base.add(8).cast::<u8>());
                                                        match l38 {
                                                            0 => {
                                                                let e = {
                                                                    let l39 = i32::from(*base.add(12).cast::<u8>());
                                                                    match l39 {
                                                                        0 => None,
                                                                        1 => {
                                                                            let e = {
                                                                                let l40 = *base.add(16).cast::<i32>();
                                                                                l40
                                                                            };
                                                                            Some(e)
                                                                        }
                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                    }
                                                                };
                                                                Ok(e)
                                                            }
                                                            1 => {
                                                                let e = {
                                                                    let l41 = i32::from(*base.add(12).cast::<u8>());
                                                                    match l41 {
                                                                        0 => None,
                                                                        1 => {
                                                                            let e = {
                                                                                let l42 = *base.add(16).cast::<i32>();
                                                                                l42
                                                                            };
                                                                            Some(e)
                                                                        }
                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                    }
                                                                };
                                                                Err(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        }
                                                    };
                                                    WitNode::ResultValue(e62)
                                                }
                                                8 => {
                                                    let e62 = {
                                                        let l43 = i32::from(*base.add(8).cast::<u8>());
                                                        l43 as u8
                                                    };
                                                    WitNode::PrimU8(e62)
                                                }
                                                9 => {
                                                    let e62 = {
                                                        let l44 = i32::from(*base.add(8).cast::<u16>());
                                                        l44 as u16
                                                    };
                                                    WitNode::PrimU16(e62)
                                                }
                                                10 => {
                                                    let e62 = {
                                                        let l45 = *base.add(8).cast::<i32>();
                                                        l45 as u32
                                                    };
                                                    WitNode::PrimU32(e62)
                                                }
                                                11 => {
                                                    let e62 = {
                                                        let l46 = *base.add(8).cast::<i64>();
                                                        l46 as u64
                                                    };
                                                    WitNode::PrimU64(e62)
                                                }
                                                12 => {
                                                    let e62 = {
                                                        let l47 = i32::from(*base.add(8).cast::<i8>());
                                                        l47 as i8
                                                    };
                                                    WitNode::PrimS8(e62)
                                                }
                                                13 => {
                                                    let e62 = {
                                                        let l48 = i32::from(*base.add(8).cast::<i16>());
                                                        l48 as i16
                                                    };
                                                    WitNode::PrimS16(e62)
                                                }
                                                14 => {
                                                    let e62 = {
                                                        let l49 = *base.add(8).cast::<i32>();
                                                        l49
                                                    };
                                                    WitNode::PrimS32(e62)
                                                }
                                                15 => {
                                                    let e62 = {
                                                        let l50 = *base.add(8).cast::<i64>();
                                                        l50
                                                    };
                                                    WitNode::PrimS64(e62)
                                                }
                                                16 => {
                                                    let e62 = {
                                                        let l51 = *base.add(8).cast::<f32>();
                                                        l51
                                                    };
                                                    WitNode::PrimFloat32(e62)
                                                }
                                                17 => {
                                                    let e62 = {
                                                        let l52 = *base.add(8).cast::<f64>();
                                                        l52
                                                    };
                                                    WitNode::PrimFloat64(e62)
                                                }
                                                18 => {
                                                    let e62 = {
                                                        let l53 = *base.add(8).cast::<i32>();
                                                        _rt::char_lift(l53 as u32)
                                                    };
                                                    WitNode::PrimChar(e62)
                                                }
                                                19 => {
                                                    let e62 = {
                                                        let l54 = i32::from(*base.add(8).cast::<u8>());
                                                        _rt::bool_lift(l54 as u8)
                                                    };
                                                    WitNode::PrimBool(e62)
                                                }
                                                20 => {
                                                    let e62 = {
                                                        let l55 = *base.add(8).cast::<*mut u8>();
                                                        let l56 = *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len57 = l56;
                                                        let bytes57 = _rt::Vec::from_raw_parts(
                                                            l55.cast(),
                                                            len57,
                                                            len57,
                                                        );
                                                        _rt::string_lift(bytes57)
                                                    };
                                                    WitNode::PrimString(e62)
                                                }
                                                n => {
                                                    debug_assert_eq!(n, 21, "invalid enum discriminant");
                                                    let e62 = {
                                                        let l58 = *base.add(8).cast::<*mut u8>();
                                                        let l59 = *base
                                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len60 = l59;
                                                        let bytes60 = _rt::Vec::from_raw_parts(
                                                            l58.cast(),
                                                            len60,
                                                            len60,
                                                        );
                                                        let l61 = *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>();
                                                        (
                                                            Uri {
                                                                value: _rt::string_lift(bytes60),
                                                            },
                                                            l61 as u64,
                                                        )
                                                    };
                                                    WitNode::Handle(e62)
                                                }
                                            };
                                            v62
                                        };
                                        result63.push(e63);
                                    }
                                    _rt::cabi_dealloc(
                                        base63,
                                        len63 * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    );
                                    WitValue { nodes: result63 }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l64 = i32::from(
                                        *ptr13.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v77 = match l64 {
                                        0 => {
                                            let e77 = {
                                                let l65 = *ptr13
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l66 = *ptr13
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len67 = l66;
                                                let bytes67 = _rt::Vec::from_raw_parts(
                                                    l65.cast(),
                                                    len67,
                                                    len67,
                                                );
                                                _rt::string_lift(bytes67)
                                            };
                                            RpcError::ProtocolError(e77)
                                        }
                                        1 => {
                                            let e77 = {
                                                let l68 = *ptr13
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l69 = *ptr13
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len70 = l69;
                                                let bytes70 = _rt::Vec::from_raw_parts(
                                                    l68.cast(),
                                                    len70,
                                                    len70,
                                                );
                                                _rt::string_lift(bytes70)
                                            };
                                            RpcError::Denied(e77)
                                        }
                                        2 => {
                                            let e77 = {
                                                let l71 = *ptr13
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l72 = *ptr13
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len73 = l72;
                                                let bytes73 = _rt::Vec::from_raw_parts(
                                                    l71.cast(),
                                                    len73,
                                                    len73,
                                                );
                                                _rt::string_lift(bytes73)
                                            };
                                            RpcError::NotFound(e77)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                                            let e77 = {
                                                let l74 = *ptr13
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l75 = *ptr13
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len76 = l75;
                                                let bytes76 = _rt::Vec::from_raw_parts(
                                                    l74.cast(),
                                                    len76,
                                                    len76,
                                                );
                                                _rt::string_lift(bytes76)
                                            };
                                            RpcError::RemoteInternalError(e77)
                                        }
                                    };
                                    v77
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        if layout12.size() != 0 {
                            _rt::alloc::dealloc(result12.cast(), layout12);
                        }
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                _rt::alloc::dealloc(ptr.cast(), layout);
                            }
                        }
                        result78
                    }
                }
            }
            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                pub fn invoke(
                    &self,
                    function_name: &str,
                    function_params: &[WitValue],
                ) -> Result<(), RpcError> {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = function_name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec12 = function_params;
                        let len12 = vec12.len();
                        let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec12.len() * (2 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result12 = if layout12.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout12);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec12.into_iter().enumerate() {
                            let base = result12
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            {
                                let WitValue { nodes: nodes1 } = e;
                                let vec11 = nodes1;
                                let len11 = vec11.len();
                                let layout11 = _rt::alloc::Layout::from_size_align_unchecked(
                                    vec11.len()
                                        * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                );
                                let result11 = if layout11.size() != 0 {
                                    let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
                                    if ptr.is_null() {
                                        _rt::alloc::handle_alloc_error(layout11);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec11.into_iter().enumerate() {
                                    let base = result11
                                        .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        match e {
                                            WitNode::RecordValue(e) => {
                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                let vec2 = e;
                                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                                let len2 = vec2.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len2;
                                                *base.add(8).cast::<*mut u8>() = ptr2.cast_mut();
                                            }
                                            WitNode::VariantValue(e) => {
                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                let (t3_0, t3_1) = e;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(t3_0);
                                                match t3_1 {
                                                    Some(e) => {
                                                        *base.add(12).cast::<u8>() = (1i32) as u8;
                                                        *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(12).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::EnumValue(e) => {
                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::FlagsValue(e) => {
                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                let vec4 = e;
                                                let len4 = vec4.len();
                                                let layout4 = _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec4.len() * 1,
                                                    1,
                                                );
                                                let result4 = if layout4.size() != 0 {
                                                    let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                                                    if ptr.is_null() {
                                                        _rt::alloc::handle_alloc_error(layout4);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec4.into_iter().enumerate() {
                                                    let base = result4.add(i * 1);
                                                    {
                                                        *base.add(0).cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                }
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len4;
                                                *base.add(8).cast::<*mut u8>() = result4;
                                                cleanup_list.extend_from_slice(&[(result4, layout4)]);
                                            }
                                            WitNode::TupleValue(e) => {
                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                let vec5 = e;
                                                let ptr5 = vec5.as_ptr().cast::<u8>();
                                                let len5 = vec5.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len5;
                                                *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                                            }
                                            WitNode::ListValue(e) => {
                                                *base.add(0).cast::<u8>() = (5i32) as u8;
                                                let vec6 = e;
                                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                                let len6 = vec6.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len6;
                                                *base.add(8).cast::<*mut u8>() = ptr6.cast_mut();
                                            }
                                            WitNode::OptionValue(e) => {
                                                *base.add(0).cast::<u8>() = (6i32) as u8;
                                                match e {
                                                    Some(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::ResultValue(e) => {
                                                *base.add(0).cast::<u8>() = (7i32) as u8;
                                                match e {
                                                    Ok(e) => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                    Err(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                };
                                            }
                                            WitNode::PrimU8(e) => {
                                                *base.add(0).cast::<u8>() = (8i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimU16(e) => {
                                                *base.add(0).cast::<u8>() = (9i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimU32(e) => {
                                                *base.add(0).cast::<u8>() = (10i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimU64(e) => {
                                                *base.add(0).cast::<u8>() = (11i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimS8(e) => {
                                                *base.add(0).cast::<u8>() = (12i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimS16(e) => {
                                                *base.add(0).cast::<u8>() = (13i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimS32(e) => {
                                                *base.add(0).cast::<u8>() = (14i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimS64(e) => {
                                                *base.add(0).cast::<u8>() = (15i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimFloat32(e) => {
                                                *base.add(0).cast::<u8>() = (16i32) as u8;
                                                *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                            }
                                            WitNode::PrimFloat64(e) => {
                                                *base.add(0).cast::<u8>() = (17i32) as u8;
                                                *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                            }
                                            WitNode::PrimChar(e) => {
                                                *base.add(0).cast::<u8>() = (18i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimBool(e) => {
                                                *base.add(0).cast::<u8>() = (19i32) as u8;
                                                *base.add(8).cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            WitNode::PrimString(e) => {
                                                *base.add(0).cast::<u8>() = (20i32) as u8;
                                                let vec7 = e;
                                                let ptr7 = vec7.as_ptr().cast::<u8>();
                                                let len7 = vec7.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len7;
                                                *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                            }
                                            WitNode::Handle(e) => {
                                                *base.add(0).cast::<u8>() = (21i32) as u8;
                                                let (t8_0, t8_1) = e;
                                                let Uri { value: value9 } = t8_0;
                                                let vec10 = value9;
                                                let ptr10 = vec10.as_ptr().cast::<u8>();
                                                let len10 = vec10.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len10;
                                                *base.add(8).cast::<*mut u8>() = ptr10.cast_mut();
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>() = _rt::as_i64(t8_1);
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len11;
                                *base.add(0).cast::<*mut u8>() = result11;
                                cleanup_list.extend_from_slice(&[(result11, layout11)]);
                            }
                        }
                        let ptr13 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[method]wasm-rpc.invoke"]
                            fn wit_import14(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import14(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import14(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                result12,
                                len12,
                                ptr13,
                            )
                        };
                        let l15 = i32::from(*ptr13.add(0).cast::<u8>());
                        let result30 = match l15 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l16 = i32::from(
                                        *ptr13.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v29 = match l16 {
                                        0 => {
                                            let e29 = {
                                                let l17 = *ptr13
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l18 = *ptr13
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len19 = l18;
                                                let bytes19 = _rt::Vec::from_raw_parts(
                                                    l17.cast(),
                                                    len19,
                                                    len19,
                                                );
                                                _rt::string_lift(bytes19)
                                            };
                                            RpcError::ProtocolError(e29)
                                        }
                                        1 => {
                                            let e29 = {
                                                let l20 = *ptr13
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l21 = *ptr13
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len22 = l21;
                                                let bytes22 = _rt::Vec::from_raw_parts(
                                                    l20.cast(),
                                                    len22,
                                                    len22,
                                                );
                                                _rt::string_lift(bytes22)
                                            };
                                            RpcError::Denied(e29)
                                        }
                                        2 => {
                                            let e29 = {
                                                let l23 = *ptr13
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l24 = *ptr13
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len25 = l24;
                                                let bytes25 = _rt::Vec::from_raw_parts(
                                                    l23.cast(),
                                                    len25,
                                                    len25,
                                                );
                                                _rt::string_lift(bytes25)
                                            };
                                            RpcError::NotFound(e29)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                                            let e29 = {
                                                let l26 = *ptr13
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l27 = *ptr13
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len28 = l27;
                                                let bytes28 = _rt::Vec::from_raw_parts(
                                                    l26.cast(),
                                                    len28,
                                                    len28,
                                                );
                                                _rt::string_lift(bytes28)
                                            };
                                            RpcError::RemoteInternalError(e29)
                                        }
                                    };
                                    v29
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        if layout12.size() != 0 {
                            _rt::alloc::dealloc(result12.cast(), layout12);
                        }
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                _rt::alloc::dealloc(ptr.cast(), layout);
                            }
                        }
                        result30
                    }
                }
            }
            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                pub fn async_invoke_and_await(
                    &self,
                    function_name: &str,
                    function_params: &[WitValue],
                ) -> FutureInvokeResult {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        let vec0 = function_name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec12 = function_params;
                        let len12 = vec12.len();
                        let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec12.len() * (2 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result12 = if layout12.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout12);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec12.into_iter().enumerate() {
                            let base = result12
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            {
                                let WitValue { nodes: nodes1 } = e;
                                let vec11 = nodes1;
                                let len11 = vec11.len();
                                let layout11 = _rt::alloc::Layout::from_size_align_unchecked(
                                    vec11.len()
                                        * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                );
                                let result11 = if layout11.size() != 0 {
                                    let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
                                    if ptr.is_null() {
                                        _rt::alloc::handle_alloc_error(layout11);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec11.into_iter().enumerate() {
                                    let base = result11
                                        .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        match e {
                                            WitNode::RecordValue(e) => {
                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                let vec2 = e;
                                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                                let len2 = vec2.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len2;
                                                *base.add(8).cast::<*mut u8>() = ptr2.cast_mut();
                                            }
                                            WitNode::VariantValue(e) => {
                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                let (t3_0, t3_1) = e;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(t3_0);
                                                match t3_1 {
                                                    Some(e) => {
                                                        *base.add(12).cast::<u8>() = (1i32) as u8;
                                                        *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(12).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::EnumValue(e) => {
                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::FlagsValue(e) => {
                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                let vec4 = e;
                                                let len4 = vec4.len();
                                                let layout4 = _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec4.len() * 1,
                                                    1,
                                                );
                                                let result4 = if layout4.size() != 0 {
                                                    let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                                                    if ptr.is_null() {
                                                        _rt::alloc::handle_alloc_error(layout4);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec4.into_iter().enumerate() {
                                                    let base = result4.add(i * 1);
                                                    {
                                                        *base.add(0).cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                }
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len4;
                                                *base.add(8).cast::<*mut u8>() = result4;
                                                cleanup_list.extend_from_slice(&[(result4, layout4)]);
                                            }
                                            WitNode::TupleValue(e) => {
                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                let vec5 = e;
                                                let ptr5 = vec5.as_ptr().cast::<u8>();
                                                let len5 = vec5.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len5;
                                                *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                                            }
                                            WitNode::ListValue(e) => {
                                                *base.add(0).cast::<u8>() = (5i32) as u8;
                                                let vec6 = e;
                                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                                let len6 = vec6.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len6;
                                                *base.add(8).cast::<*mut u8>() = ptr6.cast_mut();
                                            }
                                            WitNode::OptionValue(e) => {
                                                *base.add(0).cast::<u8>() = (6i32) as u8;
                                                match e {
                                                    Some(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::ResultValue(e) => {
                                                *base.add(0).cast::<u8>() = (7i32) as u8;
                                                match e {
                                                    Ok(e) => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                    Err(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                };
                                            }
                                            WitNode::PrimU8(e) => {
                                                *base.add(0).cast::<u8>() = (8i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimU16(e) => {
                                                *base.add(0).cast::<u8>() = (9i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimU32(e) => {
                                                *base.add(0).cast::<u8>() = (10i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimU64(e) => {
                                                *base.add(0).cast::<u8>() = (11i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimS8(e) => {
                                                *base.add(0).cast::<u8>() = (12i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimS16(e) => {
                                                *base.add(0).cast::<u8>() = (13i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimS32(e) => {
                                                *base.add(0).cast::<u8>() = (14i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimS64(e) => {
                                                *base.add(0).cast::<u8>() = (15i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimFloat32(e) => {
                                                *base.add(0).cast::<u8>() = (16i32) as u8;
                                                *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                            }
                                            WitNode::PrimFloat64(e) => {
                                                *base.add(0).cast::<u8>() = (17i32) as u8;
                                                *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                            }
                                            WitNode::PrimChar(e) => {
                                                *base.add(0).cast::<u8>() = (18i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimBool(e) => {
                                                *base.add(0).cast::<u8>() = (19i32) as u8;
                                                *base.add(8).cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            WitNode::PrimString(e) => {
                                                *base.add(0).cast::<u8>() = (20i32) as u8;
                                                let vec7 = e;
                                                let ptr7 = vec7.as_ptr().cast::<u8>();
                                                let len7 = vec7.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len7;
                                                *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                            }
                                            WitNode::Handle(e) => {
                                                *base.add(0).cast::<u8>() = (21i32) as u8;
                                                let (t8_0, t8_1) = e;
                                                let Uri { value: value9 } = t8_0;
                                                let vec10 = value9;
                                                let ptr10 = vec10.as_ptr().cast::<u8>();
                                                let len10 = vec10.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len10;
                                                *base.add(8).cast::<*mut u8>() = ptr10.cast_mut();
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>() = _rt::as_i64(t8_1);
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len11;
                                *base.add(0).cast::<*mut u8>() = result11;
                                cleanup_list.extend_from_slice(&[(result11, layout11)]);
                            }
                        }
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[method]wasm-rpc.async-invoke-and-await"]
                            fn wit_import13(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                            ) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import13(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import13(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                result12,
                                len12,
                            )
                        };
                        if layout12.size() != 0 {
                            _rt::alloc::dealloc(result12.cast(), layout12);
                        }
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                _rt::alloc::dealloc(ptr.cast(), layout);
                            }
                        }
                        unsafe { FutureInvokeResult::from_handle(ret as u32) }
                    }
                }
            }
            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                /// Schedule invocation for later
                pub fn schedule_invocation(
                    &self,
                    scheduled_time: Datetime,
                    function_name: &str,
                    function_params: &[WitValue],
                ) -> () {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                            seconds: seconds0,
                            nanoseconds: nanoseconds0,
                        } = scheduled_time;
                        let vec1 = function_name;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let vec13 = function_params;
                        let len13 = vec13.len();
                        let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec13.len() * (2 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result13 = if layout13.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout13);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec13.into_iter().enumerate() {
                            let base = result13
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            {
                                let WitValue { nodes: nodes2 } = e;
                                let vec12 = nodes2;
                                let len12 = vec12.len();
                                let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                                    vec12.len()
                                        * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                );
                                let result12 = if layout12.size() != 0 {
                                    let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                    if ptr.is_null() {
                                        _rt::alloc::handle_alloc_error(layout12);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec12.into_iter().enumerate() {
                                    let base = result12
                                        .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        match e {
                                            WitNode::RecordValue(e) => {
                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                let vec3 = e;
                                                let ptr3 = vec3.as_ptr().cast::<u8>();
                                                let len3 = vec3.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len3;
                                                *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                                            }
                                            WitNode::VariantValue(e) => {
                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                let (t4_0, t4_1) = e;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(t4_0);
                                                match t4_1 {
                                                    Some(e) => {
                                                        *base.add(12).cast::<u8>() = (1i32) as u8;
                                                        *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(12).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::EnumValue(e) => {
                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::FlagsValue(e) => {
                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                let vec5 = e;
                                                let len5 = vec5.len();
                                                let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec5.len() * 1,
                                                    1,
                                                );
                                                let result5 = if layout5.size() != 0 {
                                                    let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                                                    if ptr.is_null() {
                                                        _rt::alloc::handle_alloc_error(layout5);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec5.into_iter().enumerate() {
                                                    let base = result5.add(i * 1);
                                                    {
                                                        *base.add(0).cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                }
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len5;
                                                *base.add(8).cast::<*mut u8>() = result5;
                                                cleanup_list.extend_from_slice(&[(result5, layout5)]);
                                            }
                                            WitNode::TupleValue(e) => {
                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                let vec6 = e;
                                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                                let len6 = vec6.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len6;
                                                *base.add(8).cast::<*mut u8>() = ptr6.cast_mut();
                                            }
                                            WitNode::ListValue(e) => {
                                                *base.add(0).cast::<u8>() = (5i32) as u8;
                                                let vec7 = e;
                                                let ptr7 = vec7.as_ptr().cast::<u8>();
                                                let len7 = vec7.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len7;
                                                *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                            }
                                            WitNode::OptionValue(e) => {
                                                *base.add(0).cast::<u8>() = (6i32) as u8;
                                                match e {
                                                    Some(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::ResultValue(e) => {
                                                *base.add(0).cast::<u8>() = (7i32) as u8;
                                                match e {
                                                    Ok(e) => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                    Err(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                };
                                            }
                                            WitNode::PrimU8(e) => {
                                                *base.add(0).cast::<u8>() = (8i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimU16(e) => {
                                                *base.add(0).cast::<u8>() = (9i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimU32(e) => {
                                                *base.add(0).cast::<u8>() = (10i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimU64(e) => {
                                                *base.add(0).cast::<u8>() = (11i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimS8(e) => {
                                                *base.add(0).cast::<u8>() = (12i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimS16(e) => {
                                                *base.add(0).cast::<u8>() = (13i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimS32(e) => {
                                                *base.add(0).cast::<u8>() = (14i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimS64(e) => {
                                                *base.add(0).cast::<u8>() = (15i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimFloat32(e) => {
                                                *base.add(0).cast::<u8>() = (16i32) as u8;
                                                *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                            }
                                            WitNode::PrimFloat64(e) => {
                                                *base.add(0).cast::<u8>() = (17i32) as u8;
                                                *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                            }
                                            WitNode::PrimChar(e) => {
                                                *base.add(0).cast::<u8>() = (18i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimBool(e) => {
                                                *base.add(0).cast::<u8>() = (19i32) as u8;
                                                *base.add(8).cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            WitNode::PrimString(e) => {
                                                *base.add(0).cast::<u8>() = (20i32) as u8;
                                                let vec8 = e;
                                                let ptr8 = vec8.as_ptr().cast::<u8>();
                                                let len8 = vec8.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len8;
                                                *base.add(8).cast::<*mut u8>() = ptr8.cast_mut();
                                            }
                                            WitNode::Handle(e) => {
                                                *base.add(0).cast::<u8>() = (21i32) as u8;
                                                let (t9_0, t9_1) = e;
                                                let Uri { value: value10 } = t9_0;
                                                let vec11 = value10;
                                                let ptr11 = vec11.as_ptr().cast::<u8>();
                                                let len11 = vec11.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len11;
                                                *base.add(8).cast::<*mut u8>() = ptr11.cast_mut();
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>() = _rt::as_i64(t9_1);
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len12;
                                *base.add(0).cast::<*mut u8>() = result12;
                                cleanup_list.extend_from_slice(&[(result12, layout12)]);
                            }
                        }
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[method]wasm-rpc.schedule-invocation"]
                            fn wit_import14(
                                _: i32,
                                _: i64,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import14(
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import14(
                                (self).handle() as i32,
                                _rt::as_i64(seconds0),
                                _rt::as_i32(nanoseconds0),
                                ptr1.cast_mut(),
                                len1,
                                result13,
                                len13,
                            )
                        };
                        if layout13.size() != 0 {
                            _rt::alloc::dealloc(result13.cast(), layout13);
                        }
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                _rt::alloc::dealloc(ptr.cast(), layout);
                            }
                        }
                    }
                }
            }
            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                /// Schedule invocation for later. Call cancel on the returned resource to cancel the invocation before the scheduled time.
                pub fn schedule_cancelable_invocation(
                    &self,
                    scheduled_time: Datetime,
                    function_name: &str,
                    function_params: &[WitValue],
                ) -> CancellationToken {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                            seconds: seconds0,
                            nanoseconds: nanoseconds0,
                        } = scheduled_time;
                        let vec1 = function_name;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let vec13 = function_params;
                        let len13 = vec13.len();
                        let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec13.len() * (2 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result13 = if layout13.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout13);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec13.into_iter().enumerate() {
                            let base = result13
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            {
                                let WitValue { nodes: nodes2 } = e;
                                let vec12 = nodes2;
                                let len12 = vec12.len();
                                let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                                    vec12.len()
                                        * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                );
                                let result12 = if layout12.size() != 0 {
                                    let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                    if ptr.is_null() {
                                        _rt::alloc::handle_alloc_error(layout12);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec12.into_iter().enumerate() {
                                    let base = result12
                                        .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        match e {
                                            WitNode::RecordValue(e) => {
                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                let vec3 = e;
                                                let ptr3 = vec3.as_ptr().cast::<u8>();
                                                let len3 = vec3.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len3;
                                                *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                                            }
                                            WitNode::VariantValue(e) => {
                                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                                let (t4_0, t4_1) = e;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(t4_0);
                                                match t4_1 {
                                                    Some(e) => {
                                                        *base.add(12).cast::<u8>() = (1i32) as u8;
                                                        *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(12).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::EnumValue(e) => {
                                                *base.add(0).cast::<u8>() = (2i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::FlagsValue(e) => {
                                                *base.add(0).cast::<u8>() = (3i32) as u8;
                                                let vec5 = e;
                                                let len5 = vec5.len();
                                                let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                                                    vec5.len() * 1,
                                                    1,
                                                );
                                                let result5 = if layout5.size() != 0 {
                                                    let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                                                    if ptr.is_null() {
                                                        _rt::alloc::handle_alloc_error(layout5);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec5.into_iter().enumerate() {
                                                    let base = result5.add(i * 1);
                                                    {
                                                        *base.add(0).cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                }
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len5;
                                                *base.add(8).cast::<*mut u8>() = result5;
                                                cleanup_list.extend_from_slice(&[(result5, layout5)]);
                                            }
                                            WitNode::TupleValue(e) => {
                                                *base.add(0).cast::<u8>() = (4i32) as u8;
                                                let vec6 = e;
                                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                                let len6 = vec6.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len6;
                                                *base.add(8).cast::<*mut u8>() = ptr6.cast_mut();
                                            }
                                            WitNode::ListValue(e) => {
                                                *base.add(0).cast::<u8>() = (5i32) as u8;
                                                let vec7 = e;
                                                let ptr7 = vec7.as_ptr().cast::<u8>();
                                                let len7 = vec7.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len7;
                                                *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                            }
                                            WitNode::OptionValue(e) => {
                                                *base.add(0).cast::<u8>() = (6i32) as u8;
                                                match e {
                                                    Some(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::ResultValue(e) => {
                                                *base.add(0).cast::<u8>() = (7i32) as u8;
                                                match e {
                                                    Ok(e) => {
                                                        *base.add(8).cast::<u8>() = (0i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                    Err(e) => {
                                                        *base.add(8).cast::<u8>() = (1i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                };
                                            }
                                            WitNode::PrimU8(e) => {
                                                *base.add(0).cast::<u8>() = (8i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimU16(e) => {
                                                *base.add(0).cast::<u8>() = (9i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimU32(e) => {
                                                *base.add(0).cast::<u8>() = (10i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimU64(e) => {
                                                *base.add(0).cast::<u8>() = (11i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimS8(e) => {
                                                *base.add(0).cast::<u8>() = (12i32) as u8;
                                                *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimS16(e) => {
                                                *base.add(0).cast::<u8>() = (13i32) as u8;
                                                *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimS32(e) => {
                                                *base.add(0).cast::<u8>() = (14i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimS64(e) => {
                                                *base.add(0).cast::<u8>() = (15i32) as u8;
                                                *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                            }
                                            WitNode::PrimFloat32(e) => {
                                                *base.add(0).cast::<u8>() = (16i32) as u8;
                                                *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                            }
                                            WitNode::PrimFloat64(e) => {
                                                *base.add(0).cast::<u8>() = (17i32) as u8;
                                                *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                            }
                                            WitNode::PrimChar(e) => {
                                                *base.add(0).cast::<u8>() = (18i32) as u8;
                                                *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                            }
                                            WitNode::PrimBool(e) => {
                                                *base.add(0).cast::<u8>() = (19i32) as u8;
                                                *base.add(8).cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            WitNode::PrimString(e) => {
                                                *base.add(0).cast::<u8>() = (20i32) as u8;
                                                let vec8 = e;
                                                let ptr8 = vec8.as_ptr().cast::<u8>();
                                                let len8 = vec8.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len8;
                                                *base.add(8).cast::<*mut u8>() = ptr8.cast_mut();
                                            }
                                            WitNode::Handle(e) => {
                                                *base.add(0).cast::<u8>() = (21i32) as u8;
                                                let (t9_0, t9_1) = e;
                                                let Uri { value: value10 } = t9_0;
                                                let vec11 = value10;
                                                let ptr11 = vec11.as_ptr().cast::<u8>();
                                                let len11 = vec11.len();
                                                *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len11;
                                                *base.add(8).cast::<*mut u8>() = ptr11.cast_mut();
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>() = _rt::as_i64(t9_1);
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len12;
                                *base.add(0).cast::<*mut u8>() = result12;
                                cleanup_list.extend_from_slice(&[(result12, layout12)]);
                            }
                        }
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[method]wasm-rpc.schedule-cancelable-invocation"]
                            fn wit_import14(
                                _: i32,
                                _: i64,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                            ) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import14(
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import14(
                                (self).handle() as i32,
                                _rt::as_i64(seconds0),
                                _rt::as_i32(nanoseconds0),
                                ptr1.cast_mut(),
                                len1,
                                result13,
                                len13,
                            )
                        };
                        if layout13.size() != 0 {
                            _rt::alloc::dealloc(result13.cast(), layout13);
                        }
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                _rt::alloc::dealloc(ptr.cast(), layout);
                            }
                        }
                        unsafe { CancellationToken::from_handle(ret as u32) }
                    }
                }
            }
            impl FutureInvokeResult {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[method]future-invoke-result.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            impl FutureInvokeResult {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get(&self) -> Option<Result<WitValue, RpcError>> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 5 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 5
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[method]future-invoke-result.get"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result66 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    match l3 {
                                        0 => {
                                            let e = {
                                                let l4 = *ptr0
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l5 = *ptr0
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base51 = l4;
                                                let len51 = l5;
                                                let mut result51 = _rt::Vec::with_capacity(len51);
                                                for i in 0..len51 {
                                                    let base = base51
                                                        .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                                    let e51 = {
                                                        let l6 = i32::from(*base.add(0).cast::<u8>());
                                                        let v50 = match l6 {
                                                            0 => {
                                                                let e50 = {
                                                                    let l7 = *base.add(8).cast::<*mut u8>();
                                                                    let l8 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len9 = l8;
                                                                    _rt::Vec::from_raw_parts(l7.cast(), len9, len9)
                                                                };
                                                                WitNode::RecordValue(e50)
                                                            }
                                                            1 => {
                                                                let e50 = {
                                                                    let l10 = *base.add(8).cast::<i32>();
                                                                    let l11 = i32::from(*base.add(12).cast::<u8>());
                                                                    (
                                                                        l10 as u32,
                                                                        match l11 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l12 = *base.add(16).cast::<i32>();
                                                                                    l12
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        },
                                                                    )
                                                                };
                                                                WitNode::VariantValue(e50)
                                                            }
                                                            2 => {
                                                                let e50 = {
                                                                    let l13 = *base.add(8).cast::<i32>();
                                                                    l13 as u32
                                                                };
                                                                WitNode::EnumValue(e50)
                                                            }
                                                            3 => {
                                                                let e50 = {
                                                                    let l14 = *base.add(8).cast::<*mut u8>();
                                                                    let l15 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base17 = l14;
                                                                    let len17 = l15;
                                                                    let mut result17 = _rt::Vec::with_capacity(len17);
                                                                    for i in 0..len17 {
                                                                        let base = base17.add(i * 1);
                                                                        let e17 = {
                                                                            let l16 = i32::from(*base.add(0).cast::<u8>());
                                                                            _rt::bool_lift(l16 as u8)
                                                                        };
                                                                        result17.push(e17);
                                                                    }
                                                                    _rt::cabi_dealloc(base17, len17 * 1, 1);
                                                                    result17
                                                                };
                                                                WitNode::FlagsValue(e50)
                                                            }
                                                            4 => {
                                                                let e50 = {
                                                                    let l18 = *base.add(8).cast::<*mut u8>();
                                                                    let l19 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len20 = l19;
                                                                    _rt::Vec::from_raw_parts(l18.cast(), len20, len20)
                                                                };
                                                                WitNode::TupleValue(e50)
                                                            }
                                                            5 => {
                                                                let e50 = {
                                                                    let l21 = *base.add(8).cast::<*mut u8>();
                                                                    let l22 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len23 = l22;
                                                                    _rt::Vec::from_raw_parts(l21.cast(), len23, len23)
                                                                };
                                                                WitNode::ListValue(e50)
                                                            }
                                                            6 => {
                                                                let e50 = {
                                                                    let l24 = i32::from(*base.add(8).cast::<u8>());
                                                                    match l24 {
                                                                        0 => None,
                                                                        1 => {
                                                                            let e = {
                                                                                let l25 = *base.add(12).cast::<i32>();
                                                                                l25
                                                                            };
                                                                            Some(e)
                                                                        }
                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                    }
                                                                };
                                                                WitNode::OptionValue(e50)
                                                            }
                                                            7 => {
                                                                let e50 = {
                                                                    let l26 = i32::from(*base.add(8).cast::<u8>());
                                                                    match l26 {
                                                                        0 => {
                                                                            let e = {
                                                                                let l27 = i32::from(*base.add(12).cast::<u8>());
                                                                                match l27 {
                                                                                    0 => None,
                                                                                    1 => {
                                                                                        let e = {
                                                                                            let l28 = *base.add(16).cast::<i32>();
                                                                                            l28
                                                                                        };
                                                                                        Some(e)
                                                                                    }
                                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                                }
                                                                            };
                                                                            Ok(e)
                                                                        }
                                                                        1 => {
                                                                            let e = {
                                                                                let l29 = i32::from(*base.add(12).cast::<u8>());
                                                                                match l29 {
                                                                                    0 => None,
                                                                                    1 => {
                                                                                        let e = {
                                                                                            let l30 = *base.add(16).cast::<i32>();
                                                                                            l30
                                                                                        };
                                                                                        Some(e)
                                                                                    }
                                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                                }
                                                                            };
                                                                            Err(e)
                                                                        }
                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                    }
                                                                };
                                                                WitNode::ResultValue(e50)
                                                            }
                                                            8 => {
                                                                let e50 = {
                                                                    let l31 = i32::from(*base.add(8).cast::<u8>());
                                                                    l31 as u8
                                                                };
                                                                WitNode::PrimU8(e50)
                                                            }
                                                            9 => {
                                                                let e50 = {
                                                                    let l32 = i32::from(*base.add(8).cast::<u16>());
                                                                    l32 as u16
                                                                };
                                                                WitNode::PrimU16(e50)
                                                            }
                                                            10 => {
                                                                let e50 = {
                                                                    let l33 = *base.add(8).cast::<i32>();
                                                                    l33 as u32
                                                                };
                                                                WitNode::PrimU32(e50)
                                                            }
                                                            11 => {
                                                                let e50 = {
                                                                    let l34 = *base.add(8).cast::<i64>();
                                                                    l34 as u64
                                                                };
                                                                WitNode::PrimU64(e50)
                                                            }
                                                            12 => {
                                                                let e50 = {
                                                                    let l35 = i32::from(*base.add(8).cast::<i8>());
                                                                    l35 as i8
                                                                };
                                                                WitNode::PrimS8(e50)
                                                            }
                                                            13 => {
                                                                let e50 = {
                                                                    let l36 = i32::from(*base.add(8).cast::<i16>());
                                                                    l36 as i16
                                                                };
                                                                WitNode::PrimS16(e50)
                                                            }
                                                            14 => {
                                                                let e50 = {
                                                                    let l37 = *base.add(8).cast::<i32>();
                                                                    l37
                                                                };
                                                                WitNode::PrimS32(e50)
                                                            }
                                                            15 => {
                                                                let e50 = {
                                                                    let l38 = *base.add(8).cast::<i64>();
                                                                    l38
                                                                };
                                                                WitNode::PrimS64(e50)
                                                            }
                                                            16 => {
                                                                let e50 = {
                                                                    let l39 = *base.add(8).cast::<f32>();
                                                                    l39
                                                                };
                                                                WitNode::PrimFloat32(e50)
                                                            }
                                                            17 => {
                                                                let e50 = {
                                                                    let l40 = *base.add(8).cast::<f64>();
                                                                    l40
                                                                };
                                                                WitNode::PrimFloat64(e50)
                                                            }
                                                            18 => {
                                                                let e50 = {
                                                                    let l41 = *base.add(8).cast::<i32>();
                                                                    _rt::char_lift(l41 as u32)
                                                                };
                                                                WitNode::PrimChar(e50)
                                                            }
                                                            19 => {
                                                                let e50 = {
                                                                    let l42 = i32::from(*base.add(8).cast::<u8>());
                                                                    _rt::bool_lift(l42 as u8)
                                                                };
                                                                WitNode::PrimBool(e50)
                                                            }
                                                            20 => {
                                                                let e50 = {
                                                                    let l43 = *base.add(8).cast::<*mut u8>();
                                                                    let l44 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len45 = l44;
                                                                    let bytes45 = _rt::Vec::from_raw_parts(
                                                                        l43.cast(),
                                                                        len45,
                                                                        len45,
                                                                    );
                                                                    _rt::string_lift(bytes45)
                                                                };
                                                                WitNode::PrimString(e50)
                                                            }
                                                            n => {
                                                                debug_assert_eq!(n, 21, "invalid enum discriminant");
                                                                let e50 = {
                                                                    let l46 = *base.add(8).cast::<*mut u8>();
                                                                    let l47 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len48 = l47;
                                                                    let bytes48 = _rt::Vec::from_raw_parts(
                                                                        l46.cast(),
                                                                        len48,
                                                                        len48,
                                                                    );
                                                                    let l49 = *base
                                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i64>();
                                                                    (
                                                                        Uri {
                                                                            value: _rt::string_lift(bytes48),
                                                                        },
                                                                        l49 as u64,
                                                                    )
                                                                };
                                                                WitNode::Handle(e50)
                                                            }
                                                        };
                                                        v50
                                                    };
                                                    result51.push(e51);
                                                }
                                                _rt::cabi_dealloc(
                                                    base51,
                                                    len51 * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                                    8,
                                                );
                                                WitValue { nodes: result51 }
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l52 = i32::from(
                                                    *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                let v65 = match l52 {
                                                    0 => {
                                                        let e65 = {
                                                            let l53 = *ptr0
                                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l54 = *ptr0
                                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len55 = l54;
                                                            let bytes55 = _rt::Vec::from_raw_parts(
                                                                l53.cast(),
                                                                len55,
                                                                len55,
                                                            );
                                                            _rt::string_lift(bytes55)
                                                        };
                                                        RpcError::ProtocolError(e65)
                                                    }
                                                    1 => {
                                                        let e65 = {
                                                            let l56 = *ptr0
                                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l57 = *ptr0
                                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len58 = l57;
                                                            let bytes58 = _rt::Vec::from_raw_parts(
                                                                l56.cast(),
                                                                len58,
                                                                len58,
                                                            );
                                                            _rt::string_lift(bytes58)
                                                        };
                                                        RpcError::Denied(e65)
                                                    }
                                                    2 => {
                                                        let e65 = {
                                                            let l59 = *ptr0
                                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l60 = *ptr0
                                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len61 = l60;
                                                            let bytes61 = _rt::Vec::from_raw_parts(
                                                                l59.cast(),
                                                                len61,
                                                                len61,
                                                            );
                                                            _rt::string_lift(bytes61)
                                                        };
                                                        RpcError::NotFound(e65)
                                                    }
                                                    n => {
                                                        debug_assert_eq!(n, 3, "invalid enum discriminant");
                                                        let e65 = {
                                                            let l62 = *ptr0
                                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l63 = *ptr0
                                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len64 = l63;
                                                            let bytes64 = _rt::Vec::from_raw_parts(
                                                                l62.cast(),
                                                                len64,
                                                                len64,
                                                            );
                                                            _rt::string_lift(bytes64)
                                                        };
                                                        RpcError::RemoteInternalError(e65)
                                                    }
                                                };
                                                v65
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result66
                    }
                }
            }
            impl CancellationToken {
                #[allow(unused_unsafe, clippy::all)]
                pub fn cancel(&self) -> () {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                        unsafe extern "C" {
                            #[link_name = "[method]cancellation-token.cancel"]
                            fn wit_import0(_: i32);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) {
                            unreachable!()
                        }
                        unsafe { wit_import0((self).handle() as i32) };
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn extract_value(vnt: &ValueAndType) -> WitValue {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ValueAndType { value: value0, typ: typ0 } = vnt;
                    let WitValue { nodes: nodes1 } = value0;
                    let vec11 = nodes1;
                    let len11 = vec11.len();
                    let layout11 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec11.len() * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result11 = if layout11.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout11);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec11.into_iter().enumerate() {
                        let base = result11
                            .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                        {
                            match e {
                                WitNode::RecordValue(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let vec2 = e;
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *base.add(8).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                WitNode::VariantValue(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let (t3_0, t3_1) = e;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(t3_0);
                                    match t3_1 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                WitNode::EnumValue(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitNode::FlagsValue(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let vec4 = e;
                                    let len4 = vec4.len();
                                    let layout4 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec4.len() * 1,
                                        1,
                                    );
                                    let result4 = if layout4.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout4);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec4.into_iter().enumerate() {
                                        let base = result4.add(i * 1);
                                        {
                                            *base.add(0).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *base.add(8).cast::<*mut u8>() = result4;
                                    cleanup_list.extend_from_slice(&[(result4, layout4)]);
                                }
                                WitNode::TupleValue(e) => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                    let vec5 = e;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                WitNode::ListValue(e) => {
                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                    let vec6 = e;
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *base.add(8).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                WitNode::OptionValue(e) => {
                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                    match e {
                                        Some(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                WitNode::ResultValue(e) => {
                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                    match e {
                                        Ok(e) => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                            match e {
                                                Some(e) => {
                                                    *base.add(12).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                        Err(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            match e {
                                                Some(e) => {
                                                    *base.add(12).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                    };
                                }
                                WitNode::PrimU8(e) => {
                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                    *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                }
                                WitNode::PrimU16(e) => {
                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                    *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                }
                                WitNode::PrimU32(e) => {
                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitNode::PrimU64(e) => {
                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                    *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                }
                                WitNode::PrimS8(e) => {
                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                    *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                }
                                WitNode::PrimS16(e) => {
                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                    *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                }
                                WitNode::PrimS32(e) => {
                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitNode::PrimS64(e) => {
                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                    *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                }
                                WitNode::PrimFloat32(e) => {
                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                    *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                }
                                WitNode::PrimFloat64(e) => {
                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                    *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                }
                                WitNode::PrimChar(e) => {
                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitNode::PrimBool(e) => {
                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                    *base.add(8).cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                                WitNode::PrimString(e) => {
                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                    let vec7 = e;
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                WitNode::Handle(e) => {
                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                    let (t8_0, t8_1) = e;
                                    let Uri { value: value9 } = t8_0;
                                    let vec10 = value9;
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *base.add(8).cast::<*mut u8>() = ptr10.cast_mut();
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(t8_1);
                                }
                            }
                        }
                    }
                    let WitType { nodes: nodes12 } = typ0;
                    let vec26 = nodes12;
                    let len26 = vec26.len();
                    let layout26 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec26.len() * 24,
                        8,
                    );
                    let result26 = if layout26.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout26).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout26);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec26.into_iter().enumerate() {
                        let base = result26.add(i * 24);
                        {
                            match e {
                                WitTypeNode::RecordType(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let vec15 = e;
                                    let len15 = vec15.len();
                                    let layout15 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec15.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result15 = if layout15.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout15).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout15);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec15.into_iter().enumerate() {
                                        let base = result15
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let (t13_0, t13_1) = e;
                                            let vec14 = t13_0;
                                            let ptr14 = vec14.as_ptr().cast::<u8>();
                                            let len14 = vec14.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len14;
                                            *base.add(0).cast::<*mut u8>() = ptr14.cast_mut();
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i32>() = _rt::as_i32(t13_1);
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *base.add(8).cast::<*mut u8>() = result15;
                                    cleanup_list.extend_from_slice(&[(result15, layout15)]);
                                }
                                WitTypeNode::VariantType(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let vec18 = e;
                                    let len18 = vec18.len();
                                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec18.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result18 = if layout18.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout18);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec18.into_iter().enumerate() {
                                        let base = result18
                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let (t16_0, t16_1) = e;
                                            let vec17 = t16_0;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len17;
                                            *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
                                            match t16_1 {
                                                Some(e) => {
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *base
                                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *base.add(8).cast::<*mut u8>() = result18;
                                    cleanup_list.extend_from_slice(&[(result18, layout18)]);
                                }
                                WitTypeNode::EnumType(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let vec20 = e;
                                    let len20 = vec20.len();
                                    let layout20 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec20.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result20 = if layout20.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout20).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout20);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec20.into_iter().enumerate() {
                                        let base = result20
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec19 = e;
                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                            let len19 = vec19.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len19;
                                            *base.add(0).cast::<*mut u8>() = ptr19.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *base.add(8).cast::<*mut u8>() = result20;
                                    cleanup_list.extend_from_slice(&[(result20, layout20)]);
                                }
                                WitTypeNode::FlagsType(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let vec22 = e;
                                    let len22 = vec22.len();
                                    let layout22 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec22.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result22 = if layout22.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout22);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec22.into_iter().enumerate() {
                                        let base = result22
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec21 = e;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len21;
                                            *base.add(0).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *base.add(8).cast::<*mut u8>() = result22;
                                    cleanup_list.extend_from_slice(&[(result22, layout22)]);
                                }
                                WitTypeNode::TupleType(e) => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                    let vec23 = e;
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len23;
                                    *base.add(8).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                WitTypeNode::ListType(e) => {
                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitTypeNode::OptionType(e) => {
                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitTypeNode::ResultType(e) => {
                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                    let (t24_0, t24_1) = e;
                                    match t24_0 {
                                        Some(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match t24_1 {
                                        Some(e) => {
                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                WitTypeNode::PrimU8Type => {
                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                }
                                WitTypeNode::PrimU16Type => {
                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                }
                                WitTypeNode::PrimU32Type => {
                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                }
                                WitTypeNode::PrimU64Type => {
                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                }
                                WitTypeNode::PrimS8Type => {
                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                }
                                WitTypeNode::PrimS16Type => {
                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                }
                                WitTypeNode::PrimS32Type => {
                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                }
                                WitTypeNode::PrimS64Type => {
                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                }
                                WitTypeNode::PrimF32Type => {
                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                }
                                WitTypeNode::PrimF64Type => {
                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                }
                                WitTypeNode::PrimCharType => {
                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                }
                                WitTypeNode::PrimBoolType => {
                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                }
                                WitTypeNode::PrimStringType => {
                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                }
                                WitTypeNode::HandleType(e) => {
                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                    let (t25_0, t25_1) = e;
                                    *base.add(8).cast::<i64>() = _rt::as_i64(t25_0);
                                    *base.add(16).cast::<u8>() = (t25_1.clone() as i32) as u8;
                                }
                            }
                        }
                    }
                    let ptr27 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                    unsafe extern "C" {
                        #[link_name = "extract-value"]
                        fn wit_import28(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import28(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe { wit_import28(result11, len11, result26, len26, ptr27) };
                    let l29 = *ptr27.add(0).cast::<*mut u8>();
                    let l30 = *ptr27
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base76 = l29;
                    let len76 = l30;
                    let mut result76 = _rt::Vec::with_capacity(len76);
                    for i in 0..len76 {
                        let base = base76
                            .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                        let e76 = {
                            let l31 = i32::from(*base.add(0).cast::<u8>());
                            let v75 = match l31 {
                                0 => {
                                    let e75 = {
                                        let l32 = *base.add(8).cast::<*mut u8>();
                                        let l33 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len34 = l33;
                                        _rt::Vec::from_raw_parts(l32.cast(), len34, len34)
                                    };
                                    WitNode::RecordValue(e75)
                                }
                                1 => {
                                    let e75 = {
                                        let l35 = *base.add(8).cast::<i32>();
                                        let l36 = i32::from(*base.add(12).cast::<u8>());
                                        (
                                            l35 as u32,
                                            match l36 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l37 = *base.add(16).cast::<i32>();
                                                        l37
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        )
                                    };
                                    WitNode::VariantValue(e75)
                                }
                                2 => {
                                    let e75 = {
                                        let l38 = *base.add(8).cast::<i32>();
                                        l38 as u32
                                    };
                                    WitNode::EnumValue(e75)
                                }
                                3 => {
                                    let e75 = {
                                        let l39 = *base.add(8).cast::<*mut u8>();
                                        let l40 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base42 = l39;
                                        let len42 = l40;
                                        let mut result42 = _rt::Vec::with_capacity(len42);
                                        for i in 0..len42 {
                                            let base = base42.add(i * 1);
                                            let e42 = {
                                                let l41 = i32::from(*base.add(0).cast::<u8>());
                                                _rt::bool_lift(l41 as u8)
                                            };
                                            result42.push(e42);
                                        }
                                        _rt::cabi_dealloc(base42, len42 * 1, 1);
                                        result42
                                    };
                                    WitNode::FlagsValue(e75)
                                }
                                4 => {
                                    let e75 = {
                                        let l43 = *base.add(8).cast::<*mut u8>();
                                        let l44 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len45 = l44;
                                        _rt::Vec::from_raw_parts(l43.cast(), len45, len45)
                                    };
                                    WitNode::TupleValue(e75)
                                }
                                5 => {
                                    let e75 = {
                                        let l46 = *base.add(8).cast::<*mut u8>();
                                        let l47 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len48 = l47;
                                        _rt::Vec::from_raw_parts(l46.cast(), len48, len48)
                                    };
                                    WitNode::ListValue(e75)
                                }
                                6 => {
                                    let e75 = {
                                        let l49 = i32::from(*base.add(8).cast::<u8>());
                                        match l49 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l50 = *base.add(12).cast::<i32>();
                                                    l50
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        }
                                    };
                                    WitNode::OptionValue(e75)
                                }
                                7 => {
                                    let e75 = {
                                        let l51 = i32::from(*base.add(8).cast::<u8>());
                                        match l51 {
                                            0 => {
                                                let e = {
                                                    let l52 = i32::from(*base.add(12).cast::<u8>());
                                                    match l52 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l53 = *base.add(16).cast::<i32>();
                                                                l53
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    }
                                                };
                                                Ok(e)
                                            }
                                            1 => {
                                                let e = {
                                                    let l54 = i32::from(*base.add(12).cast::<u8>());
                                                    match l54 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l55 = *base.add(16).cast::<i32>();
                                                                l55
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    }
                                                };
                                                Err(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        }
                                    };
                                    WitNode::ResultValue(e75)
                                }
                                8 => {
                                    let e75 = {
                                        let l56 = i32::from(*base.add(8).cast::<u8>());
                                        l56 as u8
                                    };
                                    WitNode::PrimU8(e75)
                                }
                                9 => {
                                    let e75 = {
                                        let l57 = i32::from(*base.add(8).cast::<u16>());
                                        l57 as u16
                                    };
                                    WitNode::PrimU16(e75)
                                }
                                10 => {
                                    let e75 = {
                                        let l58 = *base.add(8).cast::<i32>();
                                        l58 as u32
                                    };
                                    WitNode::PrimU32(e75)
                                }
                                11 => {
                                    let e75 = {
                                        let l59 = *base.add(8).cast::<i64>();
                                        l59 as u64
                                    };
                                    WitNode::PrimU64(e75)
                                }
                                12 => {
                                    let e75 = {
                                        let l60 = i32::from(*base.add(8).cast::<i8>());
                                        l60 as i8
                                    };
                                    WitNode::PrimS8(e75)
                                }
                                13 => {
                                    let e75 = {
                                        let l61 = i32::from(*base.add(8).cast::<i16>());
                                        l61 as i16
                                    };
                                    WitNode::PrimS16(e75)
                                }
                                14 => {
                                    let e75 = {
                                        let l62 = *base.add(8).cast::<i32>();
                                        l62
                                    };
                                    WitNode::PrimS32(e75)
                                }
                                15 => {
                                    let e75 = {
                                        let l63 = *base.add(8).cast::<i64>();
                                        l63
                                    };
                                    WitNode::PrimS64(e75)
                                }
                                16 => {
                                    let e75 = {
                                        let l64 = *base.add(8).cast::<f32>();
                                        l64
                                    };
                                    WitNode::PrimFloat32(e75)
                                }
                                17 => {
                                    let e75 = {
                                        let l65 = *base.add(8).cast::<f64>();
                                        l65
                                    };
                                    WitNode::PrimFloat64(e75)
                                }
                                18 => {
                                    let e75 = {
                                        let l66 = *base.add(8).cast::<i32>();
                                        _rt::char_lift(l66 as u32)
                                    };
                                    WitNode::PrimChar(e75)
                                }
                                19 => {
                                    let e75 = {
                                        let l67 = i32::from(*base.add(8).cast::<u8>());
                                        _rt::bool_lift(l67 as u8)
                                    };
                                    WitNode::PrimBool(e75)
                                }
                                20 => {
                                    let e75 = {
                                        let l68 = *base.add(8).cast::<*mut u8>();
                                        let l69 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len70 = l69;
                                        let bytes70 = _rt::Vec::from_raw_parts(
                                            l68.cast(),
                                            len70,
                                            len70,
                                        );
                                        _rt::string_lift(bytes70)
                                    };
                                    WitNode::PrimString(e75)
                                }
                                n => {
                                    debug_assert_eq!(n, 21, "invalid enum discriminant");
                                    let e75 = {
                                        let l71 = *base.add(8).cast::<*mut u8>();
                                        let l72 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len73 = l72;
                                        let bytes73 = _rt::Vec::from_raw_parts(
                                            l71.cast(),
                                            len73,
                                            len73,
                                        );
                                        let l74 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        (
                                            Uri {
                                                value: _rt::string_lift(bytes73),
                                            },
                                            l74 as u64,
                                        )
                                    };
                                    WitNode::Handle(e75)
                                }
                            };
                            v75
                        };
                        result76.push(e76);
                    }
                    _rt::cabi_dealloc(
                        base76,
                        len76 * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result77 = WitValue { nodes: result76 };
                    if layout11.size() != 0 {
                        _rt::alloc::dealloc(result11.cast(), layout11);
                    }
                    if layout26.size() != 0 {
                        _rt::alloc::dealloc(result26.cast(), layout26);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                    result77
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn extract_type(vnt: &ValueAndType) -> WitType {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ValueAndType { value: value0, typ: typ0 } = vnt;
                    let WitValue { nodes: nodes1 } = value0;
                    let vec11 = nodes1;
                    let len11 = vec11.len();
                    let layout11 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec11.len() * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result11 = if layout11.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout11);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec11.into_iter().enumerate() {
                        let base = result11
                            .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                        {
                            match e {
                                WitNode::RecordValue(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let vec2 = e;
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *base.add(8).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                WitNode::VariantValue(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let (t3_0, t3_1) = e;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(t3_0);
                                    match t3_1 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                WitNode::EnumValue(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitNode::FlagsValue(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let vec4 = e;
                                    let len4 = vec4.len();
                                    let layout4 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec4.len() * 1,
                                        1,
                                    );
                                    let result4 = if layout4.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout4);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec4.into_iter().enumerate() {
                                        let base = result4.add(i * 1);
                                        {
                                            *base.add(0).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *base.add(8).cast::<*mut u8>() = result4;
                                    cleanup_list.extend_from_slice(&[(result4, layout4)]);
                                }
                                WitNode::TupleValue(e) => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                    let vec5 = e;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                WitNode::ListValue(e) => {
                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                    let vec6 = e;
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *base.add(8).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                WitNode::OptionValue(e) => {
                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                    match e {
                                        Some(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                WitNode::ResultValue(e) => {
                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                    match e {
                                        Ok(e) => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                            match e {
                                                Some(e) => {
                                                    *base.add(12).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                        Err(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            match e {
                                                Some(e) => {
                                                    *base.add(12).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                    };
                                }
                                WitNode::PrimU8(e) => {
                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                    *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                }
                                WitNode::PrimU16(e) => {
                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                    *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                }
                                WitNode::PrimU32(e) => {
                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitNode::PrimU64(e) => {
                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                    *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                }
                                WitNode::PrimS8(e) => {
                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                    *base.add(8).cast::<u8>() = (_rt::as_i32(e)) as u8;
                                }
                                WitNode::PrimS16(e) => {
                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                    *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                }
                                WitNode::PrimS32(e) => {
                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitNode::PrimS64(e) => {
                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                    *base.add(8).cast::<i64>() = _rt::as_i64(e);
                                }
                                WitNode::PrimFloat32(e) => {
                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                    *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                }
                                WitNode::PrimFloat64(e) => {
                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                    *base.add(8).cast::<f64>() = _rt::as_f64(e);
                                }
                                WitNode::PrimChar(e) => {
                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitNode::PrimBool(e) => {
                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                    *base.add(8).cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                                WitNode::PrimString(e) => {
                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                    let vec7 = e;
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                WitNode::Handle(e) => {
                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                    let (t8_0, t8_1) = e;
                                    let Uri { value: value9 } = t8_0;
                                    let vec10 = value9;
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *base.add(8).cast::<*mut u8>() = ptr10.cast_mut();
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(t8_1);
                                }
                            }
                        }
                    }
                    let WitType { nodes: nodes12 } = typ0;
                    let vec26 = nodes12;
                    let len26 = vec26.len();
                    let layout26 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec26.len() * 24,
                        8,
                    );
                    let result26 = if layout26.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout26).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout26);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec26.into_iter().enumerate() {
                        let base = result26.add(i * 24);
                        {
                            match e {
                                WitTypeNode::RecordType(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let vec15 = e;
                                    let len15 = vec15.len();
                                    let layout15 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec15.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result15 = if layout15.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout15).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout15);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec15.into_iter().enumerate() {
                                        let base = result15
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let (t13_0, t13_1) = e;
                                            let vec14 = t13_0;
                                            let ptr14 = vec14.as_ptr().cast::<u8>();
                                            let len14 = vec14.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len14;
                                            *base.add(0).cast::<*mut u8>() = ptr14.cast_mut();
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i32>() = _rt::as_i32(t13_1);
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *base.add(8).cast::<*mut u8>() = result15;
                                    cleanup_list.extend_from_slice(&[(result15, layout15)]);
                                }
                                WitTypeNode::VariantType(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let vec18 = e;
                                    let len18 = vec18.len();
                                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec18.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result18 = if layout18.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout18);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec18.into_iter().enumerate() {
                                        let base = result18
                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let (t16_0, t16_1) = e;
                                            let vec17 = t16_0;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len17;
                                            *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
                                            match t16_1 {
                                                Some(e) => {
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *base
                                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *base.add(8).cast::<*mut u8>() = result18;
                                    cleanup_list.extend_from_slice(&[(result18, layout18)]);
                                }
                                WitTypeNode::EnumType(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let vec20 = e;
                                    let len20 = vec20.len();
                                    let layout20 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec20.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result20 = if layout20.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout20).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout20);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec20.into_iter().enumerate() {
                                        let base = result20
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec19 = e;
                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                            let len19 = vec19.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len19;
                                            *base.add(0).cast::<*mut u8>() = ptr19.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *base.add(8).cast::<*mut u8>() = result20;
                                    cleanup_list.extend_from_slice(&[(result20, layout20)]);
                                }
                                WitTypeNode::FlagsType(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let vec22 = e;
                                    let len22 = vec22.len();
                                    let layout22 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec22.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result22 = if layout22.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout22);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec22.into_iter().enumerate() {
                                        let base = result22
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec21 = e;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len21;
                                            *base.add(0).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *base.add(8).cast::<*mut u8>() = result22;
                                    cleanup_list.extend_from_slice(&[(result22, layout22)]);
                                }
                                WitTypeNode::TupleType(e) => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                    let vec23 = e;
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len23;
                                    *base.add(8).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                WitTypeNode::ListType(e) => {
                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitTypeNode::OptionType(e) => {
                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                WitTypeNode::ResultType(e) => {
                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                    let (t24_0, t24_1) = e;
                                    match t24_0 {
                                        Some(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match t24_1 {
                                        Some(e) => {
                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                WitTypeNode::PrimU8Type => {
                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                }
                                WitTypeNode::PrimU16Type => {
                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                }
                                WitTypeNode::PrimU32Type => {
                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                }
                                WitTypeNode::PrimU64Type => {
                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                }
                                WitTypeNode::PrimS8Type => {
                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                }
                                WitTypeNode::PrimS16Type => {
                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                }
                                WitTypeNode::PrimS32Type => {
                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                }
                                WitTypeNode::PrimS64Type => {
                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                }
                                WitTypeNode::PrimF32Type => {
                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                }
                                WitTypeNode::PrimF64Type => {
                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                }
                                WitTypeNode::PrimCharType => {
                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                }
                                WitTypeNode::PrimBoolType => {
                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                }
                                WitTypeNode::PrimStringType => {
                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                }
                                WitTypeNode::HandleType(e) => {
                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                    let (t25_0, t25_1) = e;
                                    *base.add(8).cast::<i64>() = _rt::as_i64(t25_0);
                                    *base.add(16).cast::<u8>() = (t25_1.clone() as i32) as u8;
                                }
                            }
                        }
                    }
                    let ptr27 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:rpc/types@0.2.1")]
                    unsafe extern "C" {
                        #[link_name = "extract-type"]
                        fn wit_import28(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import28(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe { wit_import28(result11, len11, result26, len26, ptr27) };
                    let l29 = *ptr27.add(0).cast::<*mut u8>();
                    let l30 = *ptr27
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base71 = l29;
                    let len71 = l30;
                    let mut result71 = _rt::Vec::with_capacity(len71);
                    for i in 0..len71 {
                        let base = base71.add(i * 24);
                        let e71 = {
                            let l31 = i32::from(*base.add(0).cast::<u8>());
                            let v70 = match l31 {
                                0 => {
                                    let e70 = {
                                        let l32 = *base.add(8).cast::<*mut u8>();
                                        let l33 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base38 = l32;
                                        let len38 = l33;
                                        let mut result38 = _rt::Vec::with_capacity(len38);
                                        for i in 0..len38 {
                                            let base = base38
                                                .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                            let e38 = {
                                                let l34 = *base.add(0).cast::<*mut u8>();
                                                let l35 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len36 = l35;
                                                let bytes36 = _rt::Vec::from_raw_parts(
                                                    l34.cast(),
                                                    len36,
                                                    len36,
                                                );
                                                let l37 = *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                (_rt::string_lift(bytes36), l37)
                                            };
                                            result38.push(e38);
                                        }
                                        _rt::cabi_dealloc(
                                            base38,
                                            len38 * (3 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result38
                                    };
                                    WitTypeNode::RecordType(e70)
                                }
                                1 => {
                                    let e70 = {
                                        let l39 = *base.add(8).cast::<*mut u8>();
                                        let l40 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base46 = l39;
                                        let len46 = l40;
                                        let mut result46 = _rt::Vec::with_capacity(len46);
                                        for i in 0..len46 {
                                            let base = base46
                                                .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                            let e46 = {
                                                let l41 = *base.add(0).cast::<*mut u8>();
                                                let l42 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len43 = l42;
                                                let bytes43 = _rt::Vec::from_raw_parts(
                                                    l41.cast(),
                                                    len43,
                                                    len43,
                                                );
                                                let l44 = i32::from(
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                (
                                                    _rt::string_lift(bytes43),
                                                    match l44 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l45 = *base
                                                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>();
                                                                l45
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                )
                                            };
                                            result46.push(e46);
                                        }
                                        _rt::cabi_dealloc(
                                            base46,
                                            len46 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result46
                                    };
                                    WitTypeNode::VariantType(e70)
                                }
                                2 => {
                                    let e70 = {
                                        let l47 = *base.add(8).cast::<*mut u8>();
                                        let l48 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base52 = l47;
                                        let len52 = l48;
                                        let mut result52 = _rt::Vec::with_capacity(len52);
                                        for i in 0..len52 {
                                            let base = base52
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e52 = {
                                                let l49 = *base.add(0).cast::<*mut u8>();
                                                let l50 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len51 = l50;
                                                let bytes51 = _rt::Vec::from_raw_parts(
                                                    l49.cast(),
                                                    len51,
                                                    len51,
                                                );
                                                _rt::string_lift(bytes51)
                                            };
                                            result52.push(e52);
                                        }
                                        _rt::cabi_dealloc(
                                            base52,
                                            len52 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result52
                                    };
                                    WitTypeNode::EnumType(e70)
                                }
                                3 => {
                                    let e70 = {
                                        let l53 = *base.add(8).cast::<*mut u8>();
                                        let l54 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base58 = l53;
                                        let len58 = l54;
                                        let mut result58 = _rt::Vec::with_capacity(len58);
                                        for i in 0..len58 {
                                            let base = base58
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e58 = {
                                                let l55 = *base.add(0).cast::<*mut u8>();
                                                let l56 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len57 = l56;
                                                let bytes57 = _rt::Vec::from_raw_parts(
                                                    l55.cast(),
                                                    len57,
                                                    len57,
                                                );
                                                _rt::string_lift(bytes57)
                                            };
                                            result58.push(e58);
                                        }
                                        _rt::cabi_dealloc(
                                            base58,
                                            len58 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result58
                                    };
                                    WitTypeNode::FlagsType(e70)
                                }
                                4 => {
                                    let e70 = {
                                        let l59 = *base.add(8).cast::<*mut u8>();
                                        let l60 = *base
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len61 = l60;
                                        _rt::Vec::from_raw_parts(l59.cast(), len61, len61)
                                    };
                                    WitTypeNode::TupleType(e70)
                                }
                                5 => {
                                    let e70 = {
                                        let l62 = *base.add(8).cast::<i32>();
                                        l62
                                    };
                                    WitTypeNode::ListType(e70)
                                }
                                6 => {
                                    let e70 = {
                                        let l63 = *base.add(8).cast::<i32>();
                                        l63
                                    };
                                    WitTypeNode::OptionType(e70)
                                }
                                7 => {
                                    let e70 = {
                                        let l64 = i32::from(*base.add(8).cast::<u8>());
                                        let l66 = i32::from(*base.add(16).cast::<u8>());
                                        (
                                            match l64 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l65 = *base.add(12).cast::<i32>();
                                                        l65
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                            match l66 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l67 = *base.add(20).cast::<i32>();
                                                        l67
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        )
                                    };
                                    WitTypeNode::ResultType(e70)
                                }
                                8 => WitTypeNode::PrimU8Type,
                                9 => WitTypeNode::PrimU16Type,
                                10 => WitTypeNode::PrimU32Type,
                                11 => WitTypeNode::PrimU64Type,
                                12 => WitTypeNode::PrimS8Type,
                                13 => WitTypeNode::PrimS16Type,
                                14 => WitTypeNode::PrimS32Type,
                                15 => WitTypeNode::PrimS64Type,
                                16 => WitTypeNode::PrimF32Type,
                                17 => WitTypeNode::PrimF64Type,
                                18 => WitTypeNode::PrimCharType,
                                19 => WitTypeNode::PrimBoolType,
                                20 => WitTypeNode::PrimStringType,
                                n => {
                                    debug_assert_eq!(n, 21, "invalid enum discriminant");
                                    let e70 = {
                                        let l68 = *base.add(8).cast::<i64>();
                                        let l69 = i32::from(*base.add(16).cast::<u8>());
                                        (l68 as u64, ResourceMode::_lift(l69 as u8))
                                    };
                                    WitTypeNode::HandleType(e70)
                                }
                            };
                            v70
                        };
                        result71.push(e71);
                    }
                    _rt::cabi_dealloc(base71, len71 * 24, 8);
                    let result72 = WitType { nodes: result71 };
                    if layout11.size() != 0 {
                        _rt::alloc::dealloc(result11.cast(), layout11);
                    }
                    if layout26.size() != 0 {
                        _rt::alloc::dealloc(result26.cast(), layout26);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                    result72
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod clocks {
        /// WASI Wall Clock is a clock API intended to let users query the current
        /// time. The name "wall" makes an analogy to a "clock on the wall", which
        /// is not necessarily monotonic as it may be reset.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        ///
        /// A wall clock is a clock which measures the date and time according to
        /// some external reference.
        ///
        /// External references may be reset, so this clock is not necessarily
        /// monotonic, making it unsuitable for measuring elapsed time.
        ///
        /// It is intended for reporting the current date and time for humans.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod wall_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// A time and date in seconds plus nanoseconds.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Datetime {
                pub seconds: u64,
                pub nanoseconds: u32,
            }
            impl ::core::fmt::Debug for Datetime {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Datetime")
                        .field("seconds", &self.seconds)
                        .field("nanoseconds", &self.nanoseconds)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// This clock is not monotonic, therefore calling this function repeatedly
            /// will not necessarily produce a sequence of non-decreasing values.
            ///
            /// The returned timestamps represent the number of seconds since
            /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
            /// also known as [Unix Time].
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            ///
            /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
            /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
            pub fn now() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.3")]
                    unsafe extern "C" {
                        #[link_name = "now"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock.
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            pub fn resolution() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.3")]
                    unsafe extern "C" {
                        #[link_name = "resolution"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
        }
        /// WASI Monotonic Clock is a clock API intended to let users measure elapsed
        /// time.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        ///
        /// A monotonic clock is a clock which has an unspecified initial value, and
        /// successive reads of the clock will produce non-decreasing values.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod monotonic_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            /// An instant in time, in nanoseconds. An instant is relative to an
            /// unspecified initial value, and can only be compared to instances from
            /// the same monotonic-clock.
            pub type Instant = u64;
            /// A duration of time, in nanoseconds.
            pub type Duration = u64;
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// The clock is monotonic, therefore calling this function repeatedly will
            /// produce a sequence of non-decreasing values.
            pub fn now() -> Instant {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.3")]
                    unsafe extern "C" {
                        #[link_name = "now"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock. Returns the duration of time
            /// corresponding to a clock tick.
            pub fn resolution() -> Duration {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.3")]
                    unsafe extern "C" {
                        #[link_name = "resolution"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Create a `pollable` which will resolve once the specified instant
            /// has occurred.
            pub fn subscribe_instant(when: Instant) -> Pollable {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.3")]
                    unsafe extern "C" {
                        #[link_name = "subscribe-instant"]
                        fn wit_import0(_: i64) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0(_rt::as_i64(when)) };
                    unsafe {
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Create a `pollable` that will resolve after the specified duration has
            /// elapsed from the time this function is invoked.
            pub fn subscribe_duration(when: Duration) -> Pollable {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.3")]
                    unsafe extern "C" {
                        #[link_name = "subscribe-duration"]
                        fn wit_import0(_: i64) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0(_rt::as_i64(when)) };
                    unsafe {
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
        }
    }
    pub mod io {
        /// A poll API intended to let users wait for I/O events on multiple handles
        /// at once.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod poll {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// `pollable` represents a single I/O event which may be ready, or not.
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Pollable {
                handle: _rt::Resource<Pollable>,
            }
            impl Pollable {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Pollable {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:io/poll@0.2.3")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]pollable"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl Pollable {
                #[allow(unused_unsafe, clippy::all)]
                /// Return the readiness of a pollable. This function never blocks.
                ///
                /// Returns `true` when the pollable is ready, and `false` otherwise.
                pub fn ready(&self) -> bool {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/poll@0.2.3")]
                        unsafe extern "C" {
                            #[link_name = "[method]pollable.ready"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl Pollable {
                #[allow(unused_unsafe, clippy::all)]
                /// `block` returns immediately if the pollable is ready, and otherwise
                /// blocks until ready.
                ///
                /// This function is equivalent to calling `poll.poll` on a list
                /// containing only this pollable.
                pub fn block(&self) -> () {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/poll@0.2.3")]
                        unsafe extern "C" {
                            #[link_name = "[method]pollable.block"]
                            fn wit_import0(_: i32);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) {
                            unreachable!()
                        }
                        unsafe { wit_import0((self).handle() as i32) };
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Poll for completion on a set of pollables.
            ///
            /// This function takes a list of pollables, which identify I/O sources of
            /// interest, and waits until one or more of the events is ready for I/O.
            ///
            /// The result `list<u32>` contains one or more indices of handles in the
            /// argument list that is ready for I/O.
            ///
            /// This function traps if either:
            /// - the list is empty, or:
            /// - the list contains more elements than can be indexed with a `u32` value.
            ///
            /// A timeout can be implemented by adding a pollable from the
            /// wasi-clocks API to the list.
            ///
            /// This function does not return a `result`; polling in itself does not
            /// do any I/O so it doesn't fail. If any of the I/O sources identified by
            /// the pollables has an error, it is indicated by marking the source as
            /// being ready for I/O.
            pub fn poll(in_: &[&Pollable]) -> _rt::Vec<u32> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = in_;
                    let len0 = vec0.len();
                    let layout0 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec0.len() * 4,
                        4,
                    );
                    let result0 = if layout0.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout0).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout0);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec0.into_iter().enumerate() {
                        let base = result0.add(i * 4);
                        {
                            *base.add(0).cast::<i32>() = (e).handle() as i32;
                        }
                    }
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:io/poll@0.2.3")]
                    unsafe extern "C" {
                        #[link_name = "poll"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(result0, len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let result6 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    if layout0.size() != 0 {
                        _rt::alloc::dealloc(result0.cast(), layout0);
                    }
                    result6
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod golem {
        pub mod agent {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod guest {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type StatusUpdate = super::super::super::super::golem::agent::common::StatusUpdate;
                pub type AgentType = super::super::super::super::golem::agent::common::AgentType;
                pub type WitValue = super::super::super::super::golem::rpc::types::WitValue;
                /// This is not quite right, we really need a host function that keeps track
                /// of the resources constructed explicitly within the component using a host
                /// function and will be done during the time of implementation
                #[derive(Clone)]
                pub struct AgentRef {
                    pub agent_id: _rt::String,
                    pub agent_name: _rt::String,
                    pub agent_handle: u32,
                }
                impl ::core::fmt::Debug for AgentRef {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AgentRef")
                            .field("agent-id", &self.agent_id)
                            .field("agent-name", &self.agent_name)
                            .field("agent-handle", &self.agent_handle)
                            .finish()
                    }
                }
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Agent {
                    handle: _rt::Resource<Agent>,
                }
                type _AgentRep<T> = Option<T>;
                impl Agent {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Agent`.
                    pub fn new<T: GuestAgent>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _AgentRep<T> = Some(val);
                        let ptr: *mut _AgentRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestAgent>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestAgent>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestAgent>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(handle as *mut _AgentRep<T>)
                        };
                    }
                    fn as_ptr<T: GuestAgent>(&self) -> *mut _AgentRep<T> {
                        Agent::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`Agent`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct AgentBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Agent>,
                }
                impl<'a> AgentBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestAgent>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _AgentRep<T> {
                        Agent::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for Agent {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(wasm_import_module = "[export]golem:agent/guest")]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]agent"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_constructor_agent_cabi<T: GuestAgent>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let base49 = arg2;
                    let len49 = arg3;
                    let mut result49 = _rt::Vec::with_capacity(len49);
                    for i in 0..len49 {
                        let base = base49
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e49 = {
                            let l1 = *base.add(0).cast::<*mut u8>();
                            let l2 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base48 = l1;
                            let len48 = l2;
                            let mut result48 = _rt::Vec::with_capacity(len48);
                            for i in 0..len48 {
                                let base = base48
                                    .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                let e48 = {
                                    let l3 = i32::from(*base.add(0).cast::<u8>());
                                    use super::super::super::super::golem::rpc::types::WitNode as V47;
                                    let v47 = match l3 {
                                        0 => {
                                            let e47 = {
                                                let l4 = *base.add(8).cast::<*mut u8>();
                                                let l5 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len6 = l5;
                                                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
                                            };
                                            V47::RecordValue(e47)
                                        }
                                        1 => {
                                            let e47 = {
                                                let l7 = *base.add(8).cast::<i32>();
                                                let l8 = i32::from(*base.add(12).cast::<u8>());
                                                (
                                                    l7 as u32,
                                                    match l8 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l9 = *base.add(16).cast::<i32>();
                                                                l9
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                )
                                            };
                                            V47::VariantValue(e47)
                                        }
                                        2 => {
                                            let e47 = {
                                                let l10 = *base.add(8).cast::<i32>();
                                                l10 as u32
                                            };
                                            V47::EnumValue(e47)
                                        }
                                        3 => {
                                            let e47 = {
                                                let l11 = *base.add(8).cast::<*mut u8>();
                                                let l12 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base14 = l11;
                                                let len14 = l12;
                                                let mut result14 = _rt::Vec::with_capacity(len14);
                                                for i in 0..len14 {
                                                    let base = base14.add(i * 1);
                                                    let e14 = {
                                                        let l13 = i32::from(*base.add(0).cast::<u8>());
                                                        _rt::bool_lift(l13 as u8)
                                                    };
                                                    result14.push(e14);
                                                }
                                                _rt::cabi_dealloc(base14, len14 * 1, 1);
                                                result14
                                            };
                                            V47::FlagsValue(e47)
                                        }
                                        4 => {
                                            let e47 = {
                                                let l15 = *base.add(8).cast::<*mut u8>();
                                                let l16 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len17 = l16;
                                                _rt::Vec::from_raw_parts(l15.cast(), len17, len17)
                                            };
                                            V47::TupleValue(e47)
                                        }
                                        5 => {
                                            let e47 = {
                                                let l18 = *base.add(8).cast::<*mut u8>();
                                                let l19 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len20 = l19;
                                                _rt::Vec::from_raw_parts(l18.cast(), len20, len20)
                                            };
                                            V47::ListValue(e47)
                                        }
                                        6 => {
                                            let e47 = {
                                                let l21 = i32::from(*base.add(8).cast::<u8>());
                                                match l21 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l22 = *base.add(12).cast::<i32>();
                                                            l22
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            V47::OptionValue(e47)
                                        }
                                        7 => {
                                            let e47 = {
                                                let l23 = i32::from(*base.add(8).cast::<u8>());
                                                match l23 {
                                                    0 => {
                                                        let e = {
                                                            let l24 = i32::from(*base.add(12).cast::<u8>());
                                                            match l24 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l25 = *base.add(16).cast::<i32>();
                                                                        l25
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            }
                                                        };
                                                        Ok(e)
                                                    }
                                                    1 => {
                                                        let e = {
                                                            let l26 = i32::from(*base.add(12).cast::<u8>());
                                                            match l26 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l27 = *base.add(16).cast::<i32>();
                                                                        l27
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            }
                                                        };
                                                        Err(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            V47::ResultValue(e47)
                                        }
                                        8 => {
                                            let e47 = {
                                                let l28 = i32::from(*base.add(8).cast::<u8>());
                                                l28 as u8
                                            };
                                            V47::PrimU8(e47)
                                        }
                                        9 => {
                                            let e47 = {
                                                let l29 = i32::from(*base.add(8).cast::<u16>());
                                                l29 as u16
                                            };
                                            V47::PrimU16(e47)
                                        }
                                        10 => {
                                            let e47 = {
                                                let l30 = *base.add(8).cast::<i32>();
                                                l30 as u32
                                            };
                                            V47::PrimU32(e47)
                                        }
                                        11 => {
                                            let e47 = {
                                                let l31 = *base.add(8).cast::<i64>();
                                                l31 as u64
                                            };
                                            V47::PrimU64(e47)
                                        }
                                        12 => {
                                            let e47 = {
                                                let l32 = i32::from(*base.add(8).cast::<i8>());
                                                l32 as i8
                                            };
                                            V47::PrimS8(e47)
                                        }
                                        13 => {
                                            let e47 = {
                                                let l33 = i32::from(*base.add(8).cast::<i16>());
                                                l33 as i16
                                            };
                                            V47::PrimS16(e47)
                                        }
                                        14 => {
                                            let e47 = {
                                                let l34 = *base.add(8).cast::<i32>();
                                                l34
                                            };
                                            V47::PrimS32(e47)
                                        }
                                        15 => {
                                            let e47 = {
                                                let l35 = *base.add(8).cast::<i64>();
                                                l35
                                            };
                                            V47::PrimS64(e47)
                                        }
                                        16 => {
                                            let e47 = {
                                                let l36 = *base.add(8).cast::<f32>();
                                                l36
                                            };
                                            V47::PrimFloat32(e47)
                                        }
                                        17 => {
                                            let e47 = {
                                                let l37 = *base.add(8).cast::<f64>();
                                                l37
                                            };
                                            V47::PrimFloat64(e47)
                                        }
                                        18 => {
                                            let e47 = {
                                                let l38 = *base.add(8).cast::<i32>();
                                                _rt::char_lift(l38 as u32)
                                            };
                                            V47::PrimChar(e47)
                                        }
                                        19 => {
                                            let e47 = {
                                                let l39 = i32::from(*base.add(8).cast::<u8>());
                                                _rt::bool_lift(l39 as u8)
                                            };
                                            V47::PrimBool(e47)
                                        }
                                        20 => {
                                            let e47 = {
                                                let l40 = *base.add(8).cast::<*mut u8>();
                                                let l41 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len42 = l41;
                                                let bytes42 = _rt::Vec::from_raw_parts(
                                                    l40.cast(),
                                                    len42,
                                                    len42,
                                                );
                                                _rt::string_lift(bytes42)
                                            };
                                            V47::PrimString(e47)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 21, "invalid enum discriminant");
                                            let e47 = {
                                                let l43 = *base.add(8).cast::<*mut u8>();
                                                let l44 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len45 = l44;
                                                let bytes45 = _rt::Vec::from_raw_parts(
                                                    l43.cast(),
                                                    len45,
                                                    len45,
                                                );
                                                let l46 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>();
                                                (
                                                    super::super::super::super::golem::rpc::types::Uri {
                                                        value: _rt::string_lift(bytes45),
                                                    },
                                                    l46 as u64,
                                                )
                                            };
                                            V47::Handle(e47)
                                        }
                                    };
                                    v47
                                };
                                result48.push(e48);
                            }
                            _rt::cabi_dealloc(
                                base48,
                                len48 * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            super::super::super::super::golem::rpc::types::WitValue {
                                nodes: result48,
                            }
                        };
                        result49.push(e49);
                    }
                    _rt::cabi_dealloc(
                        base49,
                        len49 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result50 = Agent::new(
                        T::new(_rt::string_lift(bytes0), result49),
                    );
                    (result50).take_handle() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_agent_get_id_cabi<T: GuestAgent>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_id(
                        unsafe { AgentBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_agent_get_id<T: GuestAgent>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_agent_invoke_cabi<T: GuestAgent>(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                    arg3: *mut u8,
                    arg4: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let base49 = arg3;
                    let len49 = arg4;
                    let mut result49 = _rt::Vec::with_capacity(len49);
                    for i in 0..len49 {
                        let base = base49
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e49 = {
                            let l1 = *base.add(0).cast::<*mut u8>();
                            let l2 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base48 = l1;
                            let len48 = l2;
                            let mut result48 = _rt::Vec::with_capacity(len48);
                            for i in 0..len48 {
                                let base = base48
                                    .add(i * (16 + 2 * ::core::mem::size_of::<*const u8>()));
                                let e48 = {
                                    let l3 = i32::from(*base.add(0).cast::<u8>());
                                    use super::super::super::super::golem::rpc::types::WitNode as V47;
                                    let v47 = match l3 {
                                        0 => {
                                            let e47 = {
                                                let l4 = *base.add(8).cast::<*mut u8>();
                                                let l5 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len6 = l5;
                                                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
                                            };
                                            V47::RecordValue(e47)
                                        }
                                        1 => {
                                            let e47 = {
                                                let l7 = *base.add(8).cast::<i32>();
                                                let l8 = i32::from(*base.add(12).cast::<u8>());
                                                (
                                                    l7 as u32,
                                                    match l8 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l9 = *base.add(16).cast::<i32>();
                                                                l9
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                )
                                            };
                                            V47::VariantValue(e47)
                                        }
                                        2 => {
                                            let e47 = {
                                                let l10 = *base.add(8).cast::<i32>();
                                                l10 as u32
                                            };
                                            V47::EnumValue(e47)
                                        }
                                        3 => {
                                            let e47 = {
                                                let l11 = *base.add(8).cast::<*mut u8>();
                                                let l12 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base14 = l11;
                                                let len14 = l12;
                                                let mut result14 = _rt::Vec::with_capacity(len14);
                                                for i in 0..len14 {
                                                    let base = base14.add(i * 1);
                                                    let e14 = {
                                                        let l13 = i32::from(*base.add(0).cast::<u8>());
                                                        _rt::bool_lift(l13 as u8)
                                                    };
                                                    result14.push(e14);
                                                }
                                                _rt::cabi_dealloc(base14, len14 * 1, 1);
                                                result14
                                            };
                                            V47::FlagsValue(e47)
                                        }
                                        4 => {
                                            let e47 = {
                                                let l15 = *base.add(8).cast::<*mut u8>();
                                                let l16 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len17 = l16;
                                                _rt::Vec::from_raw_parts(l15.cast(), len17, len17)
                                            };
                                            V47::TupleValue(e47)
                                        }
                                        5 => {
                                            let e47 = {
                                                let l18 = *base.add(8).cast::<*mut u8>();
                                                let l19 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len20 = l19;
                                                _rt::Vec::from_raw_parts(l18.cast(), len20, len20)
                                            };
                                            V47::ListValue(e47)
                                        }
                                        6 => {
                                            let e47 = {
                                                let l21 = i32::from(*base.add(8).cast::<u8>());
                                                match l21 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l22 = *base.add(12).cast::<i32>();
                                                            l22
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            V47::OptionValue(e47)
                                        }
                                        7 => {
                                            let e47 = {
                                                let l23 = i32::from(*base.add(8).cast::<u8>());
                                                match l23 {
                                                    0 => {
                                                        let e = {
                                                            let l24 = i32::from(*base.add(12).cast::<u8>());
                                                            match l24 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l25 = *base.add(16).cast::<i32>();
                                                                        l25
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            }
                                                        };
                                                        Ok(e)
                                                    }
                                                    1 => {
                                                        let e = {
                                                            let l26 = i32::from(*base.add(12).cast::<u8>());
                                                            match l26 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l27 = *base.add(16).cast::<i32>();
                                                                        l27
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            }
                                                        };
                                                        Err(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            V47::ResultValue(e47)
                                        }
                                        8 => {
                                            let e47 = {
                                                let l28 = i32::from(*base.add(8).cast::<u8>());
                                                l28 as u8
                                            };
                                            V47::PrimU8(e47)
                                        }
                                        9 => {
                                            let e47 = {
                                                let l29 = i32::from(*base.add(8).cast::<u16>());
                                                l29 as u16
                                            };
                                            V47::PrimU16(e47)
                                        }
                                        10 => {
                                            let e47 = {
                                                let l30 = *base.add(8).cast::<i32>();
                                                l30 as u32
                                            };
                                            V47::PrimU32(e47)
                                        }
                                        11 => {
                                            let e47 = {
                                                let l31 = *base.add(8).cast::<i64>();
                                                l31 as u64
                                            };
                                            V47::PrimU64(e47)
                                        }
                                        12 => {
                                            let e47 = {
                                                let l32 = i32::from(*base.add(8).cast::<i8>());
                                                l32 as i8
                                            };
                                            V47::PrimS8(e47)
                                        }
                                        13 => {
                                            let e47 = {
                                                let l33 = i32::from(*base.add(8).cast::<i16>());
                                                l33 as i16
                                            };
                                            V47::PrimS16(e47)
                                        }
                                        14 => {
                                            let e47 = {
                                                let l34 = *base.add(8).cast::<i32>();
                                                l34
                                            };
                                            V47::PrimS32(e47)
                                        }
                                        15 => {
                                            let e47 = {
                                                let l35 = *base.add(8).cast::<i64>();
                                                l35
                                            };
                                            V47::PrimS64(e47)
                                        }
                                        16 => {
                                            let e47 = {
                                                let l36 = *base.add(8).cast::<f32>();
                                                l36
                                            };
                                            V47::PrimFloat32(e47)
                                        }
                                        17 => {
                                            let e47 = {
                                                let l37 = *base.add(8).cast::<f64>();
                                                l37
                                            };
                                            V47::PrimFloat64(e47)
                                        }
                                        18 => {
                                            let e47 = {
                                                let l38 = *base.add(8).cast::<i32>();
                                                _rt::char_lift(l38 as u32)
                                            };
                                            V47::PrimChar(e47)
                                        }
                                        19 => {
                                            let e47 = {
                                                let l39 = i32::from(*base.add(8).cast::<u8>());
                                                _rt::bool_lift(l39 as u8)
                                            };
                                            V47::PrimBool(e47)
                                        }
                                        20 => {
                                            let e47 = {
                                                let l40 = *base.add(8).cast::<*mut u8>();
                                                let l41 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len42 = l41;
                                                let bytes42 = _rt::Vec::from_raw_parts(
                                                    l40.cast(),
                                                    len42,
                                                    len42,
                                                );
                                                _rt::string_lift(bytes42)
                                            };
                                            V47::PrimString(e47)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 21, "invalid enum discriminant");
                                            let e47 = {
                                                let l43 = *base.add(8).cast::<*mut u8>();
                                                let l44 = *base
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len45 = l44;
                                                let bytes45 = _rt::Vec::from_raw_parts(
                                                    l43.cast(),
                                                    len45,
                                                    len45,
                                                );
                                                let l46 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>();
                                                (
                                                    super::super::super::super::golem::rpc::types::Uri {
                                                        value: _rt::string_lift(bytes45),
                                                    },
                                                    l46 as u64,
                                                )
                                            };
                                            V47::Handle(e47)
                                        }
                                    };
                                    v47
                                };
                                result48.push(e48);
                            }
                            _rt::cabi_dealloc(
                                base48,
                                len48 * (16 + 2 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            super::super::super::super::golem::rpc::types::WitValue {
                                nodes: result48,
                            }
                        };
                        result49.push(e49);
                    }
                    _rt::cabi_dealloc(
                        base49,
                        len49 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result50 = T::invoke(
                        unsafe { AgentBorrow::lift(arg0 as u32 as usize) }.get(),
                        _rt::string_lift(bytes0),
                        result49,
                    );
                    let ptr51 = (&raw mut _RET_AREA.0).cast::<u8>();
                    use super::super::super::super::golem::agent::common::StatusUpdate as V57;
                    match result50 {
                        V57::Error(e) => {
                            *ptr51.add(0).cast::<u8>() = (0i32) as u8;
                            use super::super::super::super::golem::agent::common::Error as V52;
                            match e {
                                V52::NetworkError => {
                                    *ptr51
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            }
                        }
                        V57::Progress(e) => {
                            *ptr51.add(0).cast::<u8>() = (1i32) as u8;
                            match e {
                                Some(e) => {
                                    *ptr51
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::golem::agent::common::ProgressReport {
                                        description: description53,
                                        counter: counter53,
                                    } = e;
                                    let vec54 = (description53.into_bytes()).into_boxed_slice();
                                    let ptr54 = vec54.as_ptr().cast::<u8>();
                                    let len54 = vec54.len();
                                    ::core::mem::forget(vec54);
                                    *ptr51
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len54;
                                    *ptr51
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr54.cast_mut();
                                    match counter53 {
                                        Some(e) => {
                                            *ptr51
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::golem::agent::common::ProgressCounter {
                                                steps: steps55,
                                                total: total55,
                                            } = e;
                                            *ptr51
                                                .add(4 + 4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i32>() = _rt::as_i32(steps55);
                                            *ptr51
                                                .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i32>() = _rt::as_i32(total55);
                                        }
                                        None => {
                                            *ptr51
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                None => {
                                    *ptr51
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        V57::Emit(e) => {
                            *ptr51.add(0).cast::<u8>() = (2i32) as u8;
                            let vec56 = (e.into_bytes()).into_boxed_slice();
                            let ptr56 = vec56.as_ptr().cast::<u8>();
                            let len56 = vec56.len();
                            ::core::mem::forget(vec56);
                            *ptr51
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len56;
                            *ptr51
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr56.cast_mut();
                        }
                    }
                    ptr51
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_agent_invoke<T: GuestAgent>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        1 => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                _ => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                            }
                        }
                        _ => {
                            let l4 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_agent_get_definition_cabi<T: GuestAgent>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_definition(
                        unsafe { AgentBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::golem::agent::common::AgentType {
                        type_name: type_name2,
                        description: description2,
                        agent_constructor: agent_constructor2,
                        methods: methods2,
                        requires: requires2,
                    } = result0;
                    let vec3 = (type_name2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec4 = (description2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                    let super::super::super::super::golem::agent::common::AgentConstructor {
                        name: name5,
                        description: description5,
                        prompt_hint: prompt_hint5,
                        input_schema: input_schema5,
                    } = agent_constructor2;
                    match name5 {
                        Some(e) => {
                            *ptr1
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec6 = (e.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr1
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *ptr1
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr6.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec7 = (description5.into_bytes()).into_boxed_slice();
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    ::core::mem::forget(vec7);
                    *ptr1.add(8 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr1
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr7.cast_mut();
                    match prompt_hint5 {
                        Some(e) => {
                            *ptr1
                                .add(9 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec8 = (e.into_bytes()).into_boxed_slice();
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            ::core::mem::forget(vec8);
                            *ptr1
                                .add(11 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *ptr1
                                .add(10 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr8.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(9 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    use super::super::super::super::golem::agent::common::DataSchema as V34;
                    match input_schema5 {
                        V34::Structured(e) => {
                            *ptr1
                                .add(12 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                            let super::super::super::super::golem::agent::common::Structured {
                                parameters: parameters9,
                            } = e;
                            let vec29 = parameters9;
                            let len29 = vec29.len();
                            let layout29 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec29.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result29 = if layout29.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout29).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout29);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec29.into_iter().enumerate() {
                                let base = result29
                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                {
                                    use super::super::super::super::golem::agent::common::ParameterType as V28;
                                    match e {
                                        V28::Wit(e) => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                            let super::super::super::super::golem::rpc::types::WitType {
                                                nodes: nodes10,
                                            } = e;
                                            let vec25 = nodes10;
                                            let len25 = vec25.len();
                                            let layout25 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec25.len() * 24,
                                                8,
                                            );
                                            let result25 = if layout25.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout25).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout25);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec25.into_iter().enumerate() {
                                                let base = result25.add(i * 24);
                                                {
                                                    use super::super::super::super::golem::rpc::types::WitTypeNode as V24;
                                                    match e {
                                                        V24::RecordType(e) => {
                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                            let vec13 = e;
                                                            let len13 = vec13.len();
                                                            let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec13.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                            let result13 = if layout13.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout13);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec13.into_iter().enumerate() {
                                                                let base = result13
                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let (t11_0, t11_1) = e;
                                                                    let vec12 = (t11_0.into_bytes()).into_boxed_slice();
                                                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                                                    let len12 = vec12.len();
                                                                    ::core::mem::forget(vec12);
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len12;
                                                                    *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                                                                    *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>() = _rt::as_i32(t11_1);
                                                                }
                                                            }
                                                            *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len13;
                                                            *base.add(8).cast::<*mut u8>() = result13;
                                                        }
                                                        V24::VariantType(e) => {
                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                            let vec16 = e;
                                                            let len16 = vec16.len();
                                                            let layout16 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec16.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                            let result16 = if layout16.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout16).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout16);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec16.into_iter().enumerate() {
                                                                let base = result16
                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let (t14_0, t14_1) = e;
                                                                    let vec15 = (t14_0.into_bytes()).into_boxed_slice();
                                                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                                                    let len15 = vec15.len();
                                                                    ::core::mem::forget(vec15);
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len15;
                                                                    *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                                                                    match t14_1 {
                                                                        Some(e) => {
                                                                            *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>() = (1i32) as u8;
                                                                            *base
                                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        None => {
                                                                            *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>() = (0i32) as u8;
                                                                        }
                                                                    };
                                                                }
                                                            }
                                                            *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len16;
                                                            *base.add(8).cast::<*mut u8>() = result16;
                                                        }
                                                        V24::EnumType(e) => {
                                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                                            let vec18 = e;
                                                            let len18 = vec18.len();
                                                            let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec18.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                            let result18 = if layout18.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout18);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec18.into_iter().enumerate() {
                                                                let base = result18
                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                                                    let len17 = vec17.len();
                                                                    ::core::mem::forget(vec17);
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len17;
                                                                    *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
                                                                }
                                                            }
                                                            *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len18;
                                                            *base.add(8).cast::<*mut u8>() = result18;
                                                        }
                                                        V24::FlagsType(e) => {
                                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                                            let vec20 = e;
                                                            let len20 = vec20.len();
                                                            let layout20 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec20.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                            let result20 = if layout20.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout20).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout20);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec20.into_iter().enumerate() {
                                                                let base = result20
                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                                                    let len19 = vec19.len();
                                                                    ::core::mem::forget(vec19);
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len19;
                                                                    *base.add(0).cast::<*mut u8>() = ptr19.cast_mut();
                                                                }
                                                            }
                                                            *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len20;
                                                            *base.add(8).cast::<*mut u8>() = result20;
                                                        }
                                                        V24::TupleType(e) => {
                                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                                            let vec21 = (e).into_boxed_slice();
                                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                                            let len21 = vec21.len();
                                                            ::core::mem::forget(vec21);
                                                            *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len21;
                                                            *base.add(8).cast::<*mut u8>() = ptr21.cast_mut();
                                                        }
                                                        V24::ListType(e) => {
                                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                        }
                                                        V24::OptionType(e) => {
                                                            *base.add(0).cast::<u8>() = (6i32) as u8;
                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                        }
                                                        V24::ResultType(e) => {
                                                            *base.add(0).cast::<u8>() = (7i32) as u8;
                                                            let (t22_0, t22_1) = e;
                                                            match t22_0 {
                                                                Some(e) => {
                                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                    *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                }
                                                                None => {
                                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                }
                                                            };
                                                            match t22_1 {
                                                                Some(e) => {
                                                                    *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                    *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                }
                                                                None => {
                                                                    *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                }
                                                            };
                                                        }
                                                        V24::PrimU8Type => {
                                                            *base.add(0).cast::<u8>() = (8i32) as u8;
                                                        }
                                                        V24::PrimU16Type => {
                                                            *base.add(0).cast::<u8>() = (9i32) as u8;
                                                        }
                                                        V24::PrimU32Type => {
                                                            *base.add(0).cast::<u8>() = (10i32) as u8;
                                                        }
                                                        V24::PrimU64Type => {
                                                            *base.add(0).cast::<u8>() = (11i32) as u8;
                                                        }
                                                        V24::PrimS8Type => {
                                                            *base.add(0).cast::<u8>() = (12i32) as u8;
                                                        }
                                                        V24::PrimS16Type => {
                                                            *base.add(0).cast::<u8>() = (13i32) as u8;
                                                        }
                                                        V24::PrimS32Type => {
                                                            *base.add(0).cast::<u8>() = (14i32) as u8;
                                                        }
                                                        V24::PrimS64Type => {
                                                            *base.add(0).cast::<u8>() = (15i32) as u8;
                                                        }
                                                        V24::PrimF32Type => {
                                                            *base.add(0).cast::<u8>() = (16i32) as u8;
                                                        }
                                                        V24::PrimF64Type => {
                                                            *base.add(0).cast::<u8>() = (17i32) as u8;
                                                        }
                                                        V24::PrimCharType => {
                                                            *base.add(0).cast::<u8>() = (18i32) as u8;
                                                        }
                                                        V24::PrimBoolType => {
                                                            *base.add(0).cast::<u8>() = (19i32) as u8;
                                                        }
                                                        V24::PrimStringType => {
                                                            *base.add(0).cast::<u8>() = (20i32) as u8;
                                                        }
                                                        V24::HandleType(e) => {
                                                            *base.add(0).cast::<u8>() = (21i32) as u8;
                                                            let (t23_0, t23_1) = e;
                                                            *base.add(8).cast::<i64>() = _rt::as_i64(t23_0);
                                                            *base.add(16).cast::<u8>() = (t23_1.clone() as i32) as u8;
                                                        }
                                                    }
                                                }
                                            }
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len25;
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result25;
                                        }
                                        V28::Text(e) => {
                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::golem::agent::common::TextType {
                                                language_code: language_code26,
                                            } = e;
                                            let vec27 = (language_code26.into_bytes())
                                                .into_boxed_slice();
                                            let ptr27 = vec27.as_ptr().cast::<u8>();
                                            let len27 = vec27.len();
                                            ::core::mem::forget(vec27);
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len27;
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr27.cast_mut();
                                        }
                                    }
                                }
                            }
                            *ptr1
                                .add(14 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len29;
                            *ptr1
                                .add(13 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result29;
                        }
                        V34::Multimodal(e) => {
                            *ptr1
                                .add(12 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::golem::agent::common::Multimodal {
                                text: text30,
                            } = e;
                            match text30 {
                                Some(e) => {
                                    *ptr1
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec33 = e;
                                    let len33 = vec33.len();
                                    let layout33 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec33.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result33 = if layout33.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout33).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout33);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec33.into_iter().enumerate() {
                                        let base = result33
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let super::super::super::super::golem::agent::common::TextType {
                                                language_code: language_code31,
                                            } = e;
                                            let vec32 = (language_code31.into_bytes())
                                                .into_boxed_slice();
                                            let ptr32 = vec32.as_ptr().cast::<u8>();
                                            let len32 = vec32.len();
                                            ::core::mem::forget(vec32);
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len32;
                                            *base.add(0).cast::<*mut u8>() = ptr32.cast_mut();
                                        }
                                    }
                                    *ptr1
                                        .add(15 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len33;
                                    *ptr1
                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result33;
                                }
                                None => {
                                    *ptr1
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    }
                    let vec91 = methods2;
                    let len91 = vec91.len();
                    let layout91 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec91.len() * (15 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result91 = if layout91.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout91).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout91);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec91.into_iter().enumerate() {
                        let base = result91
                            .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::super::golem::agent::common::AgentMethod {
                                name: name35,
                                description: description35,
                                prompt_hint: prompt_hint35,
                                input_schema: input_schema35,
                                output_schema: output_schema35,
                            } = e;
                            let vec36 = (name35.into_bytes()).into_boxed_slice();
                            let ptr36 = vec36.as_ptr().cast::<u8>();
                            let len36 = vec36.len();
                            ::core::mem::forget(vec36);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len36;
                            *base.add(0).cast::<*mut u8>() = ptr36.cast_mut();
                            let vec37 = (description35.into_bytes()).into_boxed_slice();
                            let ptr37 = vec37.as_ptr().cast::<u8>();
                            let len37 = vec37.len();
                            ::core::mem::forget(vec37);
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len37;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr37.cast_mut();
                            match prompt_hint35 {
                                Some(e) => {
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec38 = (e.into_bytes()).into_boxed_slice();
                                    let ptr38 = vec38.as_ptr().cast::<u8>();
                                    let len38 = vec38.len();
                                    ::core::mem::forget(vec38);
                                    *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len38;
                                    *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr38.cast_mut();
                                }
                                None => {
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            use super::super::super::super::golem::agent::common::DataSchema as V64;
                            match input_schema35 {
                                V64::Structured(e) => {
                                    *base
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                    let super::super::super::super::golem::agent::common::Structured {
                                        parameters: parameters39,
                                    } = e;
                                    let vec59 = parameters39;
                                    let len59 = vec59.len();
                                    let layout59 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec59.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result59 = if layout59.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout59).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout59);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec59.into_iter().enumerate() {
                                        let base = result59
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            use super::super::super::super::golem::agent::common::ParameterType as V58;
                                            match e {
                                                V58::Wit(e) => {
                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                    let super::super::super::super::golem::rpc::types::WitType {
                                                        nodes: nodes40,
                                                    } = e;
                                                    let vec55 = nodes40;
                                                    let len55 = vec55.len();
                                                    let layout55 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec55.len() * 24,
                                                        8,
                                                    );
                                                    let result55 = if layout55.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout55).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout55);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec55.into_iter().enumerate() {
                                                        let base = result55.add(i * 24);
                                                        {
                                                            use super::super::super::super::golem::rpc::types::WitTypeNode as V54;
                                                            match e {
                                                                V54::RecordType(e) => {
                                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                    let vec43 = e;
                                                                    let len43 = vec43.len();
                                                                    let layout43 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec43.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result43 = if layout43.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout43).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout43);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec43.into_iter().enumerate() {
                                                                        let base = result43
                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let (t41_0, t41_1) = e;
                                                                            let vec42 = (t41_0.into_bytes()).into_boxed_slice();
                                                                            let ptr42 = vec42.as_ptr().cast::<u8>();
                                                                            let len42 = vec42.len();
                                                                            ::core::mem::forget(vec42);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len42;
                                                                            *base.add(0).cast::<*mut u8>() = ptr42.cast_mut();
                                                                            *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<i32>() = _rt::as_i32(t41_1);
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len43;
                                                                    *base.add(8).cast::<*mut u8>() = result43;
                                                                }
                                                                V54::VariantType(e) => {
                                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                    let vec46 = e;
                                                                    let len46 = vec46.len();
                                                                    let layout46 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec46.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result46 = if layout46.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout46).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout46);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec46.into_iter().enumerate() {
                                                                        let base = result46
                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let (t44_0, t44_1) = e;
                                                                            let vec45 = (t44_0.into_bytes()).into_boxed_slice();
                                                                            let ptr45 = vec45.as_ptr().cast::<u8>();
                                                                            let len45 = vec45.len();
                                                                            ::core::mem::forget(vec45);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len45;
                                                                            *base.add(0).cast::<*mut u8>() = ptr45.cast_mut();
                                                                            match t44_1 {
                                                                                Some(e) => {
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<u8>() = (1i32) as u8;
                                                                                    *base
                                                                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len46;
                                                                    *base.add(8).cast::<*mut u8>() = result46;
                                                                }
                                                                V54::EnumType(e) => {
                                                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                    let vec48 = e;
                                                                    let len48 = vec48.len();
                                                                    let layout48 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec48.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result48 = if layout48.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout48).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout48);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec48.into_iter().enumerate() {
                                                                        let base = result48
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let vec47 = (e.into_bytes()).into_boxed_slice();
                                                                            let ptr47 = vec47.as_ptr().cast::<u8>();
                                                                            let len47 = vec47.len();
                                                                            ::core::mem::forget(vec47);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len47;
                                                                            *base.add(0).cast::<*mut u8>() = ptr47.cast_mut();
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len48;
                                                                    *base.add(8).cast::<*mut u8>() = result48;
                                                                }
                                                                V54::FlagsType(e) => {
                                                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                    let vec50 = e;
                                                                    let len50 = vec50.len();
                                                                    let layout50 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec50.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result50 = if layout50.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout50).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout50);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec50.into_iter().enumerate() {
                                                                        let base = result50
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let vec49 = (e.into_bytes()).into_boxed_slice();
                                                                            let ptr49 = vec49.as_ptr().cast::<u8>();
                                                                            let len49 = vec49.len();
                                                                            ::core::mem::forget(vec49);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len49;
                                                                            *base.add(0).cast::<*mut u8>() = ptr49.cast_mut();
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len50;
                                                                    *base.add(8).cast::<*mut u8>() = result50;
                                                                }
                                                                V54::TupleType(e) => {
                                                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                    let vec51 = (e).into_boxed_slice();
                                                                    let ptr51 = vec51.as_ptr().cast::<u8>();
                                                                    let len51 = vec51.len();
                                                                    ::core::mem::forget(vec51);
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len51;
                                                                    *base.add(8).cast::<*mut u8>() = ptr51.cast_mut();
                                                                }
                                                                V54::ListType(e) => {
                                                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                }
                                                                V54::OptionType(e) => {
                                                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                }
                                                                V54::ResultType(e) => {
                                                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                    let (t52_0, t52_1) = e;
                                                                    match t52_0 {
                                                                        Some(e) => {
                                                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        None => {
                                                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                        }
                                                                    };
                                                                    match t52_1 {
                                                                        Some(e) => {
                                                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        None => {
                                                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                        }
                                                                    };
                                                                }
                                                                V54::PrimU8Type => {
                                                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                }
                                                                V54::PrimU16Type => {
                                                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                }
                                                                V54::PrimU32Type => {
                                                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                }
                                                                V54::PrimU64Type => {
                                                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                }
                                                                V54::PrimS8Type => {
                                                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                }
                                                                V54::PrimS16Type => {
                                                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                }
                                                                V54::PrimS32Type => {
                                                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                }
                                                                V54::PrimS64Type => {
                                                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                }
                                                                V54::PrimF32Type => {
                                                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                }
                                                                V54::PrimF64Type => {
                                                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                }
                                                                V54::PrimCharType => {
                                                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                }
                                                                V54::PrimBoolType => {
                                                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                }
                                                                V54::PrimStringType => {
                                                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                }
                                                                V54::HandleType(e) => {
                                                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                    let (t53_0, t53_1) = e;
                                                                    *base.add(8).cast::<i64>() = _rt::as_i64(t53_0);
                                                                    *base.add(16).cast::<u8>() = (t53_1.clone() as i32) as u8;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len55;
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result55;
                                                }
                                                V58::Text(e) => {
                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                    let super::super::super::super::golem::agent::common::TextType {
                                                        language_code: language_code56,
                                                    } = e;
                                                    let vec57 = (language_code56.into_bytes())
                                                        .into_boxed_slice();
                                                    let ptr57 = vec57.as_ptr().cast::<u8>();
                                                    let len57 = vec57.len();
                                                    ::core::mem::forget(vec57);
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len57;
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = ptr57.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len59;
                                    *base
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result59;
                                }
                                V64::Multimodal(e) => {
                                    *base
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::golem::agent::common::Multimodal {
                                        text: text60,
                                    } = e;
                                    match text60 {
                                        Some(e) => {
                                            *base
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec63 = e;
                                            let len63 = vec63.len();
                                            let layout63 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec63.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result63 = if layout63.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout63).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout63);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec63.into_iter().enumerate() {
                                                let base = result63
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let super::super::super::super::golem::agent::common::TextType {
                                                        language_code: language_code61,
                                                    } = e;
                                                    let vec62 = (language_code61.into_bytes())
                                                        .into_boxed_slice();
                                                    let ptr62 = vec62.as_ptr().cast::<u8>();
                                                    let len62 = vec62.len();
                                                    ::core::mem::forget(vec62);
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len62;
                                                    *base.add(0).cast::<*mut u8>() = ptr62.cast_mut();
                                                }
                                            }
                                            *base
                                                .add(10 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len63;
                                            *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result63;
                                        }
                                        None => {
                                            *base
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                            }
                            use super::super::super::super::golem::agent::common::DataSchema as V90;
                            match output_schema35 {
                                V90::Structured(e) => {
                                    *base
                                        .add(11 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                    let super::super::super::super::golem::agent::common::Structured {
                                        parameters: parameters65,
                                    } = e;
                                    let vec85 = parameters65;
                                    let len85 = vec85.len();
                                    let layout85 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec85.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result85 = if layout85.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout85).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout85);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec85.into_iter().enumerate() {
                                        let base = result85
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            use super::super::super::super::golem::agent::common::ParameterType as V84;
                                            match e {
                                                V84::Wit(e) => {
                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                    let super::super::super::super::golem::rpc::types::WitType {
                                                        nodes: nodes66,
                                                    } = e;
                                                    let vec81 = nodes66;
                                                    let len81 = vec81.len();
                                                    let layout81 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec81.len() * 24,
                                                        8,
                                                    );
                                                    let result81 = if layout81.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout81).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout81);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec81.into_iter().enumerate() {
                                                        let base = result81.add(i * 24);
                                                        {
                                                            use super::super::super::super::golem::rpc::types::WitTypeNode as V80;
                                                            match e {
                                                                V80::RecordType(e) => {
                                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                    let vec69 = e;
                                                                    let len69 = vec69.len();
                                                                    let layout69 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec69.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result69 = if layout69.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout69).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout69);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec69.into_iter().enumerate() {
                                                                        let base = result69
                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let (t67_0, t67_1) = e;
                                                                            let vec68 = (t67_0.into_bytes()).into_boxed_slice();
                                                                            let ptr68 = vec68.as_ptr().cast::<u8>();
                                                                            let len68 = vec68.len();
                                                                            ::core::mem::forget(vec68);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len68;
                                                                            *base.add(0).cast::<*mut u8>() = ptr68.cast_mut();
                                                                            *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<i32>() = _rt::as_i32(t67_1);
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len69;
                                                                    *base.add(8).cast::<*mut u8>() = result69;
                                                                }
                                                                V80::VariantType(e) => {
                                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                    let vec72 = e;
                                                                    let len72 = vec72.len();
                                                                    let layout72 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec72.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result72 = if layout72.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout72).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout72);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec72.into_iter().enumerate() {
                                                                        let base = result72
                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let (t70_0, t70_1) = e;
                                                                            let vec71 = (t70_0.into_bytes()).into_boxed_slice();
                                                                            let ptr71 = vec71.as_ptr().cast::<u8>();
                                                                            let len71 = vec71.len();
                                                                            ::core::mem::forget(vec71);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len71;
                                                                            *base.add(0).cast::<*mut u8>() = ptr71.cast_mut();
                                                                            match t70_1 {
                                                                                Some(e) => {
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<u8>() = (1i32) as u8;
                                                                                    *base
                                                                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len72;
                                                                    *base.add(8).cast::<*mut u8>() = result72;
                                                                }
                                                                V80::EnumType(e) => {
                                                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                    let vec74 = e;
                                                                    let len74 = vec74.len();
                                                                    let layout74 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec74.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result74 = if layout74.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout74).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout74);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec74.into_iter().enumerate() {
                                                                        let base = result74
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let vec73 = (e.into_bytes()).into_boxed_slice();
                                                                            let ptr73 = vec73.as_ptr().cast::<u8>();
                                                                            let len73 = vec73.len();
                                                                            ::core::mem::forget(vec73);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len73;
                                                                            *base.add(0).cast::<*mut u8>() = ptr73.cast_mut();
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len74;
                                                                    *base.add(8).cast::<*mut u8>() = result74;
                                                                }
                                                                V80::FlagsType(e) => {
                                                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                    let vec76 = e;
                                                                    let len76 = vec76.len();
                                                                    let layout76 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec76.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result76 = if layout76.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout76).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout76);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec76.into_iter().enumerate() {
                                                                        let base = result76
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let vec75 = (e.into_bytes()).into_boxed_slice();
                                                                            let ptr75 = vec75.as_ptr().cast::<u8>();
                                                                            let len75 = vec75.len();
                                                                            ::core::mem::forget(vec75);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len75;
                                                                            *base.add(0).cast::<*mut u8>() = ptr75.cast_mut();
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len76;
                                                                    *base.add(8).cast::<*mut u8>() = result76;
                                                                }
                                                                V80::TupleType(e) => {
                                                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                    let vec77 = (e).into_boxed_slice();
                                                                    let ptr77 = vec77.as_ptr().cast::<u8>();
                                                                    let len77 = vec77.len();
                                                                    ::core::mem::forget(vec77);
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len77;
                                                                    *base.add(8).cast::<*mut u8>() = ptr77.cast_mut();
                                                                }
                                                                V80::ListType(e) => {
                                                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                }
                                                                V80::OptionType(e) => {
                                                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                }
                                                                V80::ResultType(e) => {
                                                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                    let (t78_0, t78_1) = e;
                                                                    match t78_0 {
                                                                        Some(e) => {
                                                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        None => {
                                                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                        }
                                                                    };
                                                                    match t78_1 {
                                                                        Some(e) => {
                                                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        None => {
                                                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                        }
                                                                    };
                                                                }
                                                                V80::PrimU8Type => {
                                                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                }
                                                                V80::PrimU16Type => {
                                                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                }
                                                                V80::PrimU32Type => {
                                                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                }
                                                                V80::PrimU64Type => {
                                                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                }
                                                                V80::PrimS8Type => {
                                                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                }
                                                                V80::PrimS16Type => {
                                                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                }
                                                                V80::PrimS32Type => {
                                                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                }
                                                                V80::PrimS64Type => {
                                                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                }
                                                                V80::PrimF32Type => {
                                                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                }
                                                                V80::PrimF64Type => {
                                                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                }
                                                                V80::PrimCharType => {
                                                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                }
                                                                V80::PrimBoolType => {
                                                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                }
                                                                V80::PrimStringType => {
                                                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                }
                                                                V80::HandleType(e) => {
                                                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                    let (t79_0, t79_1) = e;
                                                                    *base.add(8).cast::<i64>() = _rt::as_i64(t79_0);
                                                                    *base.add(16).cast::<u8>() = (t79_1.clone() as i32) as u8;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len81;
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result81;
                                                }
                                                V84::Text(e) => {
                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                    let super::super::super::super::golem::agent::common::TextType {
                                                        language_code: language_code82,
                                                    } = e;
                                                    let vec83 = (language_code82.into_bytes())
                                                        .into_boxed_slice();
                                                    let ptr83 = vec83.as_ptr().cast::<u8>();
                                                    let len83 = vec83.len();
                                                    ::core::mem::forget(vec83);
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len83;
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = ptr83.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len85;
                                    *base
                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result85;
                                }
                                V90::Multimodal(e) => {
                                    *base
                                        .add(11 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::golem::agent::common::Multimodal {
                                        text: text86,
                                    } = e;
                                    match text86 {
                                        Some(e) => {
                                            *base
                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec89 = e;
                                            let len89 = vec89.len();
                                            let layout89 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec89.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result89 = if layout89.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout89).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout89);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec89.into_iter().enumerate() {
                                                let base = result89
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let super::super::super::super::golem::agent::common::TextType {
                                                        language_code: language_code87,
                                                    } = e;
                                                    let vec88 = (language_code87.into_bytes())
                                                        .into_boxed_slice();
                                                    let ptr88 = vec88.as_ptr().cast::<u8>();
                                                    let len88 = vec88.len();
                                                    ::core::mem::forget(vec88);
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len88;
                                                    *base.add(0).cast::<*mut u8>() = ptr88.cast_mut();
                                                }
                                            }
                                            *base
                                                .add(14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len89;
                                            *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result89;
                                        }
                                        None => {
                                            *base
                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                            }
                        }
                    }
                    *ptr1
                        .add(17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len91;
                    *ptr1
                        .add(16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result91;
                    let vec151 = requires2;
                    let len151 = vec151.len();
                    let layout151 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec151.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result151 = if layout151.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout151).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout151);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec151.into_iter().enumerate() {
                        let base = result151
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::super::golem::agent::common::AgentDependency {
                                agent_name: agent_name92,
                                methods: methods92,
                            } = e;
                            let vec93 = (agent_name92.into_bytes()).into_boxed_slice();
                            let ptr93 = vec93.as_ptr().cast::<u8>();
                            let len93 = vec93.len();
                            ::core::mem::forget(vec93);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len93;
                            *base.add(0).cast::<*mut u8>() = ptr93.cast_mut();
                            let vec150 = methods92;
                            let len150 = vec150.len();
                            let layout150 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec150.len() * (15 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result150 = if layout150.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout150).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout150);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec150.into_iter().enumerate() {
                                let base = result150
                                    .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::golem::agent::common::AgentMethod {
                                        name: name94,
                                        description: description94,
                                        prompt_hint: prompt_hint94,
                                        input_schema: input_schema94,
                                        output_schema: output_schema94,
                                    } = e;
                                    let vec95 = (name94.into_bytes()).into_boxed_slice();
                                    let ptr95 = vec95.as_ptr().cast::<u8>();
                                    let len95 = vec95.len();
                                    ::core::mem::forget(vec95);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len95;
                                    *base.add(0).cast::<*mut u8>() = ptr95.cast_mut();
                                    let vec96 = (description94.into_bytes()).into_boxed_slice();
                                    let ptr96 = vec96.as_ptr().cast::<u8>();
                                    let len96 = vec96.len();
                                    ::core::mem::forget(vec96);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len96;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr96.cast_mut();
                                    match prompt_hint94 {
                                        Some(e) => {
                                            *base
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec97 = (e.into_bytes()).into_boxed_slice();
                                            let ptr97 = vec97.as_ptr().cast::<u8>();
                                            let len97 = vec97.len();
                                            ::core::mem::forget(vec97);
                                            *base
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len97;
                                            *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr97.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    use super::super::super::super::golem::agent::common::DataSchema as V123;
                                    match input_schema94 {
                                        V123::Structured(e) => {
                                            *base
                                                .add(7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                            let super::super::super::super::golem::agent::common::Structured {
                                                parameters: parameters98,
                                            } = e;
                                            let vec118 = parameters98;
                                            let len118 = vec118.len();
                                            let layout118 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec118.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result118 = if layout118.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout118).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout118);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec118.into_iter().enumerate() {
                                                let base = result118
                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    use super::super::super::super::golem::agent::common::ParameterType as V117;
                                                    match e {
                                                        V117::Wit(e) => {
                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                            let super::super::super::super::golem::rpc::types::WitType {
                                                                nodes: nodes99,
                                                            } = e;
                                                            let vec114 = nodes99;
                                                            let len114 = vec114.len();
                                                            let layout114 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec114.len() * 24,
                                                                8,
                                                            );
                                                            let result114 = if layout114.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout114).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout114);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec114.into_iter().enumerate() {
                                                                let base = result114.add(i * 24);
                                                                {
                                                                    use super::super::super::super::golem::rpc::types::WitTypeNode as V113;
                                                                    match e {
                                                                        V113::RecordType(e) => {
                                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                            let vec102 = e;
                                                                            let len102 = vec102.len();
                                                                            let layout102 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec102.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result102 = if layout102.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout102).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout102);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec102.into_iter().enumerate() {
                                                                                let base = result102
                                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let (t100_0, t100_1) = e;
                                                                                    let vec101 = (t100_0.into_bytes()).into_boxed_slice();
                                                                                    let ptr101 = vec101.as_ptr().cast::<u8>();
                                                                                    let len101 = vec101.len();
                                                                                    ::core::mem::forget(vec101);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len101;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr101.cast_mut();
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<i32>() = _rt::as_i32(t100_1);
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len102;
                                                                            *base.add(8).cast::<*mut u8>() = result102;
                                                                        }
                                                                        V113::VariantType(e) => {
                                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                            let vec105 = e;
                                                                            let len105 = vec105.len();
                                                                            let layout105 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec105.len()
                                                                                    * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result105 = if layout105.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout105).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout105);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec105.into_iter().enumerate() {
                                                                                let base = result105
                                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let (t103_0, t103_1) = e;
                                                                                    let vec104 = (t103_0.into_bytes()).into_boxed_slice();
                                                                                    let ptr104 = vec104.as_ptr().cast::<u8>();
                                                                                    let len104 = vec104.len();
                                                                                    ::core::mem::forget(vec104);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len104;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr104.cast_mut();
                                                                                    match t103_1 {
                                                                                        Some(e) => {
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>() = (1i32) as u8;
                                                                                            *base
                                                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<i32>() = _rt::as_i32(e);
                                                                                        }
                                                                                        None => {
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                    };
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len105;
                                                                            *base.add(8).cast::<*mut u8>() = result105;
                                                                        }
                                                                        V113::EnumType(e) => {
                                                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                            let vec107 = e;
                                                                            let len107 = vec107.len();
                                                                            let layout107 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec107.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result107 = if layout107.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout107).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout107);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec107.into_iter().enumerate() {
                                                                                let base = result107
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let vec106 = (e.into_bytes()).into_boxed_slice();
                                                                                    let ptr106 = vec106.as_ptr().cast::<u8>();
                                                                                    let len106 = vec106.len();
                                                                                    ::core::mem::forget(vec106);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len106;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr106.cast_mut();
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len107;
                                                                            *base.add(8).cast::<*mut u8>() = result107;
                                                                        }
                                                                        V113::FlagsType(e) => {
                                                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                            let vec109 = e;
                                                                            let len109 = vec109.len();
                                                                            let layout109 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec109.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result109 = if layout109.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout109).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout109);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec109.into_iter().enumerate() {
                                                                                let base = result109
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let vec108 = (e.into_bytes()).into_boxed_slice();
                                                                                    let ptr108 = vec108.as_ptr().cast::<u8>();
                                                                                    let len108 = vec108.len();
                                                                                    ::core::mem::forget(vec108);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len108;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr108.cast_mut();
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len109;
                                                                            *base.add(8).cast::<*mut u8>() = result109;
                                                                        }
                                                                        V113::TupleType(e) => {
                                                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                            let vec110 = (e).into_boxed_slice();
                                                                            let ptr110 = vec110.as_ptr().cast::<u8>();
                                                                            let len110 = vec110.len();
                                                                            ::core::mem::forget(vec110);
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len110;
                                                                            *base.add(8).cast::<*mut u8>() = ptr110.cast_mut();
                                                                        }
                                                                        V113::ListType(e) => {
                                                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        V113::OptionType(e) => {
                                                                            *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        V113::ResultType(e) => {
                                                                            *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                            let (t111_0, t111_1) = e;
                                                                            match t111_0 {
                                                                                Some(e) => {
                                                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                                    *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                            match t111_1 {
                                                                                Some(e) => {
                                                                                    *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                                    *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                        }
                                                                        V113::PrimU8Type => {
                                                                            *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                        }
                                                                        V113::PrimU16Type => {
                                                                            *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                        }
                                                                        V113::PrimU32Type => {
                                                                            *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                        }
                                                                        V113::PrimU64Type => {
                                                                            *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                        }
                                                                        V113::PrimS8Type => {
                                                                            *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                        }
                                                                        V113::PrimS16Type => {
                                                                            *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                        }
                                                                        V113::PrimS32Type => {
                                                                            *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                        }
                                                                        V113::PrimS64Type => {
                                                                            *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                        }
                                                                        V113::PrimF32Type => {
                                                                            *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                        }
                                                                        V113::PrimF64Type => {
                                                                            *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                        }
                                                                        V113::PrimCharType => {
                                                                            *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                        }
                                                                        V113::PrimBoolType => {
                                                                            *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                        }
                                                                        V113::PrimStringType => {
                                                                            *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                        }
                                                                        V113::HandleType(e) => {
                                                                            *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                            let (t112_0, t112_1) = e;
                                                                            *base.add(8).cast::<i64>() = _rt::as_i64(t112_0);
                                                                            *base.add(16).cast::<u8>() = (t112_1.clone() as i32) as u8;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len114;
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = result114;
                                                        }
                                                        V117::Text(e) => {
                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                            let super::super::super::super::golem::agent::common::TextType {
                                                                language_code: language_code115,
                                                            } = e;
                                                            let vec116 = (language_code115.into_bytes())
                                                                .into_boxed_slice();
                                                            let ptr116 = vec116.as_ptr().cast::<u8>();
                                                            let len116 = vec116.len();
                                                            ::core::mem::forget(vec116);
                                                            *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len116;
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = ptr116.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len118;
                                            *base
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result118;
                                        }
                                        V123::Multimodal(e) => {
                                            *base
                                                .add(7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::golem::agent::common::Multimodal {
                                                text: text119,
                                            } = e;
                                            match text119 {
                                                Some(e) => {
                                                    *base
                                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    let vec122 = e;
                                                    let len122 = vec122.len();
                                                    let layout122 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec122.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                    let result122 = if layout122.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout122).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout122);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec122.into_iter().enumerate() {
                                                        let base = result122
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let super::super::super::super::golem::agent::common::TextType {
                                                                language_code: language_code120,
                                                            } = e;
                                                            let vec121 = (language_code120.into_bytes())
                                                                .into_boxed_slice();
                                                            let ptr121 = vec121.as_ptr().cast::<u8>();
                                                            let len121 = vec121.len();
                                                            ::core::mem::forget(vec121);
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len121;
                                                            *base.add(0).cast::<*mut u8>() = ptr121.cast_mut();
                                                        }
                                                    }
                                                    *base
                                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len122;
                                                    *base
                                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result122;
                                                }
                                                None => {
                                                    *base
                                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                    }
                                    use super::super::super::super::golem::agent::common::DataSchema as V149;
                                    match output_schema94 {
                                        V149::Structured(e) => {
                                            *base
                                                .add(11 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                            let super::super::super::super::golem::agent::common::Structured {
                                                parameters: parameters124,
                                            } = e;
                                            let vec144 = parameters124;
                                            let len144 = vec144.len();
                                            let layout144 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec144.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result144 = if layout144.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout144).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout144);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec144.into_iter().enumerate() {
                                                let base = result144
                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    use super::super::super::super::golem::agent::common::ParameterType as V143;
                                                    match e {
                                                        V143::Wit(e) => {
                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                            let super::super::super::super::golem::rpc::types::WitType {
                                                                nodes: nodes125,
                                                            } = e;
                                                            let vec140 = nodes125;
                                                            let len140 = vec140.len();
                                                            let layout140 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec140.len() * 24,
                                                                8,
                                                            );
                                                            let result140 = if layout140.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout140).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout140);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec140.into_iter().enumerate() {
                                                                let base = result140.add(i * 24);
                                                                {
                                                                    use super::super::super::super::golem::rpc::types::WitTypeNode as V139;
                                                                    match e {
                                                                        V139::RecordType(e) => {
                                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                            let vec128 = e;
                                                                            let len128 = vec128.len();
                                                                            let layout128 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec128.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result128 = if layout128.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout128).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout128);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec128.into_iter().enumerate() {
                                                                                let base = result128
                                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let (t126_0, t126_1) = e;
                                                                                    let vec127 = (t126_0.into_bytes()).into_boxed_slice();
                                                                                    let ptr127 = vec127.as_ptr().cast::<u8>();
                                                                                    let len127 = vec127.len();
                                                                                    ::core::mem::forget(vec127);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len127;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr127.cast_mut();
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<i32>() = _rt::as_i32(t126_1);
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len128;
                                                                            *base.add(8).cast::<*mut u8>() = result128;
                                                                        }
                                                                        V139::VariantType(e) => {
                                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                            let vec131 = e;
                                                                            let len131 = vec131.len();
                                                                            let layout131 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec131.len()
                                                                                    * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result131 = if layout131.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout131).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout131);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec131.into_iter().enumerate() {
                                                                                let base = result131
                                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let (t129_0, t129_1) = e;
                                                                                    let vec130 = (t129_0.into_bytes()).into_boxed_slice();
                                                                                    let ptr130 = vec130.as_ptr().cast::<u8>();
                                                                                    let len130 = vec130.len();
                                                                                    ::core::mem::forget(vec130);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len130;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr130.cast_mut();
                                                                                    match t129_1 {
                                                                                        Some(e) => {
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>() = (1i32) as u8;
                                                                                            *base
                                                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<i32>() = _rt::as_i32(e);
                                                                                        }
                                                                                        None => {
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                    };
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len131;
                                                                            *base.add(8).cast::<*mut u8>() = result131;
                                                                        }
                                                                        V139::EnumType(e) => {
                                                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                            let vec133 = e;
                                                                            let len133 = vec133.len();
                                                                            let layout133 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec133.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result133 = if layout133.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout133).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout133);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec133.into_iter().enumerate() {
                                                                                let base = result133
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let vec132 = (e.into_bytes()).into_boxed_slice();
                                                                                    let ptr132 = vec132.as_ptr().cast::<u8>();
                                                                                    let len132 = vec132.len();
                                                                                    ::core::mem::forget(vec132);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len132;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr132.cast_mut();
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len133;
                                                                            *base.add(8).cast::<*mut u8>() = result133;
                                                                        }
                                                                        V139::FlagsType(e) => {
                                                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                            let vec135 = e;
                                                                            let len135 = vec135.len();
                                                                            let layout135 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec135.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result135 = if layout135.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout135).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout135);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec135.into_iter().enumerate() {
                                                                                let base = result135
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let vec134 = (e.into_bytes()).into_boxed_slice();
                                                                                    let ptr134 = vec134.as_ptr().cast::<u8>();
                                                                                    let len134 = vec134.len();
                                                                                    ::core::mem::forget(vec134);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len134;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr134.cast_mut();
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len135;
                                                                            *base.add(8).cast::<*mut u8>() = result135;
                                                                        }
                                                                        V139::TupleType(e) => {
                                                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                            let vec136 = (e).into_boxed_slice();
                                                                            let ptr136 = vec136.as_ptr().cast::<u8>();
                                                                            let len136 = vec136.len();
                                                                            ::core::mem::forget(vec136);
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len136;
                                                                            *base.add(8).cast::<*mut u8>() = ptr136.cast_mut();
                                                                        }
                                                                        V139::ListType(e) => {
                                                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        V139::OptionType(e) => {
                                                                            *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        V139::ResultType(e) => {
                                                                            *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                            let (t137_0, t137_1) = e;
                                                                            match t137_0 {
                                                                                Some(e) => {
                                                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                                    *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                            match t137_1 {
                                                                                Some(e) => {
                                                                                    *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                                    *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                        }
                                                                        V139::PrimU8Type => {
                                                                            *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                        }
                                                                        V139::PrimU16Type => {
                                                                            *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                        }
                                                                        V139::PrimU32Type => {
                                                                            *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                        }
                                                                        V139::PrimU64Type => {
                                                                            *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                        }
                                                                        V139::PrimS8Type => {
                                                                            *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                        }
                                                                        V139::PrimS16Type => {
                                                                            *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                        }
                                                                        V139::PrimS32Type => {
                                                                            *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                        }
                                                                        V139::PrimS64Type => {
                                                                            *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                        }
                                                                        V139::PrimF32Type => {
                                                                            *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                        }
                                                                        V139::PrimF64Type => {
                                                                            *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                        }
                                                                        V139::PrimCharType => {
                                                                            *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                        }
                                                                        V139::PrimBoolType => {
                                                                            *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                        }
                                                                        V139::PrimStringType => {
                                                                            *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                        }
                                                                        V139::HandleType(e) => {
                                                                            *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                            let (t138_0, t138_1) = e;
                                                                            *base.add(8).cast::<i64>() = _rt::as_i64(t138_0);
                                                                            *base.add(16).cast::<u8>() = (t138_1.clone() as i32) as u8;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len140;
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = result140;
                                                        }
                                                        V143::Text(e) => {
                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                            let super::super::super::super::golem::agent::common::TextType {
                                                                language_code: language_code141,
                                                            } = e;
                                                            let vec142 = (language_code141.into_bytes())
                                                                .into_boxed_slice();
                                                            let ptr142 = vec142.as_ptr().cast::<u8>();
                                                            let len142 = vec142.len();
                                                            ::core::mem::forget(vec142);
                                                            *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len142;
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = ptr142.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len144;
                                            *base
                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result144;
                                        }
                                        V149::Multimodal(e) => {
                                            *base
                                                .add(11 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::golem::agent::common::Multimodal {
                                                text: text145,
                                            } = e;
                                            match text145 {
                                                Some(e) => {
                                                    *base
                                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    let vec148 = e;
                                                    let len148 = vec148.len();
                                                    let layout148 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec148.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                    let result148 = if layout148.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout148).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout148);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec148.into_iter().enumerate() {
                                                        let base = result148
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let super::super::super::super::golem::agent::common::TextType {
                                                                language_code: language_code146,
                                                            } = e;
                                                            let vec147 = (language_code146.into_bytes())
                                                                .into_boxed_slice();
                                                            let ptr147 = vec147.as_ptr().cast::<u8>();
                                                            let len147 = vec147.len();
                                                            ::core::mem::forget(vec147);
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len147;
                                                            *base.add(0).cast::<*mut u8>() = ptr147.cast_mut();
                                                        }
                                                    }
                                                    *base
                                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len148;
                                                    *base
                                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result148;
                                                }
                                                None => {
                                                    *base
                                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                    }
                                }
                            }
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len150;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result150;
                        }
                    }
                    *ptr1
                        .add(19 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len151;
                    *ptr1
                        .add(18 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result151;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_agent_get_definition<T: GuestAgent>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                    let l4 = i32::from(
                        *arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l4 {
                        0 => {}
                        _ => {
                            let l5 = *arg0
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l6 = *arg0
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l5, l6, 1);
                        }
                    }
                    let l7 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *arg0
                        .add(8 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l7, l8, 1);
                    let l9 = i32::from(
                        *arg0.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l9 {
                        0 => {}
                        _ => {
                            let l10 = *arg0
                                .add(10 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l11 = *arg0
                                .add(11 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l10, l11, 1);
                        }
                    }
                    let l12 = i32::from(
                        *arg0.add(12 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l12 {
                        0 => {
                            let l13 = *arg0
                                .add(13 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l14 = *arg0
                                .add(14 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base45 = l13;
                            let len45 = l14;
                            for i in 0..len45 {
                                let base = base45
                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l15 = i32::from(*base.add(0).cast::<u8>());
                                    match l15 {
                                        0 => {
                                            let l16 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l17 = *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base42 = l16;
                                            let len42 = l17;
                                            for i in 0..len42 {
                                                let base = base42.add(i * 24);
                                                {
                                                    let l18 = i32::from(*base.add(0).cast::<u8>());
                                                    match l18 {
                                                        0 => {
                                                            let l19 = *base.add(8).cast::<*mut u8>();
                                                            let l20 = *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base23 = l19;
                                                            let len23 = l20;
                                                            for i in 0..len23 {
                                                                let base = base23
                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let l21 = *base.add(0).cast::<*mut u8>();
                                                                    let l22 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    _rt::cabi_dealloc(l21, l22, 1);
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(
                                                                base23,
                                                                len23 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                        }
                                                        1 => {
                                                            let l24 = *base.add(8).cast::<*mut u8>();
                                                            let l25 = *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base28 = l24;
                                                            let len28 = l25;
                                                            for i in 0..len28 {
                                                                let base = base28
                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let l26 = *base.add(0).cast::<*mut u8>();
                                                                    let l27 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    _rt::cabi_dealloc(l26, l27, 1);
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(
                                                                base28,
                                                                len28 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                        }
                                                        2 => {
                                                            let l29 = *base.add(8).cast::<*mut u8>();
                                                            let l30 = *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base33 = l29;
                                                            let len33 = l30;
                                                            for i in 0..len33 {
                                                                let base = base33
                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let l31 = *base.add(0).cast::<*mut u8>();
                                                                    let l32 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    _rt::cabi_dealloc(l31, l32, 1);
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(
                                                                base33,
                                                                len33 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                        }
                                                        3 => {
                                                            let l34 = *base.add(8).cast::<*mut u8>();
                                                            let l35 = *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base38 = l34;
                                                            let len38 = l35;
                                                            for i in 0..len38 {
                                                                let base = base38
                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let l36 = *base.add(0).cast::<*mut u8>();
                                                                    let l37 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    _rt::cabi_dealloc(l36, l37, 1);
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(
                                                                base38,
                                                                len38 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                        }
                                                        4 => {
                                                            let l39 = *base.add(8).cast::<*mut u8>();
                                                            let l40 = *base
                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base41 = l39;
                                                            let len41 = l40;
                                                            _rt::cabi_dealloc(base41, len41 * 4, 4);
                                                        }
                                                        5 => {}
                                                        6 => {}
                                                        7 => {}
                                                        8 => {}
                                                        9 => {}
                                                        10 => {}
                                                        11 => {}
                                                        12 => {}
                                                        13 => {}
                                                        14 => {}
                                                        15 => {}
                                                        16 => {}
                                                        17 => {}
                                                        18 => {}
                                                        19 => {}
                                                        20 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            _rt::cabi_dealloc(base42, len42 * 24, 8);
                                        }
                                        _ => {
                                            let l43 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l44 = *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l43, l44, 1);
                                        }
                                    }
                                }
                            }
                            _rt::cabi_dealloc(
                                base45,
                                len45 * (3 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l46 = i32::from(
                                *arg0
                                    .add(13 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l46 {
                                0 => {}
                                _ => {
                                    let l47 = *arg0
                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l48 = *arg0
                                        .add(15 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base51 = l47;
                                    let len51 = l48;
                                    for i in 0..len51 {
                                        let base = base51
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l49 = *base.add(0).cast::<*mut u8>();
                                            let l50 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l49, l50, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base51,
                                        len51 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                            }
                        }
                    }
                    let l52 = *arg0
                        .add(16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l53 = *arg0
                        .add(17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base141 = l52;
                    let len141 = l53;
                    for i in 0..len141 {
                        let base = base141
                            .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l54 = *base.add(0).cast::<*mut u8>();
                            let l55 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l54, l55, 1);
                            let l56 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l57 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l56, l57, 1);
                            let l58 = i32::from(
                                *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l58 {
                                0 => {}
                                _ => {
                                    let l59 = *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l60 = *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l59, l60, 1);
                                }
                            }
                            let l61 = i32::from(
                                *base
                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l61 {
                                0 => {
                                    let l62 = *base
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l63 = *base
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base94 = l62;
                                    let len94 = l63;
                                    for i in 0..len94 {
                                        let base = base94
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l64 = i32::from(*base.add(0).cast::<u8>());
                                            match l64 {
                                                0 => {
                                                    let l65 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l66 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base91 = l65;
                                                    let len91 = l66;
                                                    for i in 0..len91 {
                                                        let base = base91.add(i * 24);
                                                        {
                                                            let l67 = i32::from(*base.add(0).cast::<u8>());
                                                            match l67 {
                                                                0 => {
                                                                    let l68 = *base.add(8).cast::<*mut u8>();
                                                                    let l69 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base72 = l68;
                                                                    let len72 = l69;
                                                                    for i in 0..len72 {
                                                                        let base = base72
                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l70 = *base.add(0).cast::<*mut u8>();
                                                                            let l71 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l70, l71, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base72,
                                                                        len72 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                1 => {
                                                                    let l73 = *base.add(8).cast::<*mut u8>();
                                                                    let l74 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base77 = l73;
                                                                    let len77 = l74;
                                                                    for i in 0..len77 {
                                                                        let base = base77
                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l75 = *base.add(0).cast::<*mut u8>();
                                                                            let l76 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l75, l76, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base77,
                                                                        len77 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                2 => {
                                                                    let l78 = *base.add(8).cast::<*mut u8>();
                                                                    let l79 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base82 = l78;
                                                                    let len82 = l79;
                                                                    for i in 0..len82 {
                                                                        let base = base82
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l80 = *base.add(0).cast::<*mut u8>();
                                                                            let l81 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l80, l81, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base82,
                                                                        len82 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                3 => {
                                                                    let l83 = *base.add(8).cast::<*mut u8>();
                                                                    let l84 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base87 = l83;
                                                                    let len87 = l84;
                                                                    for i in 0..len87 {
                                                                        let base = base87
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l85 = *base.add(0).cast::<*mut u8>();
                                                                            let l86 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l85, l86, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base87,
                                                                        len87 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                4 => {
                                                                    let l88 = *base.add(8).cast::<*mut u8>();
                                                                    let l89 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base90 = l88;
                                                                    let len90 = l89;
                                                                    _rt::cabi_dealloc(base90, len90 * 4, 4);
                                                                }
                                                                5 => {}
                                                                6 => {}
                                                                7 => {}
                                                                8 => {}
                                                                9 => {}
                                                                10 => {}
                                                                11 => {}
                                                                12 => {}
                                                                13 => {}
                                                                14 => {}
                                                                15 => {}
                                                                16 => {}
                                                                17 => {}
                                                                18 => {}
                                                                19 => {}
                                                                20 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(base91, len91 * 24, 8);
                                                }
                                                _ => {
                                                    let l92 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l93 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    _rt::cabi_dealloc(l92, l93, 1);
                                                }
                                            }
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base94,
                                        len94 * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                                _ => {
                                    let l95 = i32::from(
                                        *base
                                            .add(8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l95 {
                                        0 => {}
                                        _ => {
                                            let l96 = *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l97 = *base
                                                .add(10 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base100 = l96;
                                            let len100 = l97;
                                            for i in 0..len100 {
                                                let base = base100
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let l98 = *base.add(0).cast::<*mut u8>();
                                                    let l99 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    _rt::cabi_dealloc(l98, l99, 1);
                                                }
                                            }
                                            _rt::cabi_dealloc(
                                                base100,
                                                len100 * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                        }
                                    }
                                }
                            }
                            let l101 = i32::from(
                                *base
                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l101 {
                                0 => {
                                    let l102 = *base
                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l103 = *base
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base134 = l102;
                                    let len134 = l103;
                                    for i in 0..len134 {
                                        let base = base134
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l104 = i32::from(*base.add(0).cast::<u8>());
                                            match l104 {
                                                0 => {
                                                    let l105 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l106 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base131 = l105;
                                                    let len131 = l106;
                                                    for i in 0..len131 {
                                                        let base = base131.add(i * 24);
                                                        {
                                                            let l107 = i32::from(*base.add(0).cast::<u8>());
                                                            match l107 {
                                                                0 => {
                                                                    let l108 = *base.add(8).cast::<*mut u8>();
                                                                    let l109 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base112 = l108;
                                                                    let len112 = l109;
                                                                    for i in 0..len112 {
                                                                        let base = base112
                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l110 = *base.add(0).cast::<*mut u8>();
                                                                            let l111 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l110, l111, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base112,
                                                                        len112 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                1 => {
                                                                    let l113 = *base.add(8).cast::<*mut u8>();
                                                                    let l114 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base117 = l113;
                                                                    let len117 = l114;
                                                                    for i in 0..len117 {
                                                                        let base = base117
                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l115 = *base.add(0).cast::<*mut u8>();
                                                                            let l116 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l115, l116, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base117,
                                                                        len117 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                2 => {
                                                                    let l118 = *base.add(8).cast::<*mut u8>();
                                                                    let l119 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base122 = l118;
                                                                    let len122 = l119;
                                                                    for i in 0..len122 {
                                                                        let base = base122
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l120 = *base.add(0).cast::<*mut u8>();
                                                                            let l121 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l120, l121, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base122,
                                                                        len122 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                3 => {
                                                                    let l123 = *base.add(8).cast::<*mut u8>();
                                                                    let l124 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base127 = l123;
                                                                    let len127 = l124;
                                                                    for i in 0..len127 {
                                                                        let base = base127
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l125 = *base.add(0).cast::<*mut u8>();
                                                                            let l126 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l125, l126, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base127,
                                                                        len127 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                4 => {
                                                                    let l128 = *base.add(8).cast::<*mut u8>();
                                                                    let l129 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base130 = l128;
                                                                    let len130 = l129;
                                                                    _rt::cabi_dealloc(base130, len130 * 4, 4);
                                                                }
                                                                5 => {}
                                                                6 => {}
                                                                7 => {}
                                                                8 => {}
                                                                9 => {}
                                                                10 => {}
                                                                11 => {}
                                                                12 => {}
                                                                13 => {}
                                                                14 => {}
                                                                15 => {}
                                                                16 => {}
                                                                17 => {}
                                                                18 => {}
                                                                19 => {}
                                                                20 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(base131, len131 * 24, 8);
                                                }
                                                _ => {
                                                    let l132 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l133 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    _rt::cabi_dealloc(l132, l133, 1);
                                                }
                                            }
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base134,
                                        len134 * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                                _ => {
                                    let l135 = i32::from(
                                        *base
                                            .add(12 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l135 {
                                        0 => {}
                                        _ => {
                                            let l136 = *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l137 = *base
                                                .add(14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base140 = l136;
                                            let len140 = l137;
                                            for i in 0..len140 {
                                                let base = base140
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let l138 = *base.add(0).cast::<*mut u8>();
                                                    let l139 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    _rt::cabi_dealloc(l138, l139, 1);
                                                }
                                            }
                                            _rt::cabi_dealloc(
                                                base140,
                                                len140 * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(
                        base141,
                        len141 * (15 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l142 = *arg0
                        .add(18 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l143 = *arg0
                        .add(19 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base236 = l142;
                    let len236 = l143;
                    for i in 0..len236 {
                        let base = base236
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l144 = *base.add(0).cast::<*mut u8>();
                            let l145 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l144, l145, 1);
                            let l146 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l147 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base235 = l146;
                            let len235 = l147;
                            for i in 0..len235 {
                                let base = base235
                                    .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l148 = *base.add(0).cast::<*mut u8>();
                                    let l149 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l148, l149, 1);
                                    let l150 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l151 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l150, l151, 1);
                                    let l152 = i32::from(
                                        *base
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l152 {
                                        0 => {}
                                        _ => {
                                            let l153 = *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l154 = *base
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l153, l154, 1);
                                        }
                                    }
                                    let l155 = i32::from(
                                        *base
                                            .add(7 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l155 {
                                        0 => {
                                            let l156 = *base
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l157 = *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base188 = l156;
                                            let len188 = l157;
                                            for i in 0..len188 {
                                                let base = base188
                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let l158 = i32::from(*base.add(0).cast::<u8>());
                                                    match l158 {
                                                        0 => {
                                                            let l159 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l160 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base185 = l159;
                                                            let len185 = l160;
                                                            for i in 0..len185 {
                                                                let base = base185.add(i * 24);
                                                                {
                                                                    let l161 = i32::from(*base.add(0).cast::<u8>());
                                                                    match l161 {
                                                                        0 => {
                                                                            let l162 = *base.add(8).cast::<*mut u8>();
                                                                            let l163 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base166 = l162;
                                                                            let len166 = l163;
                                                                            for i in 0..len166 {
                                                                                let base = base166
                                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l164 = *base.add(0).cast::<*mut u8>();
                                                                                    let l165 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l164, l165, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base166,
                                                                                len166 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        1 => {
                                                                            let l167 = *base.add(8).cast::<*mut u8>();
                                                                            let l168 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base171 = l167;
                                                                            let len171 = l168;
                                                                            for i in 0..len171 {
                                                                                let base = base171
                                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l169 = *base.add(0).cast::<*mut u8>();
                                                                                    let l170 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l169, l170, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base171,
                                                                                len171 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        2 => {
                                                                            let l172 = *base.add(8).cast::<*mut u8>();
                                                                            let l173 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base176 = l172;
                                                                            let len176 = l173;
                                                                            for i in 0..len176 {
                                                                                let base = base176
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l174 = *base.add(0).cast::<*mut u8>();
                                                                                    let l175 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l174, l175, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base176,
                                                                                len176 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        3 => {
                                                                            let l177 = *base.add(8).cast::<*mut u8>();
                                                                            let l178 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base181 = l177;
                                                                            let len181 = l178;
                                                                            for i in 0..len181 {
                                                                                let base = base181
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l179 = *base.add(0).cast::<*mut u8>();
                                                                                    let l180 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l179, l180, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base181,
                                                                                len181 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        4 => {
                                                                            let l182 = *base.add(8).cast::<*mut u8>();
                                                                            let l183 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base184 = l182;
                                                                            let len184 = l183;
                                                                            _rt::cabi_dealloc(base184, len184 * 4, 4);
                                                                        }
                                                                        5 => {}
                                                                        6 => {}
                                                                        7 => {}
                                                                        8 => {}
                                                                        9 => {}
                                                                        10 => {}
                                                                        11 => {}
                                                                        12 => {}
                                                                        13 => {}
                                                                        14 => {}
                                                                        15 => {}
                                                                        16 => {}
                                                                        17 => {}
                                                                        18 => {}
                                                                        19 => {}
                                                                        20 => {}
                                                                        _ => {}
                                                                    }
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(base185, len185 * 24, 8);
                                                        }
                                                        _ => {
                                                            let l186 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l187 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            _rt::cabi_dealloc(l186, l187, 1);
                                                        }
                                                    }
                                                }
                                            }
                                            _rt::cabi_dealloc(
                                                base188,
                                                len188 * (3 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                        }
                                        _ => {
                                            let l189 = i32::from(
                                                *base
                                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            match l189 {
                                                0 => {}
                                                _ => {
                                                    let l190 = *base
                                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l191 = *base
                                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base194 = l190;
                                                    let len194 = l191;
                                                    for i in 0..len194 {
                                                        let base = base194
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let l192 = *base.add(0).cast::<*mut u8>();
                                                            let l193 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            _rt::cabi_dealloc(l192, l193, 1);
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(
                                                        base194,
                                                        len194 * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                }
                                            }
                                        }
                                    }
                                    let l195 = i32::from(
                                        *base
                                            .add(11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l195 {
                                        0 => {
                                            let l196 = *base
                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l197 = *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base228 = l196;
                                            let len228 = l197;
                                            for i in 0..len228 {
                                                let base = base228
                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let l198 = i32::from(*base.add(0).cast::<u8>());
                                                    match l198 {
                                                        0 => {
                                                            let l199 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l200 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base225 = l199;
                                                            let len225 = l200;
                                                            for i in 0..len225 {
                                                                let base = base225.add(i * 24);
                                                                {
                                                                    let l201 = i32::from(*base.add(0).cast::<u8>());
                                                                    match l201 {
                                                                        0 => {
                                                                            let l202 = *base.add(8).cast::<*mut u8>();
                                                                            let l203 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base206 = l202;
                                                                            let len206 = l203;
                                                                            for i in 0..len206 {
                                                                                let base = base206
                                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l204 = *base.add(0).cast::<*mut u8>();
                                                                                    let l205 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l204, l205, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base206,
                                                                                len206 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        1 => {
                                                                            let l207 = *base.add(8).cast::<*mut u8>();
                                                                            let l208 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base211 = l207;
                                                                            let len211 = l208;
                                                                            for i in 0..len211 {
                                                                                let base = base211
                                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l209 = *base.add(0).cast::<*mut u8>();
                                                                                    let l210 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l209, l210, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base211,
                                                                                len211 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        2 => {
                                                                            let l212 = *base.add(8).cast::<*mut u8>();
                                                                            let l213 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base216 = l212;
                                                                            let len216 = l213;
                                                                            for i in 0..len216 {
                                                                                let base = base216
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l214 = *base.add(0).cast::<*mut u8>();
                                                                                    let l215 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l214, l215, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base216,
                                                                                len216 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        3 => {
                                                                            let l217 = *base.add(8).cast::<*mut u8>();
                                                                            let l218 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base221 = l217;
                                                                            let len221 = l218;
                                                                            for i in 0..len221 {
                                                                                let base = base221
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l219 = *base.add(0).cast::<*mut u8>();
                                                                                    let l220 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l219, l220, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base221,
                                                                                len221 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        4 => {
                                                                            let l222 = *base.add(8).cast::<*mut u8>();
                                                                            let l223 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base224 = l222;
                                                                            let len224 = l223;
                                                                            _rt::cabi_dealloc(base224, len224 * 4, 4);
                                                                        }
                                                                        5 => {}
                                                                        6 => {}
                                                                        7 => {}
                                                                        8 => {}
                                                                        9 => {}
                                                                        10 => {}
                                                                        11 => {}
                                                                        12 => {}
                                                                        13 => {}
                                                                        14 => {}
                                                                        15 => {}
                                                                        16 => {}
                                                                        17 => {}
                                                                        18 => {}
                                                                        19 => {}
                                                                        20 => {}
                                                                        _ => {}
                                                                    }
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(base225, len225 * 24, 8);
                                                        }
                                                        _ => {
                                                            let l226 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l227 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            _rt::cabi_dealloc(l226, l227, 1);
                                                        }
                                                    }
                                                }
                                            }
                                            _rt::cabi_dealloc(
                                                base228,
                                                len228 * (3 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                        }
                                        _ => {
                                            let l229 = i32::from(
                                                *base
                                                    .add(12 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            match l229 {
                                                0 => {}
                                                _ => {
                                                    let l230 = *base
                                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l231 = *base
                                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base234 = l230;
                                                    let len234 = l231;
                                                    for i in 0..len234 {
                                                        let base = base234
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let l232 = *base.add(0).cast::<*mut u8>();
                                                            let l233 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            _rt::cabi_dealloc(l232, l233, 1);
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(
                                                        base234,
                                                        len234 * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _rt::cabi_dealloc(
                                base235,
                                len235 * (15 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                    }
                    _rt::cabi_dealloc(
                        base236,
                        len236 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_agent_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::get_agent(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let AgentRef {
                        agent_id: agent_id3,
                        agent_name: agent_name3,
                        agent_handle: agent_handle3,
                    } = result1;
                    let vec4 = (agent_id3.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr2.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = (agent_name3.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *ptr2.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr5.cast_mut();
                    *ptr2.add(4 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                        agent_handle3,
                    );
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_agent<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_discover_agents_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::discover_agents();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec5 = result0;
                    let len5 = vec5.len();
                    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec5.len() * (5 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result5 = if layout5.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout5);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec5.into_iter().enumerate() {
                        let base = result5
                            .add(i * (5 * ::core::mem::size_of::<*const u8>()));
                        {
                            let AgentRef {
                                agent_id: agent_id2,
                                agent_name: agent_name2,
                                agent_handle: agent_handle2,
                            } = e;
                            let vec3 = (agent_id2.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                            let vec4 = (agent_name2.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                            *base
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(agent_handle2);
                        }
                    }
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr1.add(0).cast::<*mut u8>() = result5;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_discover_agents<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base6 = l0;
                    let len6 = l1;
                    for i in 0..len6 {
                        let base = base6
                            .add(i * (5 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                            let l4 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base6,
                        len6 * (5 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_discover_agent_types_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::discover_agent_types();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec152 = result0;
                    let len152 = vec152.len();
                    let layout152 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec152.len() * (20 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result152 = if layout152.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout152).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout152);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec152.into_iter().enumerate() {
                        let base = result152
                            .add(i * (20 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::super::golem::agent::common::AgentType {
                                type_name: type_name2,
                                description: description2,
                                agent_constructor: agent_constructor2,
                                methods: methods2,
                                requires: requires2,
                            } = e;
                            let vec3 = (type_name2.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                            let vec4 = (description2.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                            let super::super::super::super::golem::agent::common::AgentConstructor {
                                name: name5,
                                description: description5,
                                prompt_hint: prompt_hint5,
                                input_schema: input_schema5,
                            } = agent_constructor2;
                            match name5 {
                                Some(e) => {
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                None => {
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec7 = (description5.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *base
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *base
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr7.cast_mut();
                            match prompt_hint5 {
                                Some(e) => {
                                    *base
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *base
                                        .add(11 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *base
                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                None => {
                                    *base
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            use super::super::super::super::golem::agent::common::DataSchema as V34;
                            match input_schema5 {
                                V34::Structured(e) => {
                                    *base
                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                    let super::super::super::super::golem::agent::common::Structured {
                                        parameters: parameters9,
                                    } = e;
                                    let vec29 = parameters9;
                                    let len29 = vec29.len();
                                    let layout29 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec29.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result29 = if layout29.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout29).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout29);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec29.into_iter().enumerate() {
                                        let base = result29
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            use super::super::super::super::golem::agent::common::ParameterType as V28;
                                            match e {
                                                V28::Wit(e) => {
                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                    let super::super::super::super::golem::rpc::types::WitType {
                                                        nodes: nodes10,
                                                    } = e;
                                                    let vec25 = nodes10;
                                                    let len25 = vec25.len();
                                                    let layout25 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec25.len() * 24,
                                                        8,
                                                    );
                                                    let result25 = if layout25.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout25).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout25);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec25.into_iter().enumerate() {
                                                        let base = result25.add(i * 24);
                                                        {
                                                            use super::super::super::super::golem::rpc::types::WitTypeNode as V24;
                                                            match e {
                                                                V24::RecordType(e) => {
                                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                    let vec13 = e;
                                                                    let len13 = vec13.len();
                                                                    let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec13.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result13 = if layout13.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout13);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec13.into_iter().enumerate() {
                                                                        let base = result13
                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let (t11_0, t11_1) = e;
                                                                            let vec12 = (t11_0.into_bytes()).into_boxed_slice();
                                                                            let ptr12 = vec12.as_ptr().cast::<u8>();
                                                                            let len12 = vec12.len();
                                                                            ::core::mem::forget(vec12);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len12;
                                                                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                                                                            *base
                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<i32>() = _rt::as_i32(t11_1);
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len13;
                                                                    *base.add(8).cast::<*mut u8>() = result13;
                                                                }
                                                                V24::VariantType(e) => {
                                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                    let vec16 = e;
                                                                    let len16 = vec16.len();
                                                                    let layout16 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec16.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result16 = if layout16.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout16).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout16);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec16.into_iter().enumerate() {
                                                                        let base = result16
                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let (t14_0, t14_1) = e;
                                                                            let vec15 = (t14_0.into_bytes()).into_boxed_slice();
                                                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                                                            let len15 = vec15.len();
                                                                            ::core::mem::forget(vec15);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len15;
                                                                            *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                                                                            match t14_1 {
                                                                                Some(e) => {
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<u8>() = (1i32) as u8;
                                                                                    *base
                                                                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len16;
                                                                    *base.add(8).cast::<*mut u8>() = result16;
                                                                }
                                                                V24::EnumType(e) => {
                                                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                    let vec18 = e;
                                                                    let len18 = vec18.len();
                                                                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec18.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result18 = if layout18.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout18);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec18.into_iter().enumerate() {
                                                                        let base = result18
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let vec17 = (e.into_bytes()).into_boxed_slice();
                                                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                                                            let len17 = vec17.len();
                                                                            ::core::mem::forget(vec17);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len17;
                                                                            *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len18;
                                                                    *base.add(8).cast::<*mut u8>() = result18;
                                                                }
                                                                V24::FlagsType(e) => {
                                                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                    let vec20 = e;
                                                                    let len20 = vec20.len();
                                                                    let layout20 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec20.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                    let result20 = if layout20.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout20).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout20);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec20.into_iter().enumerate() {
                                                                        let base = result20
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let vec19 = (e.into_bytes()).into_boxed_slice();
                                                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                                                            let len19 = vec19.len();
                                                                            ::core::mem::forget(vec19);
                                                                            *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len19;
                                                                            *base.add(0).cast::<*mut u8>() = ptr19.cast_mut();
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len20;
                                                                    *base.add(8).cast::<*mut u8>() = result20;
                                                                }
                                                                V24::TupleType(e) => {
                                                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                    let vec21 = (e).into_boxed_slice();
                                                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                                                    let len21 = vec21.len();
                                                                    ::core::mem::forget(vec21);
                                                                    *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len21;
                                                                    *base.add(8).cast::<*mut u8>() = ptr21.cast_mut();
                                                                }
                                                                V24::ListType(e) => {
                                                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                }
                                                                V24::OptionType(e) => {
                                                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                }
                                                                V24::ResultType(e) => {
                                                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                    let (t22_0, t22_1) = e;
                                                                    match t22_0 {
                                                                        Some(e) => {
                                                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        None => {
                                                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                        }
                                                                    };
                                                                    match t22_1 {
                                                                        Some(e) => {
                                                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        None => {
                                                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                        }
                                                                    };
                                                                }
                                                                V24::PrimU8Type => {
                                                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                }
                                                                V24::PrimU16Type => {
                                                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                }
                                                                V24::PrimU32Type => {
                                                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                }
                                                                V24::PrimU64Type => {
                                                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                }
                                                                V24::PrimS8Type => {
                                                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                }
                                                                V24::PrimS16Type => {
                                                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                }
                                                                V24::PrimS32Type => {
                                                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                }
                                                                V24::PrimS64Type => {
                                                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                }
                                                                V24::PrimF32Type => {
                                                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                }
                                                                V24::PrimF64Type => {
                                                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                }
                                                                V24::PrimCharType => {
                                                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                }
                                                                V24::PrimBoolType => {
                                                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                }
                                                                V24::PrimStringType => {
                                                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                }
                                                                V24::HandleType(e) => {
                                                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                    let (t23_0, t23_1) = e;
                                                                    *base.add(8).cast::<i64>() = _rt::as_i64(t23_0);
                                                                    *base.add(16).cast::<u8>() = (t23_1.clone() as i32) as u8;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len25;
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result25;
                                                }
                                                V28::Text(e) => {
                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                    let super::super::super::super::golem::agent::common::TextType {
                                                        language_code: language_code26,
                                                    } = e;
                                                    let vec27 = (language_code26.into_bytes())
                                                        .into_boxed_slice();
                                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                                    let len27 = vec27.len();
                                                    ::core::mem::forget(vec27);
                                                    *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len27;
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = ptr27.cast_mut();
                                                }
                                            }
                                        }
                                    }
                                    *base
                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len29;
                                    *base
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result29;
                                }
                                V34::Multimodal(e) => {
                                    *base
                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::golem::agent::common::Multimodal {
                                        text: text30,
                                    } = e;
                                    match text30 {
                                        Some(e) => {
                                            *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec33 = e;
                                            let len33 = vec33.len();
                                            let layout33 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec33.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result33 = if layout33.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout33).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout33);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec33.into_iter().enumerate() {
                                                let base = result33
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let super::super::super::super::golem::agent::common::TextType {
                                                        language_code: language_code31,
                                                    } = e;
                                                    let vec32 = (language_code31.into_bytes())
                                                        .into_boxed_slice();
                                                    let ptr32 = vec32.as_ptr().cast::<u8>();
                                                    let len32 = vec32.len();
                                                    ::core::mem::forget(vec32);
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len32;
                                                    *base.add(0).cast::<*mut u8>() = ptr32.cast_mut();
                                                }
                                            }
                                            *base
                                                .add(15 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len33;
                                            *base
                                                .add(14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result33;
                                        }
                                        None => {
                                            *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                            }
                            let vec91 = methods2;
                            let len91 = vec91.len();
                            let layout91 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec91.len() * (15 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result91 = if layout91.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout91).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout91);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec91.into_iter().enumerate() {
                                let base = result91
                                    .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::golem::agent::common::AgentMethod {
                                        name: name35,
                                        description: description35,
                                        prompt_hint: prompt_hint35,
                                        input_schema: input_schema35,
                                        output_schema: output_schema35,
                                    } = e;
                                    let vec36 = (name35.into_bytes()).into_boxed_slice();
                                    let ptr36 = vec36.as_ptr().cast::<u8>();
                                    let len36 = vec36.len();
                                    ::core::mem::forget(vec36);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len36;
                                    *base.add(0).cast::<*mut u8>() = ptr36.cast_mut();
                                    let vec37 = (description35.into_bytes()).into_boxed_slice();
                                    let ptr37 = vec37.as_ptr().cast::<u8>();
                                    let len37 = vec37.len();
                                    ::core::mem::forget(vec37);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len37;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr37.cast_mut();
                                    match prompt_hint35 {
                                        Some(e) => {
                                            *base
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec38 = (e.into_bytes()).into_boxed_slice();
                                            let ptr38 = vec38.as_ptr().cast::<u8>();
                                            let len38 = vec38.len();
                                            ::core::mem::forget(vec38);
                                            *base
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len38;
                                            *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr38.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    use super::super::super::super::golem::agent::common::DataSchema as V64;
                                    match input_schema35 {
                                        V64::Structured(e) => {
                                            *base
                                                .add(7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                            let super::super::super::super::golem::agent::common::Structured {
                                                parameters: parameters39,
                                            } = e;
                                            let vec59 = parameters39;
                                            let len59 = vec59.len();
                                            let layout59 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec59.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result59 = if layout59.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout59).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout59);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec59.into_iter().enumerate() {
                                                let base = result59
                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    use super::super::super::super::golem::agent::common::ParameterType as V58;
                                                    match e {
                                                        V58::Wit(e) => {
                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                            let super::super::super::super::golem::rpc::types::WitType {
                                                                nodes: nodes40,
                                                            } = e;
                                                            let vec55 = nodes40;
                                                            let len55 = vec55.len();
                                                            let layout55 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec55.len() * 24,
                                                                8,
                                                            );
                                                            let result55 = if layout55.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout55).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout55);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec55.into_iter().enumerate() {
                                                                let base = result55.add(i * 24);
                                                                {
                                                                    use super::super::super::super::golem::rpc::types::WitTypeNode as V54;
                                                                    match e {
                                                                        V54::RecordType(e) => {
                                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                            let vec43 = e;
                                                                            let len43 = vec43.len();
                                                                            let layout43 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec43.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result43 = if layout43.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout43).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout43);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec43.into_iter().enumerate() {
                                                                                let base = result43
                                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let (t41_0, t41_1) = e;
                                                                                    let vec42 = (t41_0.into_bytes()).into_boxed_slice();
                                                                                    let ptr42 = vec42.as_ptr().cast::<u8>();
                                                                                    let len42 = vec42.len();
                                                                                    ::core::mem::forget(vec42);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len42;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr42.cast_mut();
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<i32>() = _rt::as_i32(t41_1);
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len43;
                                                                            *base.add(8).cast::<*mut u8>() = result43;
                                                                        }
                                                                        V54::VariantType(e) => {
                                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                            let vec46 = e;
                                                                            let len46 = vec46.len();
                                                                            let layout46 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec46.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result46 = if layout46.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout46).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout46);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec46.into_iter().enumerate() {
                                                                                let base = result46
                                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let (t44_0, t44_1) = e;
                                                                                    let vec45 = (t44_0.into_bytes()).into_boxed_slice();
                                                                                    let ptr45 = vec45.as_ptr().cast::<u8>();
                                                                                    let len45 = vec45.len();
                                                                                    ::core::mem::forget(vec45);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len45;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr45.cast_mut();
                                                                                    match t44_1 {
                                                                                        Some(e) => {
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>() = (1i32) as u8;
                                                                                            *base
                                                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<i32>() = _rt::as_i32(e);
                                                                                        }
                                                                                        None => {
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                    };
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len46;
                                                                            *base.add(8).cast::<*mut u8>() = result46;
                                                                        }
                                                                        V54::EnumType(e) => {
                                                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                            let vec48 = e;
                                                                            let len48 = vec48.len();
                                                                            let layout48 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec48.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result48 = if layout48.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout48).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout48);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec48.into_iter().enumerate() {
                                                                                let base = result48
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let vec47 = (e.into_bytes()).into_boxed_slice();
                                                                                    let ptr47 = vec47.as_ptr().cast::<u8>();
                                                                                    let len47 = vec47.len();
                                                                                    ::core::mem::forget(vec47);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len47;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr47.cast_mut();
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len48;
                                                                            *base.add(8).cast::<*mut u8>() = result48;
                                                                        }
                                                                        V54::FlagsType(e) => {
                                                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                            let vec50 = e;
                                                                            let len50 = vec50.len();
                                                                            let layout50 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec50.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result50 = if layout50.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout50).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout50);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec50.into_iter().enumerate() {
                                                                                let base = result50
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let vec49 = (e.into_bytes()).into_boxed_slice();
                                                                                    let ptr49 = vec49.as_ptr().cast::<u8>();
                                                                                    let len49 = vec49.len();
                                                                                    ::core::mem::forget(vec49);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len49;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr49.cast_mut();
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len50;
                                                                            *base.add(8).cast::<*mut u8>() = result50;
                                                                        }
                                                                        V54::TupleType(e) => {
                                                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                            let vec51 = (e).into_boxed_slice();
                                                                            let ptr51 = vec51.as_ptr().cast::<u8>();
                                                                            let len51 = vec51.len();
                                                                            ::core::mem::forget(vec51);
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len51;
                                                                            *base.add(8).cast::<*mut u8>() = ptr51.cast_mut();
                                                                        }
                                                                        V54::ListType(e) => {
                                                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        V54::OptionType(e) => {
                                                                            *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        V54::ResultType(e) => {
                                                                            *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                            let (t52_0, t52_1) = e;
                                                                            match t52_0 {
                                                                                Some(e) => {
                                                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                                    *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                            match t52_1 {
                                                                                Some(e) => {
                                                                                    *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                                    *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                        }
                                                                        V54::PrimU8Type => {
                                                                            *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                        }
                                                                        V54::PrimU16Type => {
                                                                            *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                        }
                                                                        V54::PrimU32Type => {
                                                                            *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                        }
                                                                        V54::PrimU64Type => {
                                                                            *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                        }
                                                                        V54::PrimS8Type => {
                                                                            *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                        }
                                                                        V54::PrimS16Type => {
                                                                            *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                        }
                                                                        V54::PrimS32Type => {
                                                                            *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                        }
                                                                        V54::PrimS64Type => {
                                                                            *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                        }
                                                                        V54::PrimF32Type => {
                                                                            *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                        }
                                                                        V54::PrimF64Type => {
                                                                            *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                        }
                                                                        V54::PrimCharType => {
                                                                            *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                        }
                                                                        V54::PrimBoolType => {
                                                                            *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                        }
                                                                        V54::PrimStringType => {
                                                                            *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                        }
                                                                        V54::HandleType(e) => {
                                                                            *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                            let (t53_0, t53_1) = e;
                                                                            *base.add(8).cast::<i64>() = _rt::as_i64(t53_0);
                                                                            *base.add(16).cast::<u8>() = (t53_1.clone() as i32) as u8;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len55;
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = result55;
                                                        }
                                                        V58::Text(e) => {
                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                            let super::super::super::super::golem::agent::common::TextType {
                                                                language_code: language_code56,
                                                            } = e;
                                                            let vec57 = (language_code56.into_bytes())
                                                                .into_boxed_slice();
                                                            let ptr57 = vec57.as_ptr().cast::<u8>();
                                                            let len57 = vec57.len();
                                                            ::core::mem::forget(vec57);
                                                            *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len57;
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = ptr57.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len59;
                                            *base
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result59;
                                        }
                                        V64::Multimodal(e) => {
                                            *base
                                                .add(7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::golem::agent::common::Multimodal {
                                                text: text60,
                                            } = e;
                                            match text60 {
                                                Some(e) => {
                                                    *base
                                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    let vec63 = e;
                                                    let len63 = vec63.len();
                                                    let layout63 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec63.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                    let result63 = if layout63.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout63).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout63);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec63.into_iter().enumerate() {
                                                        let base = result63
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let super::super::super::super::golem::agent::common::TextType {
                                                                language_code: language_code61,
                                                            } = e;
                                                            let vec62 = (language_code61.into_bytes())
                                                                .into_boxed_slice();
                                                            let ptr62 = vec62.as_ptr().cast::<u8>();
                                                            let len62 = vec62.len();
                                                            ::core::mem::forget(vec62);
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len62;
                                                            *base.add(0).cast::<*mut u8>() = ptr62.cast_mut();
                                                        }
                                                    }
                                                    *base
                                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len63;
                                                    *base
                                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result63;
                                                }
                                                None => {
                                                    *base
                                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                    }
                                    use super::super::super::super::golem::agent::common::DataSchema as V90;
                                    match output_schema35 {
                                        V90::Structured(e) => {
                                            *base
                                                .add(11 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                            let super::super::super::super::golem::agent::common::Structured {
                                                parameters: parameters65,
                                            } = e;
                                            let vec85 = parameters65;
                                            let len85 = vec85.len();
                                            let layout85 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec85.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result85 = if layout85.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout85).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout85);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec85.into_iter().enumerate() {
                                                let base = result85
                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    use super::super::super::super::golem::agent::common::ParameterType as V84;
                                                    match e {
                                                        V84::Wit(e) => {
                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                            let super::super::super::super::golem::rpc::types::WitType {
                                                                nodes: nodes66,
                                                            } = e;
                                                            let vec81 = nodes66;
                                                            let len81 = vec81.len();
                                                            let layout81 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec81.len() * 24,
                                                                8,
                                                            );
                                                            let result81 = if layout81.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout81).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout81);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec81.into_iter().enumerate() {
                                                                let base = result81.add(i * 24);
                                                                {
                                                                    use super::super::super::super::golem::rpc::types::WitTypeNode as V80;
                                                                    match e {
                                                                        V80::RecordType(e) => {
                                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                            let vec69 = e;
                                                                            let len69 = vec69.len();
                                                                            let layout69 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec69.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result69 = if layout69.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout69).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout69);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec69.into_iter().enumerate() {
                                                                                let base = result69
                                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let (t67_0, t67_1) = e;
                                                                                    let vec68 = (t67_0.into_bytes()).into_boxed_slice();
                                                                                    let ptr68 = vec68.as_ptr().cast::<u8>();
                                                                                    let len68 = vec68.len();
                                                                                    ::core::mem::forget(vec68);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len68;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr68.cast_mut();
                                                                                    *base
                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<i32>() = _rt::as_i32(t67_1);
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len69;
                                                                            *base.add(8).cast::<*mut u8>() = result69;
                                                                        }
                                                                        V80::VariantType(e) => {
                                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                            let vec72 = e;
                                                                            let len72 = vec72.len();
                                                                            let layout72 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec72.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result72 = if layout72.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout72).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout72);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec72.into_iter().enumerate() {
                                                                                let base = result72
                                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let (t70_0, t70_1) = e;
                                                                                    let vec71 = (t70_0.into_bytes()).into_boxed_slice();
                                                                                    let ptr71 = vec71.as_ptr().cast::<u8>();
                                                                                    let len71 = vec71.len();
                                                                                    ::core::mem::forget(vec71);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len71;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr71.cast_mut();
                                                                                    match t70_1 {
                                                                                        Some(e) => {
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>() = (1i32) as u8;
                                                                                            *base
                                                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<i32>() = _rt::as_i32(e);
                                                                                        }
                                                                                        None => {
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                    };
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len72;
                                                                            *base.add(8).cast::<*mut u8>() = result72;
                                                                        }
                                                                        V80::EnumType(e) => {
                                                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                            let vec74 = e;
                                                                            let len74 = vec74.len();
                                                                            let layout74 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec74.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result74 = if layout74.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout74).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout74);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec74.into_iter().enumerate() {
                                                                                let base = result74
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let vec73 = (e.into_bytes()).into_boxed_slice();
                                                                                    let ptr73 = vec73.as_ptr().cast::<u8>();
                                                                                    let len73 = vec73.len();
                                                                                    ::core::mem::forget(vec73);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len73;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr73.cast_mut();
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len74;
                                                                            *base.add(8).cast::<*mut u8>() = result74;
                                                                        }
                                                                        V80::FlagsType(e) => {
                                                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                            let vec76 = e;
                                                                            let len76 = vec76.len();
                                                                            let layout76 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                vec76.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                            let result76 = if layout76.size() != 0 {
                                                                                let ptr = _rt::alloc::alloc(layout76).cast::<u8>();
                                                                                if ptr.is_null() {
                                                                                    _rt::alloc::handle_alloc_error(layout76);
                                                                                }
                                                                                ptr
                                                                            } else {
                                                                                ::core::ptr::null_mut()
                                                                            };
                                                                            for (i, e) in vec76.into_iter().enumerate() {
                                                                                let base = result76
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let vec75 = (e.into_bytes()).into_boxed_slice();
                                                                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                                                                    let len75 = vec75.len();
                                                                                    ::core::mem::forget(vec75);
                                                                                    *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len75;
                                                                                    *base.add(0).cast::<*mut u8>() = ptr75.cast_mut();
                                                                                }
                                                                            }
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len76;
                                                                            *base.add(8).cast::<*mut u8>() = result76;
                                                                        }
                                                                        V80::TupleType(e) => {
                                                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                            let vec77 = (e).into_boxed_slice();
                                                                            let ptr77 = vec77.as_ptr().cast::<u8>();
                                                                            let len77 = vec77.len();
                                                                            ::core::mem::forget(vec77);
                                                                            *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>() = len77;
                                                                            *base.add(8).cast::<*mut u8>() = ptr77.cast_mut();
                                                                        }
                                                                        V80::ListType(e) => {
                                                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        V80::OptionType(e) => {
                                                                            *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                            *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                        }
                                                                        V80::ResultType(e) => {
                                                                            *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                            let (t78_0, t78_1) = e;
                                                                            match t78_0 {
                                                                                Some(e) => {
                                                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                                    *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                            match t78_1 {
                                                                                Some(e) => {
                                                                                    *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                                    *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                None => {
                                                                                    *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                            };
                                                                        }
                                                                        V80::PrimU8Type => {
                                                                            *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                        }
                                                                        V80::PrimU16Type => {
                                                                            *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                        }
                                                                        V80::PrimU32Type => {
                                                                            *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                        }
                                                                        V80::PrimU64Type => {
                                                                            *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                        }
                                                                        V80::PrimS8Type => {
                                                                            *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                        }
                                                                        V80::PrimS16Type => {
                                                                            *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                        }
                                                                        V80::PrimS32Type => {
                                                                            *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                        }
                                                                        V80::PrimS64Type => {
                                                                            *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                        }
                                                                        V80::PrimF32Type => {
                                                                            *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                        }
                                                                        V80::PrimF64Type => {
                                                                            *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                        }
                                                                        V80::PrimCharType => {
                                                                            *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                        }
                                                                        V80::PrimBoolType => {
                                                                            *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                        }
                                                                        V80::PrimStringType => {
                                                                            *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                        }
                                                                        V80::HandleType(e) => {
                                                                            *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                            let (t79_0, t79_1) = e;
                                                                            *base.add(8).cast::<i64>() = _rt::as_i64(t79_0);
                                                                            *base.add(16).cast::<u8>() = (t79_1.clone() as i32) as u8;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len81;
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = result81;
                                                        }
                                                        V84::Text(e) => {
                                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                                            let super::super::super::super::golem::agent::common::TextType {
                                                                language_code: language_code82,
                                                            } = e;
                                                            let vec83 = (language_code82.into_bytes())
                                                                .into_boxed_slice();
                                                            let ptr83 = vec83.as_ptr().cast::<u8>();
                                                            let len83 = vec83.len();
                                                            ::core::mem::forget(vec83);
                                                            *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len83;
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = ptr83.cast_mut();
                                                        }
                                                    }
                                                }
                                            }
                                            *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len85;
                                            *base
                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result85;
                                        }
                                        V90::Multimodal(e) => {
                                            *base
                                                .add(11 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::golem::agent::common::Multimodal {
                                                text: text86,
                                            } = e;
                                            match text86 {
                                                Some(e) => {
                                                    *base
                                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    let vec89 = e;
                                                    let len89 = vec89.len();
                                                    let layout89 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec89.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                    let result89 = if layout89.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout89).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout89);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec89.into_iter().enumerate() {
                                                        let base = result89
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let super::super::super::super::golem::agent::common::TextType {
                                                                language_code: language_code87,
                                                            } = e;
                                                            let vec88 = (language_code87.into_bytes())
                                                                .into_boxed_slice();
                                                            let ptr88 = vec88.as_ptr().cast::<u8>();
                                                            let len88 = vec88.len();
                                                            ::core::mem::forget(vec88);
                                                            *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len88;
                                                            *base.add(0).cast::<*mut u8>() = ptr88.cast_mut();
                                                        }
                                                    }
                                                    *base
                                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len89;
                                                    *base
                                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result89;
                                                }
                                                None => {
                                                    *base
                                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                    }
                                }
                            }
                            *base
                                .add(17 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len91;
                            *base
                                .add(16 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result91;
                            let vec151 = requires2;
                            let len151 = vec151.len();
                            let layout151 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec151.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result151 = if layout151.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout151).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout151);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec151.into_iter().enumerate() {
                                let base = result151
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::golem::agent::common::AgentDependency {
                                        agent_name: agent_name92,
                                        methods: methods92,
                                    } = e;
                                    let vec93 = (agent_name92.into_bytes()).into_boxed_slice();
                                    let ptr93 = vec93.as_ptr().cast::<u8>();
                                    let len93 = vec93.len();
                                    ::core::mem::forget(vec93);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len93;
                                    *base.add(0).cast::<*mut u8>() = ptr93.cast_mut();
                                    let vec150 = methods92;
                                    let len150 = vec150.len();
                                    let layout150 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec150.len() * (15 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result150 = if layout150.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout150).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout150);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec150.into_iter().enumerate() {
                                        let base = result150
                                            .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let super::super::super::super::golem::agent::common::AgentMethod {
                                                name: name94,
                                                description: description94,
                                                prompt_hint: prompt_hint94,
                                                input_schema: input_schema94,
                                                output_schema: output_schema94,
                                            } = e;
                                            let vec95 = (name94.into_bytes()).into_boxed_slice();
                                            let ptr95 = vec95.as_ptr().cast::<u8>();
                                            let len95 = vec95.len();
                                            ::core::mem::forget(vec95);
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len95;
                                            *base.add(0).cast::<*mut u8>() = ptr95.cast_mut();
                                            let vec96 = (description94.into_bytes()).into_boxed_slice();
                                            let ptr96 = vec96.as_ptr().cast::<u8>();
                                            let len96 = vec96.len();
                                            ::core::mem::forget(vec96);
                                            *base
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len96;
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr96.cast_mut();
                                            match prompt_hint94 {
                                                Some(e) => {
                                                    *base
                                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    let vec97 = (e.into_bytes()).into_boxed_slice();
                                                    let ptr97 = vec97.as_ptr().cast::<u8>();
                                                    let len97 = vec97.len();
                                                    ::core::mem::forget(vec97);
                                                    *base
                                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len97;
                                                    *base
                                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = ptr97.cast_mut();
                                                }
                                                None => {
                                                    *base
                                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            use super::super::super::super::golem::agent::common::DataSchema as V123;
                                            match input_schema94 {
                                                V123::Structured(e) => {
                                                    *base
                                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                    let super::super::super::super::golem::agent::common::Structured {
                                                        parameters: parameters98,
                                                    } = e;
                                                    let vec118 = parameters98;
                                                    let len118 = vec118.len();
                                                    let layout118 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec118.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                    let result118 = if layout118.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout118).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout118);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec118.into_iter().enumerate() {
                                                        let base = result118
                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            use super::super::super::super::golem::agent::common::ParameterType as V117;
                                                            match e {
                                                                V117::Wit(e) => {
                                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                    let super::super::super::super::golem::rpc::types::WitType {
                                                                        nodes: nodes99,
                                                                    } = e;
                                                                    let vec114 = nodes99;
                                                                    let len114 = vec114.len();
                                                                    let layout114 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec114.len() * 24,
                                                                        8,
                                                                    );
                                                                    let result114 = if layout114.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout114).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout114);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec114.into_iter().enumerate() {
                                                                        let base = result114.add(i * 24);
                                                                        {
                                                                            use super::super::super::super::golem::rpc::types::WitTypeNode as V113;
                                                                            match e {
                                                                                V113::RecordType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                                    let vec102 = e;
                                                                                    let len102 = vec102.len();
                                                                                    let layout102 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                        vec102.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                    let result102 = if layout102.size() != 0 {
                                                                                        let ptr = _rt::alloc::alloc(layout102).cast::<u8>();
                                                                                        if ptr.is_null() {
                                                                                            _rt::alloc::handle_alloc_error(layout102);
                                                                                        }
                                                                                        ptr
                                                                                    } else {
                                                                                        ::core::ptr::null_mut()
                                                                                    };
                                                                                    for (i, e) in vec102.into_iter().enumerate() {
                                                                                        let base = result102
                                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let (t100_0, t100_1) = e;
                                                                                            let vec101 = (t100_0.into_bytes()).into_boxed_slice();
                                                                                            let ptr101 = vec101.as_ptr().cast::<u8>();
                                                                                            let len101 = vec101.len();
                                                                                            ::core::mem::forget(vec101);
                                                                                            *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>() = len101;
                                                                                            *base.add(0).cast::<*mut u8>() = ptr101.cast_mut();
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<i32>() = _rt::as_i32(t100_1);
                                                                                        }
                                                                                    }
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len102;
                                                                                    *base.add(8).cast::<*mut u8>() = result102;
                                                                                }
                                                                                V113::VariantType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                                    let vec105 = e;
                                                                                    let len105 = vec105.len();
                                                                                    let layout105 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                        vec105.len()
                                                                                            * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                    let result105 = if layout105.size() != 0 {
                                                                                        let ptr = _rt::alloc::alloc(layout105).cast::<u8>();
                                                                                        if ptr.is_null() {
                                                                                            _rt::alloc::handle_alloc_error(layout105);
                                                                                        }
                                                                                        ptr
                                                                                    } else {
                                                                                        ::core::ptr::null_mut()
                                                                                    };
                                                                                    for (i, e) in vec105.into_iter().enumerate() {
                                                                                        let base = result105
                                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let (t103_0, t103_1) = e;
                                                                                            let vec104 = (t103_0.into_bytes()).into_boxed_slice();
                                                                                            let ptr104 = vec104.as_ptr().cast::<u8>();
                                                                                            let len104 = vec104.len();
                                                                                            ::core::mem::forget(vec104);
                                                                                            *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>() = len104;
                                                                                            *base.add(0).cast::<*mut u8>() = ptr104.cast_mut();
                                                                                            match t103_1 {
                                                                                                Some(e) => {
                                                                                                    *base
                                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<u8>() = (1i32) as u8;
                                                                                                    *base
                                                                                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<i32>() = _rt::as_i32(e);
                                                                                                }
                                                                                                None => {
                                                                                                    *base
                                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<u8>() = (0i32) as u8;
                                                                                                }
                                                                                            };
                                                                                        }
                                                                                    }
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len105;
                                                                                    *base.add(8).cast::<*mut u8>() = result105;
                                                                                }
                                                                                V113::EnumType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                                    let vec107 = e;
                                                                                    let len107 = vec107.len();
                                                                                    let layout107 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                        vec107.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                    let result107 = if layout107.size() != 0 {
                                                                                        let ptr = _rt::alloc::alloc(layout107).cast::<u8>();
                                                                                        if ptr.is_null() {
                                                                                            _rt::alloc::handle_alloc_error(layout107);
                                                                                        }
                                                                                        ptr
                                                                                    } else {
                                                                                        ::core::ptr::null_mut()
                                                                                    };
                                                                                    for (i, e) in vec107.into_iter().enumerate() {
                                                                                        let base = result107
                                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let vec106 = (e.into_bytes()).into_boxed_slice();
                                                                                            let ptr106 = vec106.as_ptr().cast::<u8>();
                                                                                            let len106 = vec106.len();
                                                                                            ::core::mem::forget(vec106);
                                                                                            *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>() = len106;
                                                                                            *base.add(0).cast::<*mut u8>() = ptr106.cast_mut();
                                                                                        }
                                                                                    }
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len107;
                                                                                    *base.add(8).cast::<*mut u8>() = result107;
                                                                                }
                                                                                V113::FlagsType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                                    let vec109 = e;
                                                                                    let len109 = vec109.len();
                                                                                    let layout109 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                        vec109.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                    let result109 = if layout109.size() != 0 {
                                                                                        let ptr = _rt::alloc::alloc(layout109).cast::<u8>();
                                                                                        if ptr.is_null() {
                                                                                            _rt::alloc::handle_alloc_error(layout109);
                                                                                        }
                                                                                        ptr
                                                                                    } else {
                                                                                        ::core::ptr::null_mut()
                                                                                    };
                                                                                    for (i, e) in vec109.into_iter().enumerate() {
                                                                                        let base = result109
                                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let vec108 = (e.into_bytes()).into_boxed_slice();
                                                                                            let ptr108 = vec108.as_ptr().cast::<u8>();
                                                                                            let len108 = vec108.len();
                                                                                            ::core::mem::forget(vec108);
                                                                                            *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>() = len108;
                                                                                            *base.add(0).cast::<*mut u8>() = ptr108.cast_mut();
                                                                                        }
                                                                                    }
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len109;
                                                                                    *base.add(8).cast::<*mut u8>() = result109;
                                                                                }
                                                                                V113::TupleType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                                    let vec110 = (e).into_boxed_slice();
                                                                                    let ptr110 = vec110.as_ptr().cast::<u8>();
                                                                                    let len110 = vec110.len();
                                                                                    ::core::mem::forget(vec110);
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len110;
                                                                                    *base.add(8).cast::<*mut u8>() = ptr110.cast_mut();
                                                                                }
                                                                                V113::ListType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                V113::OptionType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                V113::ResultType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                                    let (t111_0, t111_1) = e;
                                                                                    match t111_0 {
                                                                                        Some(e) => {
                                                                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                        }
                                                                                        None => {
                                                                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                    };
                                                                                    match t111_1 {
                                                                                        Some(e) => {
                                                                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                                        }
                                                                                        None => {
                                                                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                    };
                                                                                }
                                                                                V113::PrimU8Type => {
                                                                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                                }
                                                                                V113::PrimU16Type => {
                                                                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                                }
                                                                                V113::PrimU32Type => {
                                                                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                                }
                                                                                V113::PrimU64Type => {
                                                                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                                }
                                                                                V113::PrimS8Type => {
                                                                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                                }
                                                                                V113::PrimS16Type => {
                                                                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                                }
                                                                                V113::PrimS32Type => {
                                                                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                                }
                                                                                V113::PrimS64Type => {
                                                                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                                }
                                                                                V113::PrimF32Type => {
                                                                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                                }
                                                                                V113::PrimF64Type => {
                                                                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                                }
                                                                                V113::PrimCharType => {
                                                                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                                }
                                                                                V113::PrimBoolType => {
                                                                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                                }
                                                                                V113::PrimStringType => {
                                                                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                                }
                                                                                V113::HandleType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                                    let (t112_0, t112_1) = e;
                                                                                    *base.add(8).cast::<i64>() = _rt::as_i64(t112_0);
                                                                                    *base.add(16).cast::<u8>() = (t112_1.clone() as i32) as u8;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len114;
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>() = result114;
                                                                }
                                                                V117::Text(e) => {
                                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                    let super::super::super::super::golem::agent::common::TextType {
                                                                        language_code: language_code115,
                                                                    } = e;
                                                                    let vec116 = (language_code115.into_bytes())
                                                                        .into_boxed_slice();
                                                                    let ptr116 = vec116.as_ptr().cast::<u8>();
                                                                    let len116 = vec116.len();
                                                                    ::core::mem::forget(vec116);
                                                                    *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len116;
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>() = ptr116.cast_mut();
                                                                }
                                                            }
                                                        }
                                                    }
                                                    *base
                                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len118;
                                                    *base
                                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result118;
                                                }
                                                V123::Multimodal(e) => {
                                                    *base
                                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    let super::super::super::super::golem::agent::common::Multimodal {
                                                        text: text119,
                                                    } = e;
                                                    match text119 {
                                                        Some(e) => {
                                                            *base
                                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>() = (1i32) as u8;
                                                            let vec122 = e;
                                                            let len122 = vec122.len();
                                                            let layout122 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec122.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                            let result122 = if layout122.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout122).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout122);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec122.into_iter().enumerate() {
                                                                let base = result122
                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let super::super::super::super::golem::agent::common::TextType {
                                                                        language_code: language_code120,
                                                                    } = e;
                                                                    let vec121 = (language_code120.into_bytes())
                                                                        .into_boxed_slice();
                                                                    let ptr121 = vec121.as_ptr().cast::<u8>();
                                                                    let len121 = vec121.len();
                                                                    ::core::mem::forget(vec121);
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len121;
                                                                    *base.add(0).cast::<*mut u8>() = ptr121.cast_mut();
                                                                }
                                                            }
                                                            *base
                                                                .add(10 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len122;
                                                            *base
                                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = result122;
                                                        }
                                                        None => {
                                                            *base
                                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>() = (0i32) as u8;
                                                        }
                                                    };
                                                }
                                            }
                                            use super::super::super::super::golem::agent::common::DataSchema as V149;
                                            match output_schema94 {
                                                V149::Structured(e) => {
                                                    *base
                                                        .add(11 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                    let super::super::super::super::golem::agent::common::Structured {
                                                        parameters: parameters124,
                                                    } = e;
                                                    let vec144 = parameters124;
                                                    let len144 = vec144.len();
                                                    let layout144 = _rt::alloc::Layout::from_size_align_unchecked(
                                                        vec144.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                    let result144 = if layout144.size() != 0 {
                                                        let ptr = _rt::alloc::alloc(layout144).cast::<u8>();
                                                        if ptr.is_null() {
                                                            _rt::alloc::handle_alloc_error(layout144);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec144.into_iter().enumerate() {
                                                        let base = result144
                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            use super::super::super::super::golem::agent::common::ParameterType as V143;
                                                            match e {
                                                                V143::Wit(e) => {
                                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                    let super::super::super::super::golem::rpc::types::WitType {
                                                                        nodes: nodes125,
                                                                    } = e;
                                                                    let vec140 = nodes125;
                                                                    let len140 = vec140.len();
                                                                    let layout140 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                        vec140.len() * 24,
                                                                        8,
                                                                    );
                                                                    let result140 = if layout140.size() != 0 {
                                                                        let ptr = _rt::alloc::alloc(layout140).cast::<u8>();
                                                                        if ptr.is_null() {
                                                                            _rt::alloc::handle_alloc_error(layout140);
                                                                        }
                                                                        ptr
                                                                    } else {
                                                                        ::core::ptr::null_mut()
                                                                    };
                                                                    for (i, e) in vec140.into_iter().enumerate() {
                                                                        let base = result140.add(i * 24);
                                                                        {
                                                                            use super::super::super::super::golem::rpc::types::WitTypeNode as V139;
                                                                            match e {
                                                                                V139::RecordType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                                    let vec128 = e;
                                                                                    let len128 = vec128.len();
                                                                                    let layout128 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                        vec128.len() * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                    let result128 = if layout128.size() != 0 {
                                                                                        let ptr = _rt::alloc::alloc(layout128).cast::<u8>();
                                                                                        if ptr.is_null() {
                                                                                            _rt::alloc::handle_alloc_error(layout128);
                                                                                        }
                                                                                        ptr
                                                                                    } else {
                                                                                        ::core::ptr::null_mut()
                                                                                    };
                                                                                    for (i, e) in vec128.into_iter().enumerate() {
                                                                                        let base = result128
                                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let (t126_0, t126_1) = e;
                                                                                            let vec127 = (t126_0.into_bytes()).into_boxed_slice();
                                                                                            let ptr127 = vec127.as_ptr().cast::<u8>();
                                                                                            let len127 = vec127.len();
                                                                                            ::core::mem::forget(vec127);
                                                                                            *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>() = len127;
                                                                                            *base.add(0).cast::<*mut u8>() = ptr127.cast_mut();
                                                                                            *base
                                                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<i32>() = _rt::as_i32(t126_1);
                                                                                        }
                                                                                    }
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len128;
                                                                                    *base.add(8).cast::<*mut u8>() = result128;
                                                                                }
                                                                                V139::VariantType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                                    let vec131 = e;
                                                                                    let len131 = vec131.len();
                                                                                    let layout131 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                        vec131.len()
                                                                                            * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                    let result131 = if layout131.size() != 0 {
                                                                                        let ptr = _rt::alloc::alloc(layout131).cast::<u8>();
                                                                                        if ptr.is_null() {
                                                                                            _rt::alloc::handle_alloc_error(layout131);
                                                                                        }
                                                                                        ptr
                                                                                    } else {
                                                                                        ::core::ptr::null_mut()
                                                                                    };
                                                                                    for (i, e) in vec131.into_iter().enumerate() {
                                                                                        let base = result131
                                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let (t129_0, t129_1) = e;
                                                                                            let vec130 = (t129_0.into_bytes()).into_boxed_slice();
                                                                                            let ptr130 = vec130.as_ptr().cast::<u8>();
                                                                                            let len130 = vec130.len();
                                                                                            ::core::mem::forget(vec130);
                                                                                            *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>() = len130;
                                                                                            *base.add(0).cast::<*mut u8>() = ptr130.cast_mut();
                                                                                            match t129_1 {
                                                                                                Some(e) => {
                                                                                                    *base
                                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<u8>() = (1i32) as u8;
                                                                                                    *base
                                                                                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<i32>() = _rt::as_i32(e);
                                                                                                }
                                                                                                None => {
                                                                                                    *base
                                                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<u8>() = (0i32) as u8;
                                                                                                }
                                                                                            };
                                                                                        }
                                                                                    }
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len131;
                                                                                    *base.add(8).cast::<*mut u8>() = result131;
                                                                                }
                                                                                V139::EnumType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                                                                    let vec133 = e;
                                                                                    let len133 = vec133.len();
                                                                                    let layout133 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                        vec133.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                    let result133 = if layout133.size() != 0 {
                                                                                        let ptr = _rt::alloc::alloc(layout133).cast::<u8>();
                                                                                        if ptr.is_null() {
                                                                                            _rt::alloc::handle_alloc_error(layout133);
                                                                                        }
                                                                                        ptr
                                                                                    } else {
                                                                                        ::core::ptr::null_mut()
                                                                                    };
                                                                                    for (i, e) in vec133.into_iter().enumerate() {
                                                                                        let base = result133
                                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let vec132 = (e.into_bytes()).into_boxed_slice();
                                                                                            let ptr132 = vec132.as_ptr().cast::<u8>();
                                                                                            let len132 = vec132.len();
                                                                                            ::core::mem::forget(vec132);
                                                                                            *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>() = len132;
                                                                                            *base.add(0).cast::<*mut u8>() = ptr132.cast_mut();
                                                                                        }
                                                                                    }
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len133;
                                                                                    *base.add(8).cast::<*mut u8>() = result133;
                                                                                }
                                                                                V139::FlagsType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                                                                    let vec135 = e;
                                                                                    let len135 = vec135.len();
                                                                                    let layout135 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                                        vec135.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                    let result135 = if layout135.size() != 0 {
                                                                                        let ptr = _rt::alloc::alloc(layout135).cast::<u8>();
                                                                                        if ptr.is_null() {
                                                                                            _rt::alloc::handle_alloc_error(layout135);
                                                                                        }
                                                                                        ptr
                                                                                    } else {
                                                                                        ::core::ptr::null_mut()
                                                                                    };
                                                                                    for (i, e) in vec135.into_iter().enumerate() {
                                                                                        let base = result135
                                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let vec134 = (e.into_bytes()).into_boxed_slice();
                                                                                            let ptr134 = vec134.as_ptr().cast::<u8>();
                                                                                            let len134 = vec134.len();
                                                                                            ::core::mem::forget(vec134);
                                                                                            *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>() = len134;
                                                                                            *base.add(0).cast::<*mut u8>() = ptr134.cast_mut();
                                                                                        }
                                                                                    }
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len135;
                                                                                    *base.add(8).cast::<*mut u8>() = result135;
                                                                                }
                                                                                V139::TupleType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                                                                    let vec136 = (e).into_boxed_slice();
                                                                                    let ptr136 = vec136.as_ptr().cast::<u8>();
                                                                                    let len136 = vec136.len();
                                                                                    ::core::mem::forget(vec136);
                                                                                    *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>() = len136;
                                                                                    *base.add(8).cast::<*mut u8>() = ptr136.cast_mut();
                                                                                }
                                                                                V139::ListType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                V139::OptionType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                                                }
                                                                                V139::ResultType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                                                                    let (t137_0, t137_1) = e;
                                                                                    match t137_0 {
                                                                                        Some(e) => {
                                                                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                                            *base.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                        }
                                                                                        None => {
                                                                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                    };
                                                                                    match t137_1 {
                                                                                        Some(e) => {
                                                                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                                                                        }
                                                                                        None => {
                                                                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                    };
                                                                                }
                                                                                V139::PrimU8Type => {
                                                                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                                                                }
                                                                                V139::PrimU16Type => {
                                                                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                                                                }
                                                                                V139::PrimU32Type => {
                                                                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                                                                }
                                                                                V139::PrimU64Type => {
                                                                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                                                                }
                                                                                V139::PrimS8Type => {
                                                                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                                                                }
                                                                                V139::PrimS16Type => {
                                                                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                                                                }
                                                                                V139::PrimS32Type => {
                                                                                    *base.add(0).cast::<u8>() = (14i32) as u8;
                                                                                }
                                                                                V139::PrimS64Type => {
                                                                                    *base.add(0).cast::<u8>() = (15i32) as u8;
                                                                                }
                                                                                V139::PrimF32Type => {
                                                                                    *base.add(0).cast::<u8>() = (16i32) as u8;
                                                                                }
                                                                                V139::PrimF64Type => {
                                                                                    *base.add(0).cast::<u8>() = (17i32) as u8;
                                                                                }
                                                                                V139::PrimCharType => {
                                                                                    *base.add(0).cast::<u8>() = (18i32) as u8;
                                                                                }
                                                                                V139::PrimBoolType => {
                                                                                    *base.add(0).cast::<u8>() = (19i32) as u8;
                                                                                }
                                                                                V139::PrimStringType => {
                                                                                    *base.add(0).cast::<u8>() = (20i32) as u8;
                                                                                }
                                                                                V139::HandleType(e) => {
                                                                                    *base.add(0).cast::<u8>() = (21i32) as u8;
                                                                                    let (t138_0, t138_1) = e;
                                                                                    *base.add(8).cast::<i64>() = _rt::as_i64(t138_0);
                                                                                    *base.add(16).cast::<u8>() = (t138_1.clone() as i32) as u8;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len140;
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>() = result140;
                                                                }
                                                                V143::Text(e) => {
                                                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                    let super::super::super::super::golem::agent::common::TextType {
                                                                        language_code: language_code141,
                                                                    } = e;
                                                                    let vec142 = (language_code141.into_bytes())
                                                                        .into_boxed_slice();
                                                                    let ptr142 = vec142.as_ptr().cast::<u8>();
                                                                    let len142 = vec142.len();
                                                                    ::core::mem::forget(vec142);
                                                                    *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len142;
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>() = ptr142.cast_mut();
                                                                }
                                                            }
                                                        }
                                                    }
                                                    *base
                                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len144;
                                                    *base
                                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = result144;
                                                }
                                                V149::Multimodal(e) => {
                                                    *base
                                                        .add(11 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    let super::super::super::super::golem::agent::common::Multimodal {
                                                        text: text145,
                                                    } = e;
                                                    match text145 {
                                                        Some(e) => {
                                                            *base
                                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>() = (1i32) as u8;
                                                            let vec148 = e;
                                                            let len148 = vec148.len();
                                                            let layout148 = _rt::alloc::Layout::from_size_align_unchecked(
                                                                vec148.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                            let result148 = if layout148.size() != 0 {
                                                                let ptr = _rt::alloc::alloc(layout148).cast::<u8>();
                                                                if ptr.is_null() {
                                                                    _rt::alloc::handle_alloc_error(layout148);
                                                                }
                                                                ptr
                                                            } else {
                                                                ::core::ptr::null_mut()
                                                            };
                                                            for (i, e) in vec148.into_iter().enumerate() {
                                                                let base = result148
                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let super::super::super::super::golem::agent::common::TextType {
                                                                        language_code: language_code146,
                                                                    } = e;
                                                                    let vec147 = (language_code146.into_bytes())
                                                                        .into_boxed_slice();
                                                                    let ptr147 = vec147.as_ptr().cast::<u8>();
                                                                    let len147 = vec147.len();
                                                                    ::core::mem::forget(vec147);
                                                                    *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>() = len147;
                                                                    *base.add(0).cast::<*mut u8>() = ptr147.cast_mut();
                                                                }
                                                            }
                                                            *base
                                                                .add(14 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>() = len148;
                                                            *base
                                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>() = result148;
                                                        }
                                                        None => {
                                                            *base
                                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>() = (0i32) as u8;
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                    }
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len150;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result150;
                                }
                            }
                            *base
                                .add(19 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len151;
                            *base
                                .add(18 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result151;
                        }
                    }
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len152;
                    *ptr1.add(0).cast::<*mut u8>() = result152;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_discover_agent_types<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base239 = l0;
                    let len239 = l1;
                    for i in 0..len239 {
                        let base = base239
                            .add(i * (20 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                            let l4 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                            let l6 = i32::from(
                                *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l6 {
                                0 => {}
                                _ => {
                                    let l7 = *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                            }
                            let l9 = *base
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l10 = *base
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l9, l10, 1);
                            let l11 = i32::from(
                                *base
                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l11 {
                                0 => {}
                                _ => {
                                    let l12 = *base
                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l13 = *base
                                        .add(11 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                            }
                            let l14 = i32::from(
                                *base
                                    .add(12 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l14 {
                                0 => {
                                    let l15 = *base
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l16 = *base
                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base47 = l15;
                                    let len47 = l16;
                                    for i in 0..len47 {
                                        let base = base47
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l17 = i32::from(*base.add(0).cast::<u8>());
                                            match l17 {
                                                0 => {
                                                    let l18 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l19 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base44 = l18;
                                                    let len44 = l19;
                                                    for i in 0..len44 {
                                                        let base = base44.add(i * 24);
                                                        {
                                                            let l20 = i32::from(*base.add(0).cast::<u8>());
                                                            match l20 {
                                                                0 => {
                                                                    let l21 = *base.add(8).cast::<*mut u8>();
                                                                    let l22 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base25 = l21;
                                                                    let len25 = l22;
                                                                    for i in 0..len25 {
                                                                        let base = base25
                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l23 = *base.add(0).cast::<*mut u8>();
                                                                            let l24 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l23, l24, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base25,
                                                                        len25 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                1 => {
                                                                    let l26 = *base.add(8).cast::<*mut u8>();
                                                                    let l27 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base30 = l26;
                                                                    let len30 = l27;
                                                                    for i in 0..len30 {
                                                                        let base = base30
                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l28 = *base.add(0).cast::<*mut u8>();
                                                                            let l29 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l28, l29, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base30,
                                                                        len30 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                2 => {
                                                                    let l31 = *base.add(8).cast::<*mut u8>();
                                                                    let l32 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base35 = l31;
                                                                    let len35 = l32;
                                                                    for i in 0..len35 {
                                                                        let base = base35
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l33 = *base.add(0).cast::<*mut u8>();
                                                                            let l34 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l33, l34, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base35,
                                                                        len35 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                3 => {
                                                                    let l36 = *base.add(8).cast::<*mut u8>();
                                                                    let l37 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base40 = l36;
                                                                    let len40 = l37;
                                                                    for i in 0..len40 {
                                                                        let base = base40
                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                        {
                                                                            let l38 = *base.add(0).cast::<*mut u8>();
                                                                            let l39 = *base
                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            _rt::cabi_dealloc(l38, l39, 1);
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(
                                                                        base40,
                                                                        len40 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                        ::core::mem::size_of::<*const u8>(),
                                                                    );
                                                                }
                                                                4 => {
                                                                    let l41 = *base.add(8).cast::<*mut u8>();
                                                                    let l42 = *base
                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base43 = l41;
                                                                    let len43 = l42;
                                                                    _rt::cabi_dealloc(base43, len43 * 4, 4);
                                                                }
                                                                5 => {}
                                                                6 => {}
                                                                7 => {}
                                                                8 => {}
                                                                9 => {}
                                                                10 => {}
                                                                11 => {}
                                                                12 => {}
                                                                13 => {}
                                                                14 => {}
                                                                15 => {}
                                                                16 => {}
                                                                17 => {}
                                                                18 => {}
                                                                19 => {}
                                                                20 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(base44, len44 * 24, 8);
                                                }
                                                _ => {
                                                    let l45 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l46 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    _rt::cabi_dealloc(l45, l46, 1);
                                                }
                                            }
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base47,
                                        len47 * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                                _ => {
                                    let l48 = i32::from(
                                        *base
                                            .add(13 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l48 {
                                        0 => {}
                                        _ => {
                                            let l49 = *base
                                                .add(14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l50 = *base
                                                .add(15 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base53 = l49;
                                            let len53 = l50;
                                            for i in 0..len53 {
                                                let base = base53
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let l51 = *base.add(0).cast::<*mut u8>();
                                                    let l52 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    _rt::cabi_dealloc(l51, l52, 1);
                                                }
                                            }
                                            _rt::cabi_dealloc(
                                                base53,
                                                len53 * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                        }
                                    }
                                }
                            }
                            let l54 = *base
                                .add(16 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l55 = *base
                                .add(17 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base143 = l54;
                            let len143 = l55;
                            for i in 0..len143 {
                                let base = base143
                                    .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l56 = *base.add(0).cast::<*mut u8>();
                                    let l57 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l56, l57, 1);
                                    let l58 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l59 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l58, l59, 1);
                                    let l60 = i32::from(
                                        *base
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l60 {
                                        0 => {}
                                        _ => {
                                            let l61 = *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l62 = *base
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l61, l62, 1);
                                        }
                                    }
                                    let l63 = i32::from(
                                        *base
                                            .add(7 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l63 {
                                        0 => {
                                            let l64 = *base
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l65 = *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base96 = l64;
                                            let len96 = l65;
                                            for i in 0..len96 {
                                                let base = base96
                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let l66 = i32::from(*base.add(0).cast::<u8>());
                                                    match l66 {
                                                        0 => {
                                                            let l67 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l68 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base93 = l67;
                                                            let len93 = l68;
                                                            for i in 0..len93 {
                                                                let base = base93.add(i * 24);
                                                                {
                                                                    let l69 = i32::from(*base.add(0).cast::<u8>());
                                                                    match l69 {
                                                                        0 => {
                                                                            let l70 = *base.add(8).cast::<*mut u8>();
                                                                            let l71 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base74 = l70;
                                                                            let len74 = l71;
                                                                            for i in 0..len74 {
                                                                                let base = base74
                                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l72 = *base.add(0).cast::<*mut u8>();
                                                                                    let l73 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l72, l73, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base74,
                                                                                len74 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        1 => {
                                                                            let l75 = *base.add(8).cast::<*mut u8>();
                                                                            let l76 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base79 = l75;
                                                                            let len79 = l76;
                                                                            for i in 0..len79 {
                                                                                let base = base79
                                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l77 = *base.add(0).cast::<*mut u8>();
                                                                                    let l78 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l77, l78, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base79,
                                                                                len79 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        2 => {
                                                                            let l80 = *base.add(8).cast::<*mut u8>();
                                                                            let l81 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base84 = l80;
                                                                            let len84 = l81;
                                                                            for i in 0..len84 {
                                                                                let base = base84
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l82 = *base.add(0).cast::<*mut u8>();
                                                                                    let l83 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l82, l83, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base84,
                                                                                len84 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        3 => {
                                                                            let l85 = *base.add(8).cast::<*mut u8>();
                                                                            let l86 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base89 = l85;
                                                                            let len89 = l86;
                                                                            for i in 0..len89 {
                                                                                let base = base89
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l87 = *base.add(0).cast::<*mut u8>();
                                                                                    let l88 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l87, l88, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base89,
                                                                                len89 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        4 => {
                                                                            let l90 = *base.add(8).cast::<*mut u8>();
                                                                            let l91 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base92 = l90;
                                                                            let len92 = l91;
                                                                            _rt::cabi_dealloc(base92, len92 * 4, 4);
                                                                        }
                                                                        5 => {}
                                                                        6 => {}
                                                                        7 => {}
                                                                        8 => {}
                                                                        9 => {}
                                                                        10 => {}
                                                                        11 => {}
                                                                        12 => {}
                                                                        13 => {}
                                                                        14 => {}
                                                                        15 => {}
                                                                        16 => {}
                                                                        17 => {}
                                                                        18 => {}
                                                                        19 => {}
                                                                        20 => {}
                                                                        _ => {}
                                                                    }
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(base93, len93 * 24, 8);
                                                        }
                                                        _ => {
                                                            let l94 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l95 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            _rt::cabi_dealloc(l94, l95, 1);
                                                        }
                                                    }
                                                }
                                            }
                                            _rt::cabi_dealloc(
                                                base96,
                                                len96 * (3 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                        }
                                        _ => {
                                            let l97 = i32::from(
                                                *base
                                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            match l97 {
                                                0 => {}
                                                _ => {
                                                    let l98 = *base
                                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l99 = *base
                                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base102 = l98;
                                                    let len102 = l99;
                                                    for i in 0..len102 {
                                                        let base = base102
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let l100 = *base.add(0).cast::<*mut u8>();
                                                            let l101 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            _rt::cabi_dealloc(l100, l101, 1);
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(
                                                        base102,
                                                        len102 * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                }
                                            }
                                        }
                                    }
                                    let l103 = i32::from(
                                        *base
                                            .add(11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l103 {
                                        0 => {
                                            let l104 = *base
                                                .add(12 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l105 = *base
                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base136 = l104;
                                            let len136 = l105;
                                            for i in 0..len136 {
                                                let base = base136
                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let l106 = i32::from(*base.add(0).cast::<u8>());
                                                    match l106 {
                                                        0 => {
                                                            let l107 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l108 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base133 = l107;
                                                            let len133 = l108;
                                                            for i in 0..len133 {
                                                                let base = base133.add(i * 24);
                                                                {
                                                                    let l109 = i32::from(*base.add(0).cast::<u8>());
                                                                    match l109 {
                                                                        0 => {
                                                                            let l110 = *base.add(8).cast::<*mut u8>();
                                                                            let l111 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base114 = l110;
                                                                            let len114 = l111;
                                                                            for i in 0..len114 {
                                                                                let base = base114
                                                                                    .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l112 = *base.add(0).cast::<*mut u8>();
                                                                                    let l113 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l112, l113, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base114,
                                                                                len114 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        1 => {
                                                                            let l115 = *base.add(8).cast::<*mut u8>();
                                                                            let l116 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base119 = l115;
                                                                            let len119 = l116;
                                                                            for i in 0..len119 {
                                                                                let base = base119
                                                                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l117 = *base.add(0).cast::<*mut u8>();
                                                                                    let l118 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l117, l118, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base119,
                                                                                len119 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        2 => {
                                                                            let l120 = *base.add(8).cast::<*mut u8>();
                                                                            let l121 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base124 = l120;
                                                                            let len124 = l121;
                                                                            for i in 0..len124 {
                                                                                let base = base124
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l122 = *base.add(0).cast::<*mut u8>();
                                                                                    let l123 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l122, l123, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base124,
                                                                                len124 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        3 => {
                                                                            let l125 = *base.add(8).cast::<*mut u8>();
                                                                            let l126 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base129 = l125;
                                                                            let len129 = l126;
                                                                            for i in 0..len129 {
                                                                                let base = base129
                                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                {
                                                                                    let l127 = *base.add(0).cast::<*mut u8>();
                                                                                    let l128 = *base
                                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    _rt::cabi_dealloc(l127, l128, 1);
                                                                                }
                                                                            }
                                                                            _rt::cabi_dealloc(
                                                                                base129,
                                                                                len129 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                ::core::mem::size_of::<*const u8>(),
                                                                            );
                                                                        }
                                                                        4 => {
                                                                            let l130 = *base.add(8).cast::<*mut u8>();
                                                                            let l131 = *base
                                                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let base132 = l130;
                                                                            let len132 = l131;
                                                                            _rt::cabi_dealloc(base132, len132 * 4, 4);
                                                                        }
                                                                        5 => {}
                                                                        6 => {}
                                                                        7 => {}
                                                                        8 => {}
                                                                        9 => {}
                                                                        10 => {}
                                                                        11 => {}
                                                                        12 => {}
                                                                        13 => {}
                                                                        14 => {}
                                                                        15 => {}
                                                                        16 => {}
                                                                        17 => {}
                                                                        18 => {}
                                                                        19 => {}
                                                                        20 => {}
                                                                        _ => {}
                                                                    }
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(base133, len133 * 24, 8);
                                                        }
                                                        _ => {
                                                            let l134 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l135 = *base
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            _rt::cabi_dealloc(l134, l135, 1);
                                                        }
                                                    }
                                                }
                                            }
                                            _rt::cabi_dealloc(
                                                base136,
                                                len136 * (3 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                        }
                                        _ => {
                                            let l137 = i32::from(
                                                *base
                                                    .add(12 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            match l137 {
                                                0 => {}
                                                _ => {
                                                    let l138 = *base
                                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l139 = *base
                                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base142 = l138;
                                                    let len142 = l139;
                                                    for i in 0..len142 {
                                                        let base = base142
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let l140 = *base.add(0).cast::<*mut u8>();
                                                            let l141 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            _rt::cabi_dealloc(l140, l141, 1);
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(
                                                        base142,
                                                        len142 * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _rt::cabi_dealloc(
                                base143,
                                len143 * (15 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l144 = *base
                                .add(18 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l145 = *base
                                .add(19 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base238 = l144;
                            let len238 = l145;
                            for i in 0..len238 {
                                let base = base238
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l146 = *base.add(0).cast::<*mut u8>();
                                    let l147 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l146, l147, 1);
                                    let l148 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l149 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base237 = l148;
                                    let len237 = l149;
                                    for i in 0..len237 {
                                        let base = base237
                                            .add(i * (15 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l150 = *base.add(0).cast::<*mut u8>();
                                            let l151 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l150, l151, 1);
                                            let l152 = *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l153 = *base
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l152, l153, 1);
                                            let l154 = i32::from(
                                                *base
                                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            match l154 {
                                                0 => {}
                                                _ => {
                                                    let l155 = *base
                                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l156 = *base
                                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    _rt::cabi_dealloc(l155, l156, 1);
                                                }
                                            }
                                            let l157 = i32::from(
                                                *base
                                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            match l157 {
                                                0 => {
                                                    let l158 = *base
                                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l159 = *base
                                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base190 = l158;
                                                    let len190 = l159;
                                                    for i in 0..len190 {
                                                        let base = base190
                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let l160 = i32::from(*base.add(0).cast::<u8>());
                                                            match l160 {
                                                                0 => {
                                                                    let l161 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l162 = *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base187 = l161;
                                                                    let len187 = l162;
                                                                    for i in 0..len187 {
                                                                        let base = base187.add(i * 24);
                                                                        {
                                                                            let l163 = i32::from(*base.add(0).cast::<u8>());
                                                                            match l163 {
                                                                                0 => {
                                                                                    let l164 = *base.add(8).cast::<*mut u8>();
                                                                                    let l165 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base168 = l164;
                                                                                    let len168 = l165;
                                                                                    for i in 0..len168 {
                                                                                        let base = base168
                                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let l166 = *base.add(0).cast::<*mut u8>();
                                                                                            let l167 = *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>();
                                                                                            _rt::cabi_dealloc(l166, l167, 1);
                                                                                        }
                                                                                    }
                                                                                    _rt::cabi_dealloc(
                                                                                        base168,
                                                                                        len168 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                }
                                                                                1 => {
                                                                                    let l169 = *base.add(8).cast::<*mut u8>();
                                                                                    let l170 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base173 = l169;
                                                                                    let len173 = l170;
                                                                                    for i in 0..len173 {
                                                                                        let base = base173
                                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let l171 = *base.add(0).cast::<*mut u8>();
                                                                                            let l172 = *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>();
                                                                                            _rt::cabi_dealloc(l171, l172, 1);
                                                                                        }
                                                                                    }
                                                                                    _rt::cabi_dealloc(
                                                                                        base173,
                                                                                        len173 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                }
                                                                                2 => {
                                                                                    let l174 = *base.add(8).cast::<*mut u8>();
                                                                                    let l175 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base178 = l174;
                                                                                    let len178 = l175;
                                                                                    for i in 0..len178 {
                                                                                        let base = base178
                                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let l176 = *base.add(0).cast::<*mut u8>();
                                                                                            let l177 = *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>();
                                                                                            _rt::cabi_dealloc(l176, l177, 1);
                                                                                        }
                                                                                    }
                                                                                    _rt::cabi_dealloc(
                                                                                        base178,
                                                                                        len178 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                }
                                                                                3 => {
                                                                                    let l179 = *base.add(8).cast::<*mut u8>();
                                                                                    let l180 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base183 = l179;
                                                                                    let len183 = l180;
                                                                                    for i in 0..len183 {
                                                                                        let base = base183
                                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let l181 = *base.add(0).cast::<*mut u8>();
                                                                                            let l182 = *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>();
                                                                                            _rt::cabi_dealloc(l181, l182, 1);
                                                                                        }
                                                                                    }
                                                                                    _rt::cabi_dealloc(
                                                                                        base183,
                                                                                        len183 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                }
                                                                                4 => {
                                                                                    let l184 = *base.add(8).cast::<*mut u8>();
                                                                                    let l185 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base186 = l184;
                                                                                    let len186 = l185;
                                                                                    _rt::cabi_dealloc(base186, len186 * 4, 4);
                                                                                }
                                                                                5 => {}
                                                                                6 => {}
                                                                                7 => {}
                                                                                8 => {}
                                                                                9 => {}
                                                                                10 => {}
                                                                                11 => {}
                                                                                12 => {}
                                                                                13 => {}
                                                                                14 => {}
                                                                                15 => {}
                                                                                16 => {}
                                                                                17 => {}
                                                                                18 => {}
                                                                                19 => {}
                                                                                20 => {}
                                                                                _ => {}
                                                                            }
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(base187, len187 * 24, 8);
                                                                }
                                                                _ => {
                                                                    let l188 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l189 = *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    _rt::cabi_dealloc(l188, l189, 1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(
                                                        base190,
                                                        len190 * (3 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                }
                                                _ => {
                                                    let l191 = i32::from(
                                                        *base
                                                            .add(8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    match l191 {
                                                        0 => {}
                                                        _ => {
                                                            let l192 = *base
                                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l193 = *base
                                                                .add(10 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base196 = l192;
                                                            let len196 = l193;
                                                            for i in 0..len196 {
                                                                let base = base196
                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let l194 = *base.add(0).cast::<*mut u8>();
                                                                    let l195 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    _rt::cabi_dealloc(l194, l195, 1);
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(
                                                                base196,
                                                                len196 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                            let l197 = i32::from(
                                                *base
                                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            match l197 {
                                                0 => {
                                                    let l198 = *base
                                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l199 = *base
                                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base230 = l198;
                                                    let len230 = l199;
                                                    for i in 0..len230 {
                                                        let base = base230
                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                        {
                                                            let l200 = i32::from(*base.add(0).cast::<u8>());
                                                            match l200 {
                                                                0 => {
                                                                    let l201 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l202 = *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let base227 = l201;
                                                                    let len227 = l202;
                                                                    for i in 0..len227 {
                                                                        let base = base227.add(i * 24);
                                                                        {
                                                                            let l203 = i32::from(*base.add(0).cast::<u8>());
                                                                            match l203 {
                                                                                0 => {
                                                                                    let l204 = *base.add(8).cast::<*mut u8>();
                                                                                    let l205 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base208 = l204;
                                                                                    let len208 = l205;
                                                                                    for i in 0..len208 {
                                                                                        let base = base208
                                                                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let l206 = *base.add(0).cast::<*mut u8>();
                                                                                            let l207 = *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>();
                                                                                            _rt::cabi_dealloc(l206, l207, 1);
                                                                                        }
                                                                                    }
                                                                                    _rt::cabi_dealloc(
                                                                                        base208,
                                                                                        len208 * (3 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                }
                                                                                1 => {
                                                                                    let l209 = *base.add(8).cast::<*mut u8>();
                                                                                    let l210 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base213 = l209;
                                                                                    let len213 = l210;
                                                                                    for i in 0..len213 {
                                                                                        let base = base213
                                                                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let l211 = *base.add(0).cast::<*mut u8>();
                                                                                            let l212 = *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>();
                                                                                            _rt::cabi_dealloc(l211, l212, 1);
                                                                                        }
                                                                                    }
                                                                                    _rt::cabi_dealloc(
                                                                                        base213,
                                                                                        len213 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                }
                                                                                2 => {
                                                                                    let l214 = *base.add(8).cast::<*mut u8>();
                                                                                    let l215 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base218 = l214;
                                                                                    let len218 = l215;
                                                                                    for i in 0..len218 {
                                                                                        let base = base218
                                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let l216 = *base.add(0).cast::<*mut u8>();
                                                                                            let l217 = *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>();
                                                                                            _rt::cabi_dealloc(l216, l217, 1);
                                                                                        }
                                                                                    }
                                                                                    _rt::cabi_dealloc(
                                                                                        base218,
                                                                                        len218 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                }
                                                                                3 => {
                                                                                    let l219 = *base.add(8).cast::<*mut u8>();
                                                                                    let l220 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base223 = l219;
                                                                                    let len223 = l220;
                                                                                    for i in 0..len223 {
                                                                                        let base = base223
                                                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                        {
                                                                                            let l221 = *base.add(0).cast::<*mut u8>();
                                                                                            let l222 = *base
                                                                                                .add(::core::mem::size_of::<*const u8>())
                                                                                                .cast::<usize>();
                                                                                            _rt::cabi_dealloc(l221, l222, 1);
                                                                                        }
                                                                                    }
                                                                                    _rt::cabi_dealloc(
                                                                                        base223,
                                                                                        len223 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    );
                                                                                }
                                                                                4 => {
                                                                                    let l224 = *base.add(8).cast::<*mut u8>();
                                                                                    let l225 = *base
                                                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let base226 = l224;
                                                                                    let len226 = l225;
                                                                                    _rt::cabi_dealloc(base226, len226 * 4, 4);
                                                                                }
                                                                                5 => {}
                                                                                6 => {}
                                                                                7 => {}
                                                                                8 => {}
                                                                                9 => {}
                                                                                10 => {}
                                                                                11 => {}
                                                                                12 => {}
                                                                                13 => {}
                                                                                14 => {}
                                                                                15 => {}
                                                                                16 => {}
                                                                                17 => {}
                                                                                18 => {}
                                                                                19 => {}
                                                                                20 => {}
                                                                                _ => {}
                                                                            }
                                                                        }
                                                                    }
                                                                    _rt::cabi_dealloc(base227, len227 * 24, 8);
                                                                }
                                                                _ => {
                                                                    let l228 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l229 = *base
                                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    _rt::cabi_dealloc(l228, l229, 1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _rt::cabi_dealloc(
                                                        base230,
                                                        len230 * (3 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                }
                                                _ => {
                                                    let l231 = i32::from(
                                                        *base
                                                            .add(12 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    match l231 {
                                                        0 => {}
                                                        _ => {
                                                            let l232 = *base
                                                                .add(13 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l233 = *base
                                                                .add(14 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let base236 = l232;
                                                            let len236 = l233;
                                                            for i in 0..len236 {
                                                                let base = base236
                                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                {
                                                                    let l234 = *base.add(0).cast::<*mut u8>();
                                                                    let l235 = *base
                                                                        .add(::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    _rt::cabi_dealloc(l234, l235, 1);
                                                                }
                                                            }
                                                            _rt::cabi_dealloc(
                                                                base236,
                                                                len236 * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base237,
                                        len237 * (15 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                            }
                            _rt::cabi_dealloc(
                                base238,
                                len238 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                    }
                    _rt::cabi_dealloc(
                        base239,
                        len239 * (20 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                pub trait Guest {
                    type Agent: GuestAgent;
                    fn get_agent(agent_id: _rt::String) -> AgentRef;
                    fn discover_agents() -> _rt::Vec<AgentRef>;
                    fn discover_agent_types() -> _rt::Vec<AgentType>;
                }
                pub trait GuestAgent: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(wasm_import_module = "[export]golem:agent/guest")]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]agent"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(wasm_import_module = "[export]golem:agent/guest")]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]agent"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn new(agent_name: _rt::String, params: _rt::Vec<WitValue>) -> Self;
                    fn get_id(&self) -> _rt::String;
                    /// In the future, it will be possible
                    /// in the future, this will be result
                    fn invoke(
                        &self,
                        method_name: _rt::String,
                        input: _rt::Vec<WitValue>,
                    ) -> StatusUpdate;
                    fn get_definition(&self) -> AgentType;
                }
                #[doc(hidden)]
                macro_rules! __export_golem_agent_guest_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "golem:agent/guest#[constructor]agent")] unsafe extern "C" fn
                        export_constructor_agent(arg0 : * mut u8, arg1 : usize, arg2 : *
                        mut u8, arg3 : usize,) -> i32 { unsafe { $($path_to_types)*::
                        _export_constructor_agent_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Agent > (arg0, arg1, arg2, arg3) } } #[unsafe
                        (export_name = "golem:agent/guest#[method]agent.get-id")] unsafe
                        extern "C" fn export_method_agent_get_id(arg0 : * mut u8,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_method_agent_get_id_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Agent > (arg0) } } #[unsafe (export_name =
                        "cabi_post_golem:agent/guest#[method]agent.get-id")] unsafe
                        extern "C" fn _post_return_method_agent_get_id(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_method_agent_get_id::<<$ty as $($path_to_types)*::
                        Guest >::Agent > (arg0) } } #[unsafe (export_name =
                        "golem:agent/guest#[method]agent.invoke")] unsafe extern "C" fn
                        export_method_agent_invoke(arg0 : * mut u8, arg1 : * mut u8, arg2
                        : usize, arg3 : * mut u8, arg4 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_method_agent_invoke_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Agent > (arg0, arg1, arg2, arg3,
                        arg4) } } #[unsafe (export_name =
                        "cabi_post_golem:agent/guest#[method]agent.invoke")] unsafe
                        extern "C" fn _post_return_method_agent_invoke(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_method_agent_invoke::<<$ty as $($path_to_types)*::
                        Guest >::Agent > (arg0) } } #[unsafe (export_name =
                        "golem:agent/guest#[method]agent.get-definition")] unsafe extern
                        "C" fn export_method_agent_get_definition(arg0 : * mut u8,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_method_agent_get_definition_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Agent > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:agent/guest#[method]agent.get-definition")]
                        unsafe extern "C" fn
                        _post_return_method_agent_get_definition(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_method_agent_get_definition::<<$ty as
                        $($path_to_types)*:: Guest >::Agent > (arg0) } } #[unsafe
                        (export_name = "golem:agent/guest#get-agent")] unsafe extern "C"
                        fn export_get_agent(arg0 : * mut u8, arg1 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_get_agent_cabi::<$ty >
                        (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_golem:agent/guest#get-agent")] unsafe extern "C" fn
                        _post_return_get_agent(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_get_agent::<$ty > (arg0) } }
                        #[unsafe (export_name = "golem:agent/guest#discover-agents")]
                        unsafe extern "C" fn export_discover_agents() -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_discover_agents_cabi::<$ty
                        > () } } #[unsafe (export_name =
                        "cabi_post_golem:agent/guest#discover-agents")] unsafe extern "C"
                        fn _post_return_discover_agents(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_discover_agents::<$ty > (arg0)
                        } } #[unsafe (export_name =
                        "golem:agent/guest#discover-agent-types")] unsafe extern "C" fn
                        export_discover_agent_types() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_discover_agent_types_cabi::<$ty > ()
                        } } #[unsafe (export_name =
                        "cabi_post_golem:agent/guest#discover-agent-types")] unsafe
                        extern "C" fn _post_return_discover_agent_types(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_discover_agent_types::<$ty > (arg0) } } const _ :
                        () = { #[doc(hidden)] #[unsafe (export_name =
                        "golem:agent/guest#[dtor]agent")] #[allow(non_snake_case)] unsafe
                        extern "C" fn dtor(rep : * mut u8) { unsafe {
                        $($path_to_types)*:: Agent::dtor::< <$ty as $($path_to_types)*::
                        Guest >::Agent > (rep) } } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_agent_guest_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 20 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 20
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub use alloc_crate::vec::Vec;
    pub use alloc_crate::alloc;
    pub use alloc_crate::string::String;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }
    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }
    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }
    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn char_lift(val: u32) -> char {
        if cfg!(debug_assertions) {
            core::char::from_u32(val).unwrap()
        } else {
            core::char::from_u32_unchecked(val)
        }
    }
    pub use alloc_crate::boxed::Box;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_agentic_guest_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::golem::agent::guest::__export_golem_agent_guest_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::golem::agent::guest);
    };
}
#[doc(inline)]
pub(crate) use __export_agentic_guest_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:golem:agentic-guest:agentic-guest:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 6591] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xbb2\x01A\x02\x01A\x18\
\x01B\x05\x01r\x02\x07secondsw\x0bnanosecondsy\x04\0\x08datetime\x03\0\0\x01@\0\0\
\x01\x04\0\x03now\x01\x02\x04\0\x0aresolution\x01\x02\x03\0\x1cwasi:clocks/wall-\
clock@0.2.3\x05\0\x01B\x0a\x04\0\x08pollable\x03\x01\x01h\0\x01@\x01\x04self\x01\
\0\x7f\x04\0\x16[method]pollable.ready\x01\x02\x01@\x01\x04self\x01\x01\0\x04\0\x16\
[method]pollable.block\x01\x03\x01p\x01\x01py\x01@\x01\x02in\x04\0\x05\x04\0\x04\
poll\x01\x06\x03\0\x12wasi:io/poll@0.2.3\x05\x01\x02\x03\0\0\x08datetime\x02\x03\
\0\x01\x08pollable\x01BX\x02\x03\x02\x01\x02\x04\0\x08datetime\x03\0\0\x02\x03\x02\
\x01\x03\x04\0\x08pollable\x03\0\x02\x01r\x02\x09high-bitsw\x08low-bitsw\x04\0\x04\
uuid\x03\0\x04\x01r\x01\x04uuid\x05\x04\0\x0ccomponent-id\x03\0\x06\x01r\x02\x0c\
component-id\x07\x0bworker-names\x04\0\x09worker-id\x03\0\x08\x01z\x04\0\x0anode\
-index\x03\0\x0a\x01w\x04\0\x0bresource-id\x03\0\x0c\x01m\x02\x05owned\x08borrow\
ed\x04\0\x0dresource-mode\x03\0\x0e\x01o\x02s\x0b\x01p\x10\x01k\x0b\x01o\x02s\x12\
\x01p\x13\x01ps\x01p\x0b\x01o\x02\x12\x12\x01o\x02\x0d\x0f\x01q\x16\x0brecord-ty\
pe\x01\x11\0\x0cvariant-type\x01\x14\0\x09enum-type\x01\x15\0\x0aflags-type\x01\x15\
\0\x0atuple-type\x01\x16\0\x09list-type\x01\x0b\0\x0boption-type\x01\x0b\0\x0bre\
sult-type\x01\x17\0\x0cprim-u8-type\0\0\x0dprim-u16-type\0\0\x0dprim-u32-type\0\0\
\x0dprim-u64-type\0\0\x0cprim-s8-type\0\0\x0dprim-s16-type\0\0\x0dprim-s32-type\0\
\0\x0dprim-s64-type\0\0\x0dprim-f32-type\0\0\x0dprim-f64-type\0\0\x0eprim-char-t\
ype\0\0\x0eprim-bool-type\0\0\x10prim-string-type\0\0\x0bhandle-type\x01\x18\0\x04\
\0\x0dwit-type-node\x03\0\x19\x01p\x1a\x01r\x01\x05nodes\x1b\x04\0\x08wit-type\x03\
\0\x1c\x01r\x01\x05values\x04\0\x03uri\x03\0\x1e\x01o\x02y\x12\x01p\x7f\x01j\x01\
\x12\x01\x12\x01o\x02\x1fw\x01q\x16\x0crecord-value\x01\x16\0\x0dvariant-value\x01\
\x20\0\x0aenum-value\x01y\0\x0bflags-value\x01!\0\x0btuple-value\x01\x16\0\x0ali\
st-value\x01\x16\0\x0coption-value\x01\x12\0\x0cresult-value\x01\"\0\x07prim-u8\x01\
}\0\x08prim-u16\x01{\0\x08prim-u32\x01y\0\x08prim-u64\x01w\0\x07prim-s8\x01~\0\x08\
prim-s16\x01|\0\x08prim-s32\x01z\0\x08prim-s64\x01x\0\x0cprim-float32\x01v\0\x0c\
prim-float64\x01u\0\x09prim-char\x01t\0\x09prim-bool\x01\x7f\0\x0bprim-string\x01\
s\0\x06handle\x01#\0\x04\0\x08wit-node\x03\0$\x01p%\x01r\x01\x05nodes&\x04\0\x09\
wit-value\x03\0'\x01r\x02\x05value(\x03typ\x1d\x04\0\x0evalue-and-type\x03\0)\x01\
q\x04\x0eprotocol-error\x01s\0\x06denied\x01s\0\x09not-found\x01s\0\x15remote-in\
ternal-error\x01s\0\x04\0\x09rpc-error\x03\0+\x04\0\x08wasm-rpc\x03\x01\x04\0\x14\
future-invoke-result\x03\x01\x04\0\x12cancellation-token\x03\x01\x01i-\x01@\x01\x09\
worker-id\x09\00\x04\0\x15[constructor]wasm-rpc\x011\x01@\x01\x0ccomponent-id\x07\
\00\x04\0\x1a[static]wasm-rpc.ephemeral\x012\x01h-\x01p(\x01j\x01(\x01,\x01@\x03\
\x04self3\x0dfunction-names\x0ffunction-params4\05\x04\0![method]wasm-rpc.invoke\
-and-await\x016\x01j\0\x01,\x01@\x03\x04self3\x0dfunction-names\x0ffunction-para\
ms4\07\x04\0\x17[method]wasm-rpc.invoke\x018\x01i.\x01@\x03\x04self3\x0dfunction\
-names\x0ffunction-params4\09\x04\0'[method]wasm-rpc.async-invoke-and-await\x01:\
\x01@\x04\x04self3\x0escheduled-time\x01\x0dfunction-names\x0ffunction-params4\x01\
\0\x04\0$[method]wasm-rpc.schedule-invocation\x01;\x01i/\x01@\x04\x04self3\x0esc\
heduled-time\x01\x0dfunction-names\x0ffunction-params4\0<\x04\0/[method]wasm-rpc\
.schedule-cancelable-invocation\x01=\x01h.\x01i\x03\x01@\x01\x04self>\0?\x04\0&[\
method]future-invoke-result.subscribe\x01@\x01k5\x01@\x01\x04self>\0\xc1\0\x04\0\
\x20[method]future-invoke-result.get\x01B\x01h/\x01@\x01\x04self\xc3\0\x01\0\x04\
\0![method]cancellation-token.cancel\x01D\x01j\x01\x05\x01s\x01@\x01\x04uuids\0\xc5\
\0\x04\0\x0aparse-uuid\x01F\x01@\x01\x04uuid\x05\0s\x04\0\x0euuid-to-string\x01G\
\x01@\x01\x03vnt*\0(\x04\0\x0dextract-value\x01H\x01@\x01\x03vnt*\0\x1d\x04\0\x0c\
extract-type\x01I\x03\0\x15golem:rpc/types@0.2.1\x05\x04\x02\x03\0\x02\x08wit-ty\
pe\x01B)\x02\x03\x02\x01\x05\x04\0\x08wit-type\x03\0\0\x01q\x01\x04text\x01s\0\x04\
\0\x0fparameter-value\x03\0\x02\x01p\x03\x01q\x02\x04text\x01s\0\x0astructured\x01\
\x04\0\x04\0\x0adata-value\x03\0\x05\x01r\x01\x0dlanguage-codes\x04\0\x09text-ty\
pe\x03\0\x07\x01q\x02\x03wit\x01\x01\0\x04text\x01\x08\0\x04\0\x0eparameter-type\
\x03\0\x09\x01p\x0a\x01r\x01\x0aparameters\x0b\x04\0\x0astructured\x03\0\x0c\x01\
p\x08\x01k\x0e\x01r\x01\x04text\x0f\x04\0\x0amultimodal\x03\0\x10\x01q\x02\x0ast\
ructured\x01\x0d\0\x0amultimodal\x01\x11\0\x04\0\x0bdata-schema\x03\0\x12\x01ks\x01\
r\x04\x04name\x14\x0bdescriptions\x0bprompt-hint\x14\x0cinput-schema\x13\x04\0\x11\
agent-constructor\x03\0\x15\x01r\x05\x04names\x0bdescriptions\x0bprompt-hint\x14\
\x0cinput-schema\x13\x0doutput-schema\x13\x04\0\x0cagent-method\x03\0\x17\x01p\x18\
\x01r\x02\x0aagent-names\x07methods\x19\x04\0\x10agent-dependency\x03\0\x1a\x01p\
\x1b\x01r\x05\x09type-names\x0bdescriptions\x11agent-constructor\x16\x07methods\x19\
\x08requires\x1c\x04\0\x0aagent-type\x03\0\x1d\x01r\x02\x05stepsy\x05totaly\x04\0\
\x10progress-counter\x03\0\x1f\x01k\x20\x01r\x02\x0bdescriptions\x07counter!\x04\
\0\x0fprogress-report\x03\0\"\x01q\x01\x0dnetwork-error\0\0\x04\0\x05error\x03\0\
$\x01k#\x01q\x03\x05error\x01%\0\x08progress\x01&\0\x04emit\x01s\0\x04\0\x0dstat\
us-update\x03\0'\x03\0\x12golem:agent/common\x05\x06\x01B\x0f\x02\x03\x02\x01\x03\
\x04\0\x08pollable\x03\0\0\x01w\x04\0\x07instant\x03\0\x02\x01w\x04\0\x08duratio\
n\x03\0\x04\x01@\0\0\x03\x04\0\x03now\x01\x06\x01@\0\0\x05\x04\0\x0aresolution\x01\
\x07\x01i\x01\x01@\x01\x04when\x03\0\x08\x04\0\x11subscribe-instant\x01\x09\x01@\
\x01\x04when\x05\0\x08\x04\0\x12subscribe-duration\x01\x0a\x03\0!wasi:clocks/mon\
otonic-clock@0.2.3\x05\x07\x02\x03\0\x04\x08duration\x02\x03\0\x02\x0ccomponent-\
id\x02\x03\0\x02\x04uuid\x02\x03\0\x02\x09worker-id\x02\x03\0\x03\x0aagent-type\x01\
B\x80\x01\x02\x03\x02\x01\x08\x04\0\x08duration\x03\0\0\x02\x03\x02\x01\x09\x04\0\
\x0ccomponent-id\x03\0\x02\x02\x03\x02\x01\x0a\x04\0\x04uuid\x03\0\x04\x02\x03\x02\
\x01\x0b\x04\0\x09worker-id\x03\0\x06\x02\x03\x02\x01\x0c\x04\0\x0aagent-type\x03\
\0\x08\x01w\x04\0\x0boplog-index\x03\0\x0a\x01r\x02\x09worker-id\x07\x09oplog-id\
x\x0b\x04\0\x0apromise-id\x03\0\x0c\x01w\x04\0\x11component-version\x03\0\x0e\x01\
r\x01\x05values\x04\0\x0aaccount-id\x03\0\x10\x01ku\x01r\x05\x0cmax-attemptsy\x09\
min-delay\x01\x09max-delay\x01\x0amultiplieru\x11max-jitter-factor\x12\x04\0\x0c\
retry-policy\x03\0\x13\x01q\x03\x0fpersist-nothing\0\0\x1bpersist-remote-side-ef\
fects\0\0\x05smart\0\0\x04\0\x11persistence-level\x03\0\x15\x01m\x02\x09automati\
c\x0esnapshot-based\x04\0\x0bupdate-mode\x03\0\x17\x01m\x06\x05equal\x09not-equa\
l\x0dgreater-equal\x07greater\x0aless-equal\x04less\x04\0\x11filter-comparator\x03\
\0\x19\x01m\x04\x05equal\x09not-equal\x04like\x08not-like\x04\0\x18string-filter\
-comparator\x03\0\x1b\x01m\x07\x07running\x04idle\x09suspended\x0binterrupted\x08\
retrying\x06failed\x06exited\x04\0\x0dworker-status\x03\0\x1d\x01r\x02\x0acompar\
ator\x1c\x05values\x04\0\x12worker-name-filter\x03\0\x1f\x01r\x02\x0acomparator\x1a\
\x05value\x1e\x04\0\x14worker-status-filter\x03\0!\x01r\x02\x0acomparator\x1a\x05\
valuew\x04\0\x15worker-version-filter\x03\0#\x01r\x02\x0acomparator\x1a\x05value\
w\x04\0\x18worker-created-at-filter\x03\0%\x01r\x03\x04names\x0acomparator\x1c\x05\
values\x04\0\x11worker-env-filter\x03\0'\x01q\x05\x04name\x01\x20\0\x06status\x01\
\"\0\x07version\x01$\0\x0acreated-at\x01&\0\x03env\x01(\0\x04\0\x16worker-proper\
ty-filter\x03\0)\x01p*\x01r\x01\x07filters+\x04\0\x11worker-all-filter\x03\0,\x01\
p-\x01r\x01\x07filters.\x04\0\x11worker-any-filter\x03\0/\x01ps\x01o\x02ss\x01p2\
\x01r\x06\x09worker-id\x07\x04args1\x03env3\x06status\x1e\x11component-versionw\x0b\
retry-countw\x04\0\x0fworker-metadata\x03\04\x04\0\x0bget-workers\x03\x01\x01q\x02\
\x15revert-to-oplog-index\x01\x0b\0\x17revert-last-invocations\x01w\0\x04\0\x14r\
evert-worker-target\x03\07\x01m\x02\x08original\x06forked\x04\0\x0bfork-result\x03\
\09\x01k0\x01i6\x01@\x03\x0ccomponent-id\x03\x06filter;\x07precise\x7f\0<\x04\0\x18\
[constructor]get-workers\x01=\x01h6\x01p5\x01k?\x01@\x01\x04self>\0\xc0\0\x04\0\x1c\
[method]get-workers.get-next\x01A\x01@\0\0\x0d\x04\0\x0ecreate-promise\x01B\x01p\
}\x01@\x01\x0apromise-id\x0d\0\xc3\0\x04\0\x0dawait-promise\x01D\x01k\xc3\0\x01@\
\x01\x0apromise-id\x0d\0\xc5\0\x04\0\x0cpoll-promise\x01F\x01@\x02\x0apromise-id\
\x0d\x04data\xc3\0\0\x7f\x04\0\x10complete-promise\x01G\x01@\x01\x0apromise-id\x0d\
\x01\0\x04\0\x0edelete-promise\x01H\x01@\0\0\x0b\x04\0\x0fget-oplog-index\x01I\x01\
@\x01\x09oplog-idx\x0b\x01\0\x04\0\x0fset-oplog-index\x01J\x01@\x01\x08replicas}\
\x01\0\x04\0\x0coplog-commit\x01K\x04\0\x14mark-begin-operation\x01I\x01@\x01\x05\
begin\x0b\x01\0\x04\0\x12mark-end-operation\x01L\x01@\0\0\x14\x04\0\x10get-retry\
-policy\x01M\x01@\x01\x10new-retry-policy\x14\x01\0\x04\0\x10set-retry-policy\x01\
N\x01@\0\0\x16\x04\0\x1bget-oplog-persistence-level\x01O\x01@\x01\x15new-persist\
ence-level\x16\x01\0\x04\0\x1bset-oplog-persistence-level\x01P\x01@\0\0\x7f\x04\0\
\x14get-idempotence-mode\x01Q\x01@\x01\x0aidempotent\x7f\x01\0\x04\0\x14set-idem\
potence-mode\x01R\x01@\0\0\x05\x04\0\x18generate-idempotency-key\x01S\x01@\x03\x09\
worker-id\x07\x0etarget-version\x0f\x04mode\x18\x01\0\x04\0\x0dupdate-worker\x01\
T\x01@\0\05\x04\0\x11get-self-metadata\x01U\x01k5\x01@\x01\x09worker-id\x07\0\xd6\
\0\x04\0\x13get-worker-metadata\x01W\x01@\x03\x10source-worker-id\x07\x10target-\
worker-id\x07\x11oplog-idx-cut-off\x0b\x01\0\x04\0\x0bfork-worker\x01X\x01@\x02\x09\
worker-id\x07\x0drevert-target8\x01\0\x04\0\x0drevert-worker\x01Y\x01k\x03\x01@\x01\
\x13component-references\0\xda\0\x04\0\x14resolve-component-id\x01[\x01k\x07\x01\
@\x02\x13component-references\x0bworker-names\0\xdc\0\x04\0\x11resolve-worker-id\
\x01]\x04\0\x18resolve-worker-id-strict\x01]\x01@\x01\x08new-names\0:\x04\0\x04f\
ork\x01^\x01p\x09\x01@\0\0\xdf\0\x04\0\x14discover-agent-types\x01`\x01@\x01\x0a\
agent-types\0\xda\0\x04\0\x13get-agent-component\x01a\x03\0\x14golem:api/host@1.\
1.7\x05\x0d\x02\x03\0\x03\x0dstatus-update\x02\x03\0\x02\x09wit-value\x01B\x1c\x02\
\x03\x02\x01\x0e\x04\0\x0dstatus-update\x03\0\0\x02\x03\x02\x01\x0c\x04\0\x0aage\
nt-type\x03\0\x02\x02\x03\x02\x01\x0f\x04\0\x09wit-value\x03\0\x04\x01r\x03\x08a\
gent-ids\x0aagent-names\x0cagent-handley\x04\0\x09agent-ref\x03\0\x06\x04\0\x05a\
gent\x03\x01\x01p\x05\x01i\x08\x01@\x02\x0aagent-names\x06params\x09\0\x0a\x04\0\
\x12[constructor]agent\x01\x0b\x01h\x08\x01@\x01\x04self\x0c\0s\x04\0\x14[method\
]agent.get-id\x01\x0d\x01@\x03\x04self\x0c\x0bmethod-names\x05input\x09\0\x01\x04\
\0\x14[method]agent.invoke\x01\x0e\x01@\x01\x04self\x0c\0\x03\x04\0\x1c[method]a\
gent.get-definition\x01\x0f\x01@\x01\x08agent-ids\0\x07\x04\0\x09get-agent\x01\x10\
\x01p\x07\x01@\0\0\x11\x04\0\x0fdiscover-agents\x01\x12\x01p\x03\x01@\0\0\x13\x04\
\0\x14discover-agent-types\x01\x14\x04\0\x11golem:agent/guest\x05\x10\x04\0!gole\
m:agentic-guest/agentic-guest\x04\0\x0b\x13\x01\0\x0dagentic-guest\x03\0\0\0G\x09\
producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rus\
t\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
